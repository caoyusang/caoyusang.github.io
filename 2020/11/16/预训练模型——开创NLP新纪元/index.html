

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="caoyusang">
  <meta name="keywords" content="">
  <title>预训练模型——开创NLP新纪元 - caoyusang的科研日常</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>caoyusang</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/7.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-16 21:40" pubdate>
        2020年11月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      116
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">预训练模型——开创NLP新纪元</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：4 个月前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <h2 id="预训练模型——开创NLP新纪元"><a href="#预训练模型——开创NLP新纪元" class="headerlink" title="预训练模型——开创NLP新纪元"></a>预训练模型——开创NLP新纪元</h2><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2003.08271v3.pdf">论文地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tomohideshibata/BERT-related-papers">BERT相关论文列表</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/thunlp/PLMpapers">清华整理-预训练语言模型</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cedrickchee/awesome-bert-nlp">awesome-bert-nlp</a></p>
<p><a target="_blank" rel="noopener" href="https://bertlang.unibocconi.it/">BERT Lang Street</a></p>
<p><a target="_blank" rel="noopener" href="https://huggingface.co/models">huggingface models</a></p>
<h3 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h3><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-1.png" srcset="/img/loading.gif" class="">
<ul>
<li><p>对如今自然语言处理研究中常用的预训练模型进行了全面的概述，包括背景知识、模型架构、预训练任务、预训练模型的各种扩展、预训练模型的适应方法、预训练模型相关资源和应用。</p>
</li>
<li><p>基于现有的对预训练模型分类方法，从四个不同的角度提出了一个新的分类方法，它从四个不同的角度对现有的原型系统进行分类:</p>
<ul>
<li>表示类型</li>
<li>模型结构</li>
<li>预训练任务的类型</li>
<li>特定类型场景的扩展</li>
</ul>
</li>
<li><p>收集了大量的预训练模型的资源，包括预训练模型的开源实现、可视化工具、语料库和论文列表</p>
</li>
<li><p>针对预训练模型，提出了几个可能的未来研究方向。</p>
</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="语言表示学习"><a href="#语言表示学习" class="headerlink" title="语言表示学习"></a>语言表示学习</h4><p>一个好的语言嵌入表示应该能够蕴含文本语料中隐含的语言规则和常识信息，例如<strong>词汇的含义、句法结构、语义角色、语用学</strong>等信息。<strong>分布式表示</strong>的核心在于用<strong>低维实值向量</strong>来描述一段文本的含义，该向量的每个维度上的值都没有对应的意义，但是向量<strong>整体代表了一个具体的概念</strong>。</p>
<h5 id="与上下文无关的嵌入"><a href="#与上下文无关的嵌入" class="headerlink" title="与上下文无关的嵌入"></a>与上下文无关的嵌入</h5><p>将离散的语言符号映射到分布式嵌入空间中，具体来说，对于词汇表 <script type="math/tex">\text{V}</script> 中每个单词 <script type="math/tex">x</script> ，将其映射成一个 <script type="math/tex">d</script> 维的实值向量，由此得到一个由<strong>词汇表中全部单词的嵌入向量作为列向量</strong>的嵌入矩阵 <script type="math/tex">\text{E}^{d × |\text{V}|}</script>，矩阵的列数就是词汇表 <script type="math/tex">\text{V}</script> 中单词的总数 <script type="math/tex">|\text{V}|</script>，矩阵的行数就是嵌入向量的维度 <script type="math/tex">d</script>。因此，<strong>单词 <script type="math/tex">x</script> 的嵌入向量 <script type="math/tex">e_{x}</script> 也可以由其唯一的独热编码 <script type="math/tex">h_{x}</script>乘上嵌入矩阵得到</strong>，即</p>
<script type="math/tex; mode=display">
e_{x} = h_{x}E</script><p><strong>问题</strong></p>
<ul>
<li>嵌入是<strong>静态</strong>的，即单词的嵌入与上下文无关。然而当遇到<strong>多义词</strong>时，不跟据上下文语境的话，无法判断其真实代表的含义。</li>
<li><strong>词汇量不足</strong>。采用字符或者单词的<strong>子词</strong>作为基本表示单位。例如<strong>CharCNN、FastText</strong>和<strong>Byte-Pair Encoding</strong>等表示方法。</li>
</ul>
<h5 id="语境嵌入"><a href="#语境嵌入" class="headerlink" title="语境嵌入"></a>语境嵌入</h5><p>为了解决与上下文无关嵌入存在的问题，需要区分单词在不同语境下代表的语义。</p>
<p><strong>利用不同的神经上下文编码器 <script type="math/tex">f_{\mathrm{enc}} \left(·\right)</script> 对与上下文无关的嵌入 <script type="math/tex">x_{t}</script> 进行编码，得到蕴含上下文信息的语境嵌入 <script type="math/tex">h_{t}</script>。</strong></p>
<script type="math/tex; mode=display">
\left[\mathbf{h}_{1}, \mathbf{h}_{2}, \cdots, \mathbf{h}_{T}\right]=f_{\mathrm{enc}}\left(x_{1}, x_{2}, \cdots, x_{T}\right)</script><p>下图是展示了利用神经编码器对上下文无关嵌入向量进行编码后得到语境嵌入，然后将其用于下游的面向具体任务的模型。</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-2.png" srcset="/img/loading.gif" class="">
<h4 id="神经上下文编码器"><a href="#神经上下文编码器" class="headerlink" title="神经上下文编码器"></a>神经上下文编码器</h4><p>大多数神经上下文编码器可以归结为两类：</p>
<ul>
<li><p><strong>序列模型</strong> —— 按照顺序捕捉单词的局部上下文信息</p>
<ul>
<li><strong>卷积模型</strong> —— 将输入句子中单词的嵌入作为输入，通过卷积运算<strong>聚集</strong>某个单词来自其<strong>邻居的局部信息</strong>来获取该单词的含义</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-3.png" srcset="/img/loading.gif" class="">
<ul>
<li><strong>递归模型</strong> —— 递归模型<strong>捕捉短记忆单词的上下文表示</strong>，如<strong>LSTMs 和GRUs</strong>。从一个词的两边收集信息，但递归模型的性能往往受到<strong>长句子语义依赖问题</strong>的影响。</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-4.png" srcset="/img/loading.gif" class="">
<ul>
<li><strong>优点</strong><ul>
<li>易于训练</li>
<li>对于各种自然语言处理任务能获得良好的结果</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>学到的单词的上下文表示具有局部性偏差</li>
<li>难以捕捉单词之间的长期交互</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>非序列模型</strong> —— 非序列模型通过预先定义的单词之间的树或图结构来学习上下文表示，例如句法结构或语义关系。经典的模型包括<strong>Recursive NN、TreeLSTM和图卷积网络GCN。</strong></p>
<ul>
<li><p><strong>图模型存在的问题</strong> </p>
<ul>
<li>如何建立一个好的图结构也是一个具有挑战性的问题</li>
<li>图结构严重依赖于专家知识或外部NLP工具。</li>
</ul>
</li>
<li><p><strong>全连接自注意力模型</strong> </p>
<ul>
<li>为所有单词嵌入建立全连接图，让模型自行学习关系结构。</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-5.png" srcset="/img/loading.gif" class="">
<ul>
<li>连接权重由自注意力机制动态计算得到</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-6.png" srcset="/img/loading.gif" class="">
<ul>
<li><strong>Transformer</strong></li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-7.png" srcset="/img/loading.gif" class="">
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>直接对序列中每两个单词之间的依存关系进行建模，更强大，已成为当前预训练模型采用的主流架构</li>
<li>更适合对语言的长程依存关系进行建模</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>由于其复杂而又沉重的架构以及较小的模型偏差，Transformer通常需要一个大的训练语料库进行训练</li>
<li>训练时，容易在小的或中等大小的数据集上出现过拟合问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="预训练模型诞生背景"><a href="#预训练模型诞生背景" class="headerlink" title="预训练模型诞生背景"></a>预训练模型诞生背景</h4><p>随着深度学习的发展，模型参数的数量迅速增加。需要更大的数据集来充分训练模型参数并防止过度拟合。然而，对于大多数自然语言处理任务来说，构建大规模标注数据集是一个巨大的挑战，因为标注成本非常昂贵，尤其是对于语法和语义相关的任务。相比之下，大规模的无标签语料库相对容易构建。</p>
<p>为了利用大量未标记的文本数据，可以首先从它们那里学习一个好的表示，然后将这些表示用于其他任务。研究表明，借助于从大型未标注语料库的语料库中提取的表征，许多自然语言处理任务的性能有了显著提高。</p>
<p>预训练的优势有如下几点：</p>
<ul>
<li>在大规模文本语料库中能学习到一般的语言表示以用于下游任务</li>
<li>使得下游任务采用的模型能更好地被初始化，并获得更好的泛化表现，加速下游任务模型的收敛</li>
<li>预训练可以看作一种正则化的方式，避免模型在小规模数据上过拟合</li>
</ul>
<h4 id="预训练模型的发展史"><a href="#预训练模型的发展史" class="headerlink" title="预训练模型的发展史"></a>预训练模型的发展史</h4><p>预训练一直是学习模型参数的一种有效策略，预训练完毕之后，利用标记数据对模型参数进行微调以适应下游任务。</p>
<h5 id="第一代：预训练词嵌入"><a href="#第一代：预训练词嵌入" class="headerlink" title="第一代：预训练词嵌入"></a>第一代：预训练词嵌入</h5><p><strong>模型发展：</strong></p>
<ul>
<li><strong>NNLM</strong></li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-8.png" srcset="/img/loading.gif" class="">
<p><strong>学习任务</strong></p>
<p>输入某个句子中某个单词的前 <script type="math/tex">t-1</script> 个单词，要求NNLM网络<strong>最大化</strong>第 <script type="math/tex">t</script> 个位置出现该单词的概率，例如给定文本句子：”The most popular pre-train models is Bert”，根据前6个单词，让模型预测单词”Bert”即最大化以下概率：</p>
<script type="math/tex; mode=display">
P\left(W_{t}="Bert" \mid W_{1},W_{2},W_{3},\cdots，W_{t-1};\theta\right)</script><p>其中 <script type="math/tex">W_{i}</script> 为单词的独热编码，它们作为模型的初始输入，<script type="math/tex">W_{i}</script> 乘上矩阵 <script type="math/tex">Q</script> 之后就得到对应单词的word embedding值 <script type="math/tex">C\left(W_{i}\right)</script>。将每个单词的word embdding拼接起来，上接隐层向量，然后经过一个 <script type="math/tex">softmax</script> 层预测后面紧跟着应该接哪个词。</p>
<p>事实上，矩阵 <script type="math/tex">Q</script> 的每一行代表着对应单词的word embedding值，只不过矩阵 <script type="math/tex">Q</script> 的内容也是模型参数，需要学习获得，<script type="math/tex">Q</script> 最初用随机值初始化。当模型训练完毕，矩阵 <script type="math/tex">Q</script> 就是NNLM模型在大规模文本语料库上完成语言模型的训练任务后得到的副产品，这个 <script type="math/tex">Q</script> 的每一行都是对应单词的嵌word embedding。</p>
<ul>
<li><p><strong>Word2Vec</strong> —— 基于预测的模型(两种不同训练方式)</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-9.png" srcset="/img/loading.gif" class="">
<ul>
<li><p><strong>CBOW</strong> —— 从上下文预测中间词(完形填空)</p>
</li>
<li><p><strong>Skip-Gram</strong> —— 从中间词预测上下文</p>
</li>
</ul>
</li>
<li><p><strong>Glove</strong> —— 基于统计的模型</p>
<p>基于全局语料库构建词的<strong>共现矩阵</strong>，矩阵的每一行是一个word，每一列是context。共现矩阵就是计算每个word在每个context出现的频率。通过对词的共现计数矩阵进行降维，来得到词向量；首先需要根据整个语料建立一个大型的体现词共现情况的矩阵，其<strong>目标是优化减小重建损失</strong>(reconstruction loss)，即降维之后的向量能尽量表达原始向量的完整信息。</p>
<p>GloVe 相对于 Word2Vec 有一个优点是<strong>更容易并行化执行</strong>，可以更快，更容易地在大规模语料上训练。</p>
</li>
</ul>
<p><strong>第一代预训练词嵌入的优势：</strong></p>
<ul>
<li>尽管网络结构简单，但是仍然可以学习到高质量的单词嵌入来捕捉单词之间潜在的句法和语义相似性</li>
</ul>
<p><strong>不足之处：</strong></p>
<ul>
<li>得到的词嵌入向量与上下文无关，当词嵌入被应用于下游任务时，模型的其他参数需要重新训练。</li>
</ul>
<h5 id="第二代：预训练语境编码器"><a href="#第二代：预训练语境编码器" class="headerlink" title="第二代：预训练语境编码器"></a>第二代：预训练语境编码器</h5><p><strong>模型发展</strong>：</p>
<script type="math/tex; mode=display">
\text{ELMO} \rightarrow \text{GPT} \rightarrow \text{BERT}</script><p>由于大多数自然语言处理任务超出了单词层面，自然要在句子层面或更高层面对神经编码器进行预训练。神经编码器的输出向量也被称为上下文单词嵌入，因为它们根据单词的上下文来表示单词的语义。</p>
<p>研究者发现，序列模型<strong>Seq2Seq</strong>在做文本分类任务时，编码器和解码器的权重用两种语言模型的预训练权重初始化，然后用标记数据微调。模型的表现大大提升。</p>
<p>现如今，预训练模型通常使用<strong>更大规模</strong>的语料库、更复杂的神经网络模型结构(例如，Transformer)和新的预训练任务来训练。</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-10.png" srcset="/img/loading.gif" class="">
<ul>
<li><p><strong>ELMo</strong></p>
<ul>
<li><p><strong>预训练阶段</strong></p>
<ul>
<li>利用<strong>语言模型</strong>进行预训练，该语言模型的任务是根据单词的上下文序列正确预测该单词。</li>
<li><strong>ELMO</strong>网络结构<strong>采用了双层双向LSTM</strong>，左右两端分别是正反向的双层的LSTM编码器。</li>
<li>模型输入的句子中每个单词都能得到对应的三个嵌入向量：最底层的(<strong>黄色部分</strong>)是词嵌入Word Embedding，第一层双向LSTM中对应单词位置的Embedding，蕴含单词的<strong>句法信息</strong>；然后第二层LSTM中对应单词位置的Embedding，蕴含单词的<strong>语义信息</strong>。</li>
</ul>
</li>
<li><p><strong>微调阶段</strong></p>
<ul>
<li>将下游任务模型的输入通过ELMO进行编码得到文本嵌入，集成三种Embedding，将整合后的Embedding用于下游任务模型网络结构中对应单词的输入。</li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>采用了典型的<strong>预训练-微调</strong>的两阶段过程</li>
<li>预训练过程中，不仅学会了单词的word embedding，还学到了一个双层双向的LSTM网络结构，这个双层双向的网络结构可以用来提取文本的句法信息、语义信息。</li>
</ul>
</li>
<li><p><strong>不足</strong></p>
<ul>
<li>LSTM的<strong>特征抽取能力</strong>远比不上Transformer</li>
<li>双向拼接的<strong>融合特征的能力</strong>不够强</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>GPT</strong></p>
<ul>
<li><p><strong>预训练阶段</strong></p>
<ul>
<li>预训练的过程其实和ELMO类似，仍然以语言模型为目标任务，但是<strong>语言模型改成单向</strong>的，即只根据上文正确预测当前位置的单词，而把单词的下文完全抛开。</li>
<li>特征抽取器换成了<strong>Transformer</strong>,特征抽取的能力大大提升</li>
</ul>
</li>
<li><p><strong>微调阶段</strong></p>
<ul>
<li><p>对于不同的下游任务，<strong>网络结构要向GPT的网络结构看齐</strong>。在做下游任务的时候，利用预训练好的参数初始化GPT的网络结构，这样通过预训练学到的语言学知识就被引入到下游任务中。</p>
</li>
<li><p>模型参数初始化后，用下游任务去训练这个网络，对网络参数进行Fine-tuning，使得网络更适合解决下游问题。</p>
</li>
<li><p>改造下游任务<br>（1）对于<strong>分类</strong>问题，加上一个起始和终结符号即可；<br>（2）对于<strong>句子关系</strong>判断问题，比如Entailment NLI，两个句子中间再加个分隔符即可；<br>（3）对<strong>文本相似性</strong>判断问题，把两个句子顺序颠倒下做出两个输入即可，这是为了告诉模型句子顺序不重要；<br>（4）对于<strong>多项选择</strong>问题，则多路输入，每一路把文章和答案选项拼接作为输入即可</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-12.png" srcset="/img/loading.gif" class="">
</li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>训练的是单向语言模型</li>
<li>采用更强大的特征提取器Transformer</li>
</ul>
</li>
<li><p><strong>不足</strong></p>
<ul>
<li>单向语言模型改成双向就好了</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>BERT</strong></p>
<ul>
<li><p><strong>预训练阶段</strong></p>
<ul>
<li><p><strong>MLM(掩盖语言模型)</strong></p>
<p>（1）<strong>MLM</strong>任务，即<strong>随机屏蔽</strong>(MASK)部分输入token，然后只预测那些被屏蔽的token。</p>
<p>（2）但是这么干之后，预训练阶段和finetuning阶段之间就不匹配了，因为在finetuning期间不会见到[MASK]。为了解决这个问题，BERT的做法是：不总是用实际的[MASK]替换被“masked”的词汇。相反，训练一个数据生成器随机选择15％的token，执行以下过程：</p>
<p><strong>80％</strong>的时间：用<strong>[MASK]标记替换</strong>单词，例如，my dog is hairy → my dog is [MASK]<br><strong>10％</strong>的时间：用一个<strong>随机的单词替换</strong>该单词，例如，my dog is hairy → my dog is apple<br><strong>10％</strong>的时间：保持单词<strong>不变</strong>，例如，my dog is hairy → my dog is hairy. </p>
<p>（3）<strong>缺陷</strong>：MLM模型下，一些单词会被随机替换，而Transformer的encoder部分不知道它将被要求预测的那些单词或哪些单词已被随机单词替换，因此它被迫保持每个输入token的分布式上下文表示。同时，由于训练MLM时，每个batch只预测了15％的token，这表明模型可能需要更多的预训练步骤才能收敛。这无疑增加了训练成本。</p>
</li>
<li><p>和GPT不同的地方在于，BERT采用和ELMO一样的<strong>双向语言模型任务</strong>作为预训练任务；</p>
</li>
<li><p>和ELMO不同的地方在于，BERT采用和GPT一样的特征提取器<strong>Transformer</strong>，集两家之所长。</p>
</li>
</ul>
</li>
<li><p><strong>微调阶段</strong></p>
<ul>
<li><p>和GPT一样，BERT也面临对下游任务进行改造的问题</p>
</li>
<li><p>改造下游任务</p>
<p><strong>（1）句子对分类</strong> —— 在句子开头加上[<strong>CLS</strong>]，后接单句的组成token，句子对之间用[<strong>SEP</strong>]分隔开，最后[<strong>CLS</strong>]对应位置输出的向量 <script type="math/tex">C</script> 由于不具备特别的语义特征，因此能更好地表示整个<strong>句对的语义信息</strong>。最后， 把第一个起始符号对应的<strong>Transformer</strong>最后一层位置上的输出 <script type="math/tex">C</script> 串接一个 <script type="math/tex">\mathbf{softmax}</script> 分类层对句对关系进行分类</p>
<p><strong>（2）单句分类</strong> —— [<strong>CLS</strong>]作为句子开头，后接单句的组成token，同样[<strong>CLS</strong>]对应位置输出的向量 <script type="math/tex">C</script> 后接上一个 <script type="math/tex">\mathbf{softmax}</script>分类器对句子进行分类</p>
<p><strong>（3）问答</strong> —— [<strong>CLS</strong>]作为句子开头，问题句的组成token和背景文本句的组成token用[<strong>SEP</strong>]隔开，将每个属于背景句子的token所在对应位置的输出向量与<strong>Start</strong>向量<strong>做点积算得分</strong>，根据得分确定答案在背景文本中的起始位置，结束位置的确定也是一样。最后在背景文本中，<strong>起始位置和结束位置之间对应的这段文本就当作问题的最终回答</strong>。</p>
<p><strong>（4）序列标注</strong> —— [<strong>CLS</strong>]作为句子开头，后接单句的组成token，将每个token对应位置输出的向量输入到一个多分类器中，输出每个token的标注分类预测。</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-13.png" srcset="/img/loading.gif" class="">
</li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li><p><strong>MLM</strong>双向语言模型</p>
</li>
<li><p><strong>Transformer</strong>做特征提取器</p>
</li>
<li><p><strong>BERT</strong>输入部分的处理</p>
<p><strong>输入部分是个线性序列</strong>，两个句子通过分隔符分割，最前面和最后增加两个标识符号。每个单词有三个embedding</p>
<p>(1)<strong>单词embedding</strong> </p>
<p>​    预训练后得到的单词Embedding。</p>
<p>(2)<strong>位置embedding</strong></p>
<p>​    自注意力机制没有位置概念，每个位置等同看待，为了弄清楚token所在位置，需要引入位置嵌入，告诉模型当前的token处于句子的什么位置。</p>
<p>(3)<strong>句子embedding</strong></p>
<p>​    整个句子的Embedding代表了整个句子的语义信息，句子嵌入需要给到那个句子中每个token。</p>
<p>把单词对应的三个embedding叠加，就形成了Bert的输入。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-14.png" srcset="/img/loading.gif" class="">
<ul>
<li><p><strong>不足</strong></p>
<ul>
<li>同预训练阶段<strong>MLM</strong>模型的缺陷</li>
</ul>
</li>
</ul>
<h3 id="预训练模型概览"><a href="#预训练模型概览" class="headerlink" title="预训练模型概览"></a>预训练模型概览</h3><h4 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h4><h5 id="语言模型-LM"><a href="#语言模型-LM" class="headerlink" title="语言模型(LM)"></a>语言模型(LM)</h5><p>语言模型通常特指自回归语言模型或者单向语言模型。</p>
<ul>
<li><strong>任务</strong> —— 给定上文，根据紧接着的下一词汇在词汇表中的概率分布输出更可能的下文，即最大化句子出现的概率。给定一串文本序列 <script type="math/tex">x_{1:T} = \left[ x_{1},x_{2}, \dots, x_{T} \right]</script>，其联合分布概率可以表示为如下条件概率的乘积：</li>
</ul>
<script type="math/tex; mode=display">
p\left(\mathbf{x}_{1: T}\right)=\prod_{t=1}^{T} p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)</script><p>其中，<script type="math/tex">x_{0}</script> 为起始标记 <script type="math/tex">[Start]</script> 对应的token。上述条件概率 <script type="math/tex">p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)</script> 可以通过计算给定语境下(即上文<script type="math/tex">x_{0:t-1}</script>) 词汇表中所有词的概率分布来建模，其中，语境上文又可以通过神经编码器 <script type="math/tex">f_{enc}(·)</script> 来进行编码，利用一个预测层 <script type="math/tex">g_{LM}(·)</script> 输出词汇表中所有词在当前位置出现的概率分布。</p>
<script type="math/tex; mode=display">
p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)=g_{LM}( f_{enc}(x_{0:t-1}))</script><p>当给定一个巨大的语料库时，可以用最大似然估计来训练整个网络。</p>
<ul>
<li><strong>缺点</strong> —— 每个token的表示只编码了上文的token和它自己。然而，更好的文本语境表示应该编码来自上文和下文两个方向的上下文信息。</li>
<li><strong>改进</strong> —— 考虑单向LM的缺陷，用两个单向LM组合起来构成双向LM(BiLM)。BiLM由两个单向LM组成：一个向前的从左到右LM和一个向后的从右到左LM。</li>
<li><strong>代表模型</strong><ul>
<li>单向 —— GPT、GPT2、GPT3</li>
<li>双向 —— ELMO</li>
</ul>
</li>
</ul>
<h5 id="掩盖语言模型-MLM"><a href="#掩盖语言模型-MLM" class="headerlink" title="掩盖语言模型(MLM)"></a>掩盖语言模型(MLM)</h5><ul>
<li><strong>任务</strong> —— 完形填空(cloze task)，从文本中的其他词预测当前被掩盖位置最可能出现的词。由于是同时考虑文本的上文和下文对掩盖词进行预测，因此MLM很好地克服了标准单向线性模型语境编码不完全的缺点。</li>
<li><strong>缺点</strong> —— 由于MLM首先会从输入文本中随机掩盖掉一些token，然后用其余的token来预测掩盖掉的token。因此，这种预训练方法会在预训练阶段和微调阶段之间造成不匹配，因为 <script type="math/tex">[MASK]</script> 不会在微调阶段出现。</li>
<li><strong>改进</strong>  —— 不总是用 <script type="math/tex">[MASK]</script> 进行替换，训练一个数据生成器<ul>
<li>在80%的时间内使用特殊的[MASK]进行替换</li>
<li>在10%的时间内使用随机的token执行替换</li>
<li>在10%的时间内使用原始token来执行替换</li>
</ul>
</li>
<li><strong>代表模型</strong> —— BERT及其庞大的BERT家族</li>
</ul>
<h5 id="排列语言模型-PLM"><a href="#排列语言模型-PLM" class="headerlink" title="排列语言模型(PLM)"></a>排列语言模型(PLM)</h5><p>虽然MLM效果惊人，但是不能忽视的是，MLM在预训练中使用的一些特殊标记(如[MASK])在模型应用于下游任务时并不存在，这导致预训练和微调之间存在差距。为了克服这个问题，提出了排列语言模型PLM。</p>
<ul>
<li><strong>任务</strong> —— 基于输入序列的随机排列的语言建模。简单来说，就是从所有可能的排列中随机抽样一个排列。然后，将排列序列中的一些token作为目标，然后训练模型来预测这些目标。需要注意的是，这种随机排列不会影响序列的自然位置，仅会定义token预测的顺序。</li>
<li><strong>代表模型</strong> —— XLNet</li>
</ul>
<h5 id="去噪自编码器-DAE"><a href="#去噪自编码器-DAE" class="headerlink" title="去噪自编码器(DAE)"></a>去噪自编码器(DAE)</h5><ul>
<li><strong>任务</strong> —— 输入部分损坏的文本，重建原始的未失真的文本。</li>
</ul>
<p>破坏文本的方式有：</p>
<ol>
<li>token掩盖：从输入中随机采样token，并用[MASK]替换它们。</li>
<li>token删除：从输入中随机删除token。与掩盖token不同，模型需要确定缺失输入的位置。</li>
<li>文本填充：像SpanBERT一样，许多文本跨度被采样并用单个[MASK]标记替换。每个跨度长度由泊松分布(λ = 3)得出。该模型需要预测一个跨度中缺少多少个token。</li>
<li>句子排列：根据句号将文档分成句子，并以随机顺序排列这些句子。</li>
<li>文档翻转：随机均匀地选择一个token，并翻转文档，使其从该token开始。模型需要识别文档的真正开始位置</li>
</ol>
<h5 id="比较学习-CL"><a href="#比较学习-CL" class="headerlink" title="比较学习(CL)"></a>比较学习(CL)</h5><ul>
<li><strong>总体任务</strong> —— 假设一些观察到的文本对在语义上比随机抽样的文本更相似。学习文本对 <script type="math/tex">(x，y)</script> 的得分函数 <script type="math/tex">s(x，y)</script> 以最小化目标函数：</li>
</ul>
<script type="math/tex; mode=display">
\mathcal{L}_{\mathrm{CTL}}=\mathbb{E}_{x, y^{+}, y^{-}}\left[-\log \frac{\exp \left(s\left(x, y^{+}\right)\right)}{\exp \left(s\left(x, y^{+}\right)\right)+\exp \left(s\left(x, y^{-}\right)\right)}\right]</script><p>其中，<script type="math/tex">\left(x, y^{+}\right)</script> 是更相似的一对，<script type="math/tex">y^{+}</script> 和 <script type="math/tex">y^{-}</script> 分别为正样本和负样本。文本对的得分函数 <script type="math/tex">s(x，y)</script> 通常通过训练神经网络来学习。</p>
<p>训练的方式有两种：</p>
<script type="math/tex; mode=display">
s(x, y)=f_{\mathrm{enc}(x)}^{\mathrm{T}} f_{\mathrm{enc}(y)}</script><script type="math/tex; mode=display">
s(x, y)=f_{\text {enc }}(x \oplus y)</script><ul>
<li><strong>代表任务</strong> <ul>
<li>下一句预测(NSP) —— NSP训练模型来区分两个输入句子是否是来自训练语料库的连续片段。具体来说，在为每个预训练例子选择句子对时，50%的时候，第二句是第一句的实际下一句，50%的时候，是从语料库中随机抽取的一句。通过这样做，它能够教模型理解两个输入句子之间的关系，从而有利于对该信息敏感的下游任务，例如问答和自然语言推理。 但是NSP任务的有效性和必要性备受质疑。</li>
<li>句子顺序预测(SOP) —— 和NSP不同，SOP使用同一文档中的两个连续片段作为正面示例，使用相同的两个连续片段，但它们的顺序交换作为反面示例。</li>
</ul>
</li>
</ul>
<h4 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h4><p>为了阐明自然语言处理中现有预训练模型之间的关系，可以从四个不同的角度对现有预训练模型进行分类：</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-15.png" srcset="/img/loading.gif" class="">
<ul>
<li><p>表示类型</p>
<ul>
<li>与上下文独立的表示 —— Word2Vec、Glove等</li>
<li>与上下文相关的表示 —— ELMO、GPT、BERT等</li>
</ul>
</li>
<li><p>架构(基础网络)</p>
<ul>
<li>LSTM —— ELMO</li>
<li>Transformer<ul>
<li>encoder —— BERT</li>
<li>decoder —— GPT（使用了三角矩阵实现了掩盖自注意力机制，即不允许模型在预测的时候看到下文）</li>
<li>full</li>
</ul>
</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-16.png" srcset="/img/loading.gif" class="">
</li>
<li><p>预训练任务</p>
<ul>
<li>监督学习 —— 学习一个函数，该函数基于由输入输出对组成的训练数据将输入映射到输出。</li>
<li>无监督 —— 从未标记的数据中发现一些内在的知识，如LM。</li>
<li>自监督 —— 监督学习和非监督学习的结合，学习范式和监督学习完全一样，只是训练数据的标签是自动生成的。关键思想是从其他部分以某种形式预测输入的任何部分。如MLM。</li>
</ul>
</li>
<li><p>扩展：特定场景下的预训练模型，包括知识丰富的预训练模型、多语言或特定语言的预训练模型、多模型预训练模型、特定领域的预训练模型等</p>
</li>
</ul>
<h4 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h4><h5 id="非上下文词嵌入"><a href="#非上下文词嵌入" class="headerlink" title="非上下文词嵌入"></a>非上下文词嵌入</h5><ul>
<li><strong>思想</strong> —— 通过神经网络语言模型学习的单词表示能够捕捉语言中的语言规律，单词之间的关系可以通过特定关系的向量偏移来表征。例如，<script type="math/tex">vec(“China”) − vec(“Beijing”) ≈ vec(“Japan”) −vec(“Tokyo”)</script> ，另外，经过神经语言模型训练得到的词向量还具有组合性，<script type="math/tex">vec(“Germany”) + vec(“capital”) ≈ vec(“Berlin”)</script>。</li>
<li><strong>缺点</strong> —— 这种分布式单词表示擅长预测分类属性(例如，狗是一种动物)，但不能真正学习属性(例如，天是蓝的)。而且，考虑到多义词需要结合上下文语境进行词义的判断，而这种与上下文无关的分布式词表示往往无法代表词的正确意思。</li>
</ul>
<h5 id="上下文词嵌入"><a href="#上下文词嵌入" class="headerlink" title="上下文词嵌入"></a>上下文词嵌入</h5><ul>
<li><strong>思想</strong> —— 在做语言模型任务时，把上下文语境文本融合进词表示向量，使得词表示向量能够蕴含除词本义之外的上下文语义知识信息和语言学信息。<ul>
<li>语言学信息 —— 研究人员从BERT中提取依赖树和支持树，证明了BERT对语法结构进行编码的能力。<ul>
<li>语言特征似乎表现在单独的语义和句法子空间中</li>
<li>注意矩阵包含语法表征</li>
<li>BERT非常精细地区分词义。</li>
</ul>
</li>
<li>语义知识信息 —— 除了语言知识，预训练模型还可以存储训练数据中呈现的世界知识。探索世界知识的一个简单方法是用“填空”完形填空语句来查询BERT，例如，“但丁诞生于[MASK]”。研究人员通过从几个知识来源手动创建单标记完形填空语句(查询)来构建LAMA(语言模型分析)任务。他们的实验表明BERT包含的世界知识比传统的信息抽取方法更有竞争力。</li>
</ul>
</li>
</ul>
<h3 id="预训练模型拓展"><a href="#预训练模型拓展" class="headerlink" title="预训练模型拓展"></a>预训练模型拓展</h3><h4 id="基于知识增强"><a href="#基于知识增强" class="headerlink" title="基于知识增强"></a>基于知识增强</h4><ul>
<li><strong>思想</strong> —— 将外部知识纳入预训练模型</li>
<li><strong>代表模型</strong><ul>
<li>LIBERT —— 通过额外的语言限制任务整合语言知识</li>
<li>SentiLR —— 集成每个词的情感极性，将MLM扩展为具有标签感知能力的MLM(LA-MLM)</li>
<li>SenseBERT —— 经过预先训练，不仅可以预测掩码标记，还可以预测它们在WordNet中的超集。</li>
<li>ERNIE —— 将预先在知识图上训练的实体嵌入与文本中相应的实体提及相结合，以增强文本表示。</li>
<li>KnowBERT —— 将BERT与实体链接模型结合起来，以端到端的方式整合实体表示。</li>
<li>K-BERT —— 允许在对下游任务进行微调的过程中注入事实知识。</li>
<li>知识-文本融合模型 —— 机器阅读理解中获取相关语言和事实知识。</li>
</ul>
</li>
</ul>
<h4 id="基于多语言和特定语言"><a href="#基于多语言和特定语言" class="headerlink" title="基于多语言和特定语言"></a>基于多语言和特定语言</h4><ul>
<li>多语言<ul>
<li>跨语言理解</li>
<li>跨语言生成</li>
</ul>
</li>
<li>特定语言</li>
</ul>
<h4 id="基于多模态"><a href="#基于多模态" class="headerlink" title="基于多模态"></a>基于多模态</h4><p>这些多模态模型中的绝大多数是为一般的视觉和语言特征编码而设计的。这些模型是在大量跨模态数据的基础上进行预训练的（如带有口语词的视频或带有字幕的图像），并结合扩展的预训练任务来充分利用多模态特征。</p>
<h5 id="视频-文本-Video-Text"><a href="#视频-文本-Video-Text" class="headerlink" title="视频-文本(Video-Text)"></a>视频-文本(Video-Text)</h5><p>视频分别由基于CNN的编码器和现成的语音识别技术进行预处理。使用一个单独的Transformer编码器在处理过的数据上进行训练，学习视频字幕等下游任务的视觉语言表示。代表模型有，VideoBERT和CBT。</p>
<h5 id="图像-文本-Image-Text"><a href="#图像-文本-Image-Text" class="headerlink" title="图像-文本(Image-Text)"></a>图像-文本(Image-Text)</h5><p>引入图像-文本对，旨在微调下游任务，如视觉问题回答(<strong>VQA</strong>)和视觉常识推理(<strong>VCR</strong>)。</p>
<p><strong>分类：</strong></p>
<ul>
<li>采用两个独立的编码器来独立地表示图像和文本， 例如ViLBERT和LXMERT。</li>
<li>使用single-stream unified Transformer,虽然这些模型体系结构不同，但是在这些方法中引入了类似的预训练任务，例如MLM和图像-文本匹配。例如，VisualBERT，B2T2，VLBERT， Unicoder-VL和UNITER。</li>
</ul>
<h5 id="音频-文本-Audio-Text"><a href="#音频-文本-Audio-Text" class="headerlink" title="音频-文本(Audio-Text)"></a>音频-文本(Audio-Text)</h5><p>SpeechBERT模型试图用一个Transformer编码器编码音频和文本以建立一个端到端的语音问答(SQA)模型。</p>
<h4 id="基于特定领域与任务"><a href="#基于特定领域与任务" class="headerlink" title="基于特定领域与任务"></a>基于特定领域与任务</h4><p>大多数预训练模型都是在维基百科等通用领域语料库上进行预训练的，这限制了它们在特定领域或任务上的应用。</p>
<ul>
<li><strong>训练特定领域预训练模型</strong><ul>
<li>生物医学 —— BioBERT</li>
<li>科学 —— SciBERT </li>
<li>临床医学 —— ClinicalBERT</li>
</ul>
</li>
<li><strong>利用通用领域预训练模型适应具体任务</strong><ul>
<li>情感分析 —— 感知情感标签的MLM</li>
<li>文本摘要 —— 间歇句生成</li>
<li>不流畅检测 —— 噪声词检测</li>
</ul>
</li>
</ul>
<h4 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h4><ul>
<li><strong>动机</strong> —— 预训练模型参数量过于庞大，很难在现实应用和资源受限的设备上进行部署，因此，如何压缩模型也成为了研究的一个热点。</li>
<li><strong>模型压缩方法</strong> —— 一种减小模型尺寸和提高计算效率的潜在方法<ul>
<li><strong>模型修剪</strong> —— 去除不重要的参数，具体来说，就是去除部分神经网络(如权值、神经元、层、通道、注意头)，从而达到减小模型规模、加快推理时间的效果。修剪选择和修剪时机的把握有待研究。</li>
<li>连接权重量化 —— 用较少的比特表示参数，将精度较高的参数压缩到较低的精度。</li>
<li><strong>参数共享</strong> —— 对于那些相似的模型单元，共享它们的参数。这种方法广泛应用于CNNs、RNNs和Transformer。例如，ALBERT使用跨层参数共享和因子化嵌入参数化来减少模型的参数。虽然参数数量大大减少，但是ALBERT的训练和推理时间甚至比标准的BERT还要长。通常，参数共享不会提高推理阶段的计算效率。</li>
<li><strong>知识提取</strong> —— 在原模型的基础上，根据原模型的中间结果学习一个更小的模型</li>
<li>模块替换 —— 用更紧凑的模块替换原模型具有相似功能的模块。例如使用<strong>Theseus-Compress</strong>，压缩模型的同时保持98%的模型性能，速度是原来的1.4倍。</li>
</ul>
</li>
</ul>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-17.png" srcset="/img/loading.gif" class="">
<h3 id="预训练模型应用于下游任务"><a href="#预训练模型应用于下游任务" class="headerlink" title="预训练模型应用于下游任务"></a>预训练模型应用于下游任务</h3><h4 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h4><p>迁移学习是将知识从源任务(或领域)调整到目标任务(或领域)。</p>
<img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-18.png" srcset="/img/loading.gif" class="">
<h4 id="如何迁移"><a href="#如何迁移" class="headerlink" title="如何迁移"></a>如何迁移</h4><ul>
<li><p>选择合适的预训练任务、模型架构和语料库</p>
<ul>
<li>不同的预训练任务有各自的偏向，对不同的任务有不同的效果。例如，NSP任务使预训练模型学习了两句话之间的关系。因此，训练后的预训练模型可以受益于问答和自然语言推理(NLI)等下游任务。</li>
<li>BERT虽然能很好地解决自然语言推理任务，但是很难用于生成式的任务。</li>
<li>下游任务的数据分布应该接近预训练模型。</li>
</ul>
</li>
<li><p>选择合适的层</p>
<ul>
<li><p>给定一个预先训练的深度模型，不同的层应该捕获不同种类的信息，例如词性标注、解析、长期依赖、语义角色、共指。对于基于RNN的模型，研究表明，多层LSTM编码器的不同层学习到的表示有益于不同的任务。</p>
</li>
<li><p>有三种方法可以选择表示：</p>
<ul>
<li>只选择预先训练的静态嵌入表示，而模型的其余部分仍然需要为新的目标任务从头开始训练。这些部分无法获取更高级别的信息，而这些信息可能更有用。</li>
<li>顶层表示。最简单有效的方法是将顶层的表示馈入特定任务模型。</li>
<li>所有层。更灵活的方法是自动选择最佳层：</li>
</ul>
<script type="math/tex; mode=display">
\mathbf{r}_{t}=\gamma \sum_{l=1}^{L} \alpha_{l} \mathbf{h}_{t}^{(l)}</script><p>​            其中，<script type="math/tex">\alpha</script> 表示 <script type="math/tex">l</script> 层的软最大归一化权重，<script type="math/tex">\gamma</script>是缩放预训练模型输出的向量的标量。混合表示 <script type="math/tex">r_{t}</script> 被输入到特定任务模型中。</p>
</li>
</ul>
</li>
</ul>
<h4 id="微调策略"><a href="#微调策略" class="headerlink" title="微调策略"></a>微调策略</h4><ul>
<li><strong>两阶段微调</strong> —— 在第一阶段，预训练模型被转换成一个由中间任务或语料库微调的模型。在第二阶段，转移的模型被微调到目标任务。</li>
<li><strong>多任务微调</strong> —— 多任务学习框架下的微调BERT，多任务学习和预训练是互补的技术。</li>
<li><strong>使用额外的自适应模块进行微调</strong> —— 微调的主要缺点是参数效率低，每个下游任务都有自己的微调参数。因此，更好的解决方案是在原始参数固定的情况下，往预训练模型中注入一些可微调的自适应模块。</li>
</ul>
<h3 id="预训练模型资源"><a href="#预训练模型资源" class="headerlink" title="预训练模型资源"></a>预训练模型资源</h3><ul>
<li><strong>预训练模型的开源实现</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tmikolov/word2vec">word2vec</a></li>
<li><a target="_blank" rel="noopener" href="https://nlp.stanford.edu/projects/glove">GloVe</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebookresearch/fastText">FastText</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/huggingface/transformers">Transformer</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pytorch/fairseq">Fairseq</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/flairNLP/flair">Flair</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/allenai/allennlp">AllenNLP</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/fastnlp/fastNLP">fastNLP</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/unilm">UniLMs</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ymcui/Chinese-BERT-wwm">Chinese-BERT</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google-research/bert">BERT</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pytorch/fairseq/tree/master/examples/roberta">RoBERTa</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zihangdai/xlnet/">XLNet</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google-research/ALBERT">ALBERT</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google-research/text-to-text-transfer-transformer">T5</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/PaddlePaddle/ERNIE">ERNIE</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/salesforce/ctrl">CTRL</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jessevig/bertviz">BertViz</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bhoov/exbert">exBERT</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/airaria/TextBrewer">TextBrewer</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/deepmipt/DeepPavlov">DeepPavlov</a></li>
</ul>
</li>
<li>语料库<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jcpeterson/openwebtext">OpenWebText</a></li>
<li><a target="_blank" rel="noopener" href="http://commoncrawl.org/">Common Crawl</a></li>
<li><a target="_blank" rel="noopener" href="https://dumps.wikimedia.org/enwiki/">WikiEn</a></li>
</ul>
</li>
</ul>
<h3 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h3><ul>
<li>预训练模型还未到达上限 —— 模型可以通过更多的训练步骤和更大的语料库来进一步改进。</li>
<li>预训练模型架构优化 —— 为预训练模型寻找更有效的模型架构对于获取更大范围的上下文信息非常重要。深度架构的设计具有挑战性，可能会寻求一些自动化方法的帮助，比如神经架构搜索。</li>
<li>面向任务的预训练和模型压缩</li>
<li>实现超越微调的知识转移</li>
<li>提高预训练模型的可解释性和可靠性</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] Qiu X, Sun T, Xu Y, et al. Pre-trained models for natural language processing: A survey[J]. arXiv preprint arXiv:2003.08271, 2020.</p>
<p>[2] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.</p>
<p>[3] Radford A, Narasimhan K, Salimans T, et al. Improving language understanding by generative pre-training[J]. 2018.</p>
<p>[4] Yang Z, Dai Z, Yang Y, et al. Xlnet: Generalized autoregressive pretraining for language understanding[C]//Advances in neural information processing systems. 2019: 5753-5763.</p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/49271699">从Word Embedding到Bert模型—自然语言处理中的预训练技术发展史 by 张俊林</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/">常识推理</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/NLP/">NLP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">常识问答大比拼</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/">
                        <span class="hidden-mobile">常识Transformer用于自动知识图构建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "预训练模型——开创NLP新纪元&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  











</body>
</html>
