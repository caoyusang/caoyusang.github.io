<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="/2021/05/28/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2021/05/28/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收(GC)"></a>垃圾回收(GC)</h2><h3 id="1-哪些是垃圾？"><a href="#1-哪些是垃圾？" class="headerlink" title="1.哪些是垃圾？"></a>1.哪些是垃圾？</h3><p>堆中存放了几乎所有的对象实例，在垃圾收集器对堆进行垃圾回收时，首先要确定的就是堆中对象是否存活。</p><p>判断对象是否存活有两种方法：引用计数法和可达性分析法。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><code>引用计数法</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>方法描述</strong></th><th style="text-align:center"><strong>给对象中<code>添加一个引用计数器</code>，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>优点</strong></td><td style="text-align:center"><strong>实现<code>简单</code>，效率高</strong></td></tr><tr><td style="text-align:center"><strong>缺点</strong></td><td style="text-align:center"><strong>很难解决对象之间<code>相互循环引用</code>的问题</strong></td></tr></tbody></table></div><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a><code>可达性分析法</code></h4><p>通过一系列的称为<code>“GC Roots”</code>的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为<code>引用链</code>，当一个对象到 GC Roots <code>没有任何引用链相连的话，则证明此对象是不可用的</code></p><p><code>GC Roots对象集合(GC Root Set)</code>中可能包含的对象：</p><ul><li>虚拟机栈(栈帧中的<code>本地变量表</code>)中引用的对象</li><li>本地方法栈(<code>Native 方法</code>)中引用的对象</li><li>方法区中<code>类静态属性</code>引用的对象</li><li>方法区中<code>常量</code>引用的对象</li><li>所有被<code>同步锁持有</code>的对象</li></ul><h3 id="2-引用分类"><a href="#2-引用分类" class="headerlink" title="2.引用分类"></a>2.引用分类</h3><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">回收时间</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">强引用</td><td style="text-align:center">一直存活，除非GC Roots不可达</td><td style="text-align:center">所有程序的场景，基本对象，自定义对象等</td></tr><tr><td style="text-align:center">软引用</td><td style="text-align:center">内存不足时会被回收</td><td style="text-align:center">一般用在对内存非常敏感的资源上，用作缓存的场景比较多</td></tr><tr><td style="text-align:center">弱引用</td><td style="text-align:center">只能存活到下一次GC前</td><td style="text-align:center">生命周期很短的对象，例如ThreadLocal中的Key。</td></tr><tr><td style="text-align:center">虚引用</td><td style="text-align:center">随时会被回收</td><td style="text-align:center">可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td></tr></tbody></table></div><h3 id="3-GC分类"><a href="#3-GC分类" class="headerlink" title="3.GC分类"></a>3.GC分类</h3><h4 id="Partial-GC"><a href="#Partial-GC" class="headerlink" title="Partial GC"></a><code>Partial GC</code></h4><p><code>部分收集</code>，针对堆不同年代的对象进行垃圾回收。</p><ul><li>新生代收集(Minor GC) —— 只对新生代进行垃圾收集</li><li>老年代收集(Major GC) —— 只对老年代进行垃圾收集</li><li>混合收集(Mixed GC) —— 对<code>整个新生代</code>和<code>部分老年代</code>进行垃圾收集</li></ul><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a><code>Full GC</code></h4><p><code>整堆收集</code>，收集整个Java堆和方法区。</p><h3 id="4-GC算法"><a href="#4-GC算法" class="headerlink" title="4.GC算法"></a>4.GC算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><code>标记-清除算法</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>方法概述</strong></th><th style="text-align:center"><strong>先标记(垃圾判定)需要回收的对象，标记完成后，进行统一回收</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>执行效率不稳定</code></strong></td><td style="text-align:center"><strong>标记和清除两个过程的<code>执行效率随着需要回收的对象的数量增长而降低</code></strong></td></tr><tr><td style="text-align:center"><strong><code>导致内存空间碎片化</code></strong></td><td style="text-align:center"><strong>标记、清除后会产生大量不连续的内存碎片；这会导致<code>当需要分配较大对象的时候没办法找到足够的连续内存进行分配</code>，因此不得不提前触发另一次GC</strong></td></tr></tbody></table></div><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a><code>标记-复制算法</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center">方法概述</th><th style="text-align:center">将可用内存分为大小相同的两块，每次只使用其中一块进行内存分配，当这一块的内存用完了，进行垃圾回收后，将仍存活的对象复制到另外一块保留的内存上，再把已使用过的内存空间一次清理掉</th></tr></thead><tbody><tr><td style="text-align:center"><strong>优点</strong></td><td style="text-align:center"><strong>实现简单，运行高效，给对象分配内存<code>不会存在空间碎片</code>的情况</strong></td></tr><tr><td style="text-align:center"><strong><code>内存空间浪费严重</code></strong></td><td style="text-align:center"><strong>可用内存直接减半</strong></td></tr><tr><td style="text-align:center"><strong><code>不适合老年代GC</code></strong></td><td style="text-align:center"><strong>老年代对象存活时间长，GC时需要复制的对象很多，这样将<code>产生大量的内存间复制的开销</code>，相反，适合作为新生代区域的收集算法</strong></td></tr></tbody></table></div><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><code>标记-整理算法</code></h4><p>根据<code>老年代的特点提出的一种标记算法</code>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<code>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</code>。</p><h3 id="5-GC收集器"><a href="#5-GC收集器" class="headerlink" title="5.GC收集器"></a>5.GC收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>特点</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>最基本也是历史最悠久的垃圾收集器</strong></td><td style="text-align:center"><strong>-</strong></td></tr><tr><td style="text-align:center"><strong><code>单线程</code></strong></td><td style="text-align:center"><strong>只会用一个垃圾收集线程完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程（<code>咋瓦鲁多？</code>）</strong></td></tr><tr><td style="text-align:center"><strong>垃圾回收策略</strong></td><td style="text-align:center"><strong>新生代（标记-复制）、老年代（标记-整理）</strong></td></tr><tr><td style="text-align:center"><strong><code>简单高效</code></strong></td><td style="text-align:center"><strong>没有多线程交互的开销，可以获得很高的单线程收集效率</strong></td></tr><tr><td style="text-align:center"><strong>适合运行在<code>Client</code>模式下的虚拟机</strong></td><td style="text-align:center"><strong>-</strong></td></tr></tbody></table></div><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>特点</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial收集器的<code>多线程版本</code></strong></td><td style="text-align:center"><strong>除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</strong></td></tr><tr><td style="text-align:center"><strong><code>多线程</code></strong></td><td style="text-align:center"><strong>默认开启的收集线程数目和处理器的核心数目相同</strong></td></tr><tr><td style="text-align:center"><strong>垃圾回收策略</strong></td><td style="text-align:center"><strong>新生代（标记-复制）、老年代（标记-整理）</strong></td></tr><tr><td style="text-align:center"><strong>适合运行在<code>server</code>模式下的虚拟机</strong></td><td style="text-align:center"><strong>-</strong></td></tr></tbody></table></div><h5 id="收集器中的并发vs并行"><a href="#收集器中的并发vs并行" class="headerlink" title="收集器中的并发vs并行"></a><code>收集器中的并发vs并行</code></h5><ul><li>并行（Parallel） —— 描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程处于等待状态。</li><li>并发（Concurrent）—— 描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程和用户线程都在运行。由于用户线程未被冻结，所以程序仍然能响应服务请求，但是这时由于垃圾收集器线程占用了一部分系统资源，此时应用程序处理的吞吐量将受一定的影响。</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a><code>Parallel Scavenge收集器</code></h4><p>使用标记-复制算法的多线程收集器，看上去几乎和 ParNew 一样。只不过Parallel Scavenge 收集器关注点是吞吐量即如何高效率地利用CPU。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>特点</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>目标在于达到一个<code>可控的服务吞吐量</code></strong></td><td style="text-align:center"><strong>吞吐量就是CPU用于运行用户代码的时间与CPU总耗时的比值</strong></td></tr><tr><td style="text-align:center"><strong><code>控制吞吐量的参数</code></strong></td><td style="text-align:center"><strong>-XX: MaxGCPauseMillis(最大垃圾收集停顿时间)，-XX: GCTimeRatio(直接设置吞吐量大小)</strong></td></tr><tr><td style="text-align:center"><strong>多线程</strong></td><td style="text-align:center"><strong>-</strong></td></tr><tr><td style="text-align:center"><strong>垃圾回收策略</strong></td><td style="text-align:center"><strong>新生代（标记-复制）、老年代（标记-整理）</strong></td></tr></tbody></table></div><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><strong>Serial Old收集器</strong></h4><p><strong>Serial 收集器的<code>老年代版本</code>，它同样是一个<code>单线程</code>收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</strong></p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h4><p><strong>Parallel Scavenge 收集器的<code>老年代版本</code>。使用<code>多线程和“标记-整理”</code>算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑Parallel Scavenge 收集器和Parallel Old收集器的组合。</strong></p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><strong><code>CMS收集器</code></strong></h4><p>Concurrent <code>Mark Sweep</code>收集器以<code>获取最短回收停顿时间</code>为目标。从名字上就能看出来，CMS收集器是基于<code>标记-清除</code>算法实现的，运行过程主要包括以下四个步骤：</p><ol><li>初始标记 —— 标记GC Roots能直接关联到的对象，速度快，需要”咋瓦鲁多“</li><li>并发标记 —— 从GC Roots的直接关联对象开始遍历整个对象图（进行可达性分析），速度慢，不需要停顿用户线程，可以和垃圾收集线程并发运行</li><li>重新标记 —— 修正在并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，速度快，耗时略比初始标记长一些</li><li>并发清除 —— 清理标记阶段判断已经死亡的对象，由于不用移动存活对象，因此这个阶段也可以和用户线程并发执行</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">初始标记</th><th style="text-align:center">并发标记</th><th style="text-align:center">重新标记</th><th style="text-align:center">并发清除</th></tr></thead><tbody><tr><td style="text-align:center">过程</td><td style="text-align:center">标记GC Roots能<code>直接关联到的对象</code></td><td style="text-align:center"><code>从GC Roots的直接关联对象开始遍历整个对象图</code></td><td style="text-align:center"><code>修正</code>在并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录</td><td style="text-align:center">清理标记阶段判断已经死亡的对象</td></tr><tr><td style="text-align:center">速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td><td style="text-align:center">快，略比初始标记时间长</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><code>能否与用户线程并发执行</code></td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table></div><h5 id="CMS收集器的优缺点"><a href="#CMS收集器的优缺点" class="headerlink" title="CMS收集器的优缺点"></a><code>CMS收集器的优缺点</code></h5><p><code>优点</code></p><ul><li>并发收集、低停顿（服务响应速度快），可以给用户带来良好的交互体验</li></ul><p><code>缺点</code></p><ul><li>对处理器资源十分敏感。CMS<code>默认启动的回收线程数是(CPU核心线程数+3)/4</code>，当CPU的核心数大于等于4时，使用CMS收集器进行垃圾回收，垃圾回收线程只占用不超过四分之一的CPU运算资源，而当CPU核心数小于4时，CPU能提供的负载本来就有限，还要分出将近一半的运算能力去执行垃圾收集器线程，则会就会导致用户程序的执行速度忽然大幅降低。</li><li>无法处理“浮动垃圾”。并发清理阶段，用户线程仍在继续运行，会不断地产生垃圾对象，而这一部分垃圾对象出现在标记过程结束之后，CMS无法在当次收集过程中处理它们，只能留待下一次垃圾收集再进行处理，这部分垃圾就是“浮动垃圾”。</li><li>产生大量空间碎片。因为CMS收集器在垃圾清除阶段使用的是“标记-清除”算法。</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><code>G1收集器</code></h4><p>Garbage First收集器（G1）是一款<code>面向服务端应用</code>的垃圾收集器，JDK9发布之后，G1收集器宣告取代Parallel Scavenge+Parallel Old组合，成为<code>服务端模式下的默认垃圾收集器</code>。G1收集器主要针对配备多颗处理器及大容量内存的机器.，能够以极高概率满足GC停顿时间要求的同时，同时还具备高吞吐量性能特征。</p><p>在G1收集器出现之前，所有的垃圾收集器（包括CMS）的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），要么是整个Java堆（Full GC）。而G1跳出了这个樊笼，可以面向堆内存的任何部分组成回收集（Cset）进行回收，回收的衡量标准不再是垃圾对象属于哪个分代，而变成了哪块内存中存放的垃圾数目最多，回收收益最大，这就是<code>G1的Mixed GC模式</code>。</p><h5 id="G1基于Region的堆内存布局"><a href="#G1基于Region的堆内存布局" class="headerlink" title="G1基于Region的堆内存布局"></a><code>G1基于Region的堆内存布局</code></h5><p><code>G1之前的JVM内存模型</code></p><p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2021/05/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/05/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><code>当需要某个类的时候</code>，Java虚拟机会加载 .class 文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><ul><li>隐式加载 new 创建类的实例,</li><li>显式加载：loaderClass，forName等</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式创建某个类或者接口对象的Class对象</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>下图展示了一个类的完整生命周期，虚线框内的部分为类加载的过程。</p><img src="/2021/05/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20210320164851353.png" class=""><ul><li><code>加载</code>——在这个阶段，JVM 的主要目的是将字节码转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的<code>方法区</code>创建一个对应的 <code>Class 对象</code>，这个 Class 对象就是这个类各种数据的访问入口。这一阶段主要完成以下三件事：<ul><li>通过全类名获取定义此类的二进制字节流（比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等）</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</li></ul></li><li>验证 —— 确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</li><li><code>准备</code> —— 该阶段是正式为类变量分配内存并<code>设置类变量初始值</code>的阶段，这些内存都将在<code>方法区中分配</code>。<ul><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型<code>默认的零值</code>（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。<code>特殊情况</code>：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ul></li><li>解析 —— 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。<code>得到类或者字段、方法在内存中的指针或者偏移量。</code></li><li><code>初始化</code> —— 初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>的过程。只有主动去使用类才会初始化类，类初始化的触发条件：<ul><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条字节码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li><li><strong>「补充」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM 中内置了三个重要的 ClassLoader，除了BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li><li><strong>自定义类加载器</strong>，除了 <code>BootstrapClassLoader</code> ，其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><code>原理</code></p><p>每一个类都有一个对应它的类加载器。系统中的类加载器在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器，如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，这就是双亲委派模式。</p><img src="/2021/05/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/5982616-aad63782162c9ae5.png" class=""><p><code>好处</code></p><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子类加载器再加载一次（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域</title>
    <link href="/2021/05/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/05/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="1-Java内存区域划分"><a href="#1-Java内存区域划分" class="headerlink" title="1.Java内存区域划分"></a>1.Java内存区域划分</h3><p>JVM在执行Java程序的过程中会把它管理的内存区域划分成两类用途不同的数据区：</p><ul><li><p>线程共有（线程共享）区域——堆和方法区</p></li><li><p>线程私有（线程隔离）区域——程序计数器、虚拟机栈和本地方法栈</p></li></ul><img src="/2021/05/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-20210526164944774.png" class=""><h3 id="2-线程共享数据区"><a href="#2-线程共享数据区" class="headerlink" title="2.线程共享数据区"></a>2.线程共享数据区</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a><code>堆</code></h4><img src="/2021/05/28/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/image-20210526185840704.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center">用途</th><th style="text-align:center"><code>完成几乎所有Java实例对象的内存分配，进行垃圾回收的主要内存区域</code></th></tr></thead><tbody><tr><td style="text-align:center"><strong>划分</strong></td><td style="text-align:center">年轻代<code>8 : 1 : 1(Eden区 : From Survivor 0 : To Survivor 1 区)</code>、老年代</td></tr><tr><td style="text-align:center"><strong>内存空间大小</strong></td><td style="text-align:center"><strong>大</strong></td></tr><tr><td style="text-align:center"><strong>垃圾回收模式</strong></td><td style="text-align:center"><strong>以主流的HotSpot为例，采用<code>分代回收</code>策略，对于年轻代的对象采取复制算法，对老年代采取标记-清除或者标记-整理算法</strong></td></tr><tr><td style="text-align:center"><strong>异常情况</strong></td><td style="text-align:center"><strong>堆中没完成实例分配，且堆此时无法再扩展，JVM会抛出<code>OOM</code>异常</strong></td></tr></tbody></table></div><h5 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h5><p>当有对象需要分配时，一个对象永远<code>优先被分配在年轻代的 Eden 区</code>，等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收。此时 Eden 区中没有被引用的对象的内存就会被回收，在一次新生代垃圾回收后，Eden区中所有存活的对象都会被<code>复制</code>到To Survivor区，而在From Survivor区中，<code>仍存活的对象会根据它们的年龄值决定去向</code>，年龄值达到<code>年龄阀值</code>（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， <code>From Survivor区和To Survivor区会交换它们的角色</code>，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><code>方法区</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center">用途</th><th style="text-align:center">存储已被虚拟机加载的<code>类的结构信息(字段和方法数据、构造方法)、常量、静态变量</code>、即时编译器编译后的代码缓存等数据，像是堆的一个逻辑部分</th></tr></thead><tbody><tr><td style="text-align:center"><strong>异常情况</strong></td><td style="text-align:center"><strong>方法区无法满足新的内存分配需求时，抛出OOM异常</strong></td></tr></tbody></table></div><h3 id="3-线程私有数据区"><a href="#3-线程私有数据区" class="headerlink" title="3.线程私有数据区"></a>3.线程私有数据区</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><code>程序计数器</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center">用途</th><th style="text-align:center">指示当前线程所<code>执行的字节码的行号指示器</code>。字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令，程序控制中的<code>分支、循环、跳转、异常处理、线程恢复</code>等都依赖程序计数器</th></tr></thead><tbody><tr><td style="text-align:center"><strong>私有性质</strong></td><td style="text-align:center"><strong>JVM多线程通过线程切换并分配CPU时间实现的，任一确定的时刻，一个CPU指挥执行一条线程中的指令。所以为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。</strong></td></tr><tr><td style="text-align:center"><strong>内存空间大小</strong></td><td style="text-align:center"><strong>小</strong></td></tr><tr><td style="text-align:center"><strong>生命周期</strong></td><td style="text-align:center"><strong>随着线程的创建而创建，随着线程的消亡而消亡</strong></td></tr><tr><td style="text-align:center"><strong>真实值</strong></td><td style="text-align:center"><strong>如果执行的是<code>Java方法</code>，那么计数器记录的就是<code>正在执行的JVM字节码指令的地址</code>；如果执行的是<code>本地(Native)方法</code>，那么计数器的值则应该为空(<code>Undefined</code>)</strong></td></tr><tr><td style="text-align:center"><strong>异常情况</strong></td><td style="text-align:center"><strong>唯一一个不会出现 <code>OutOfMemoryError(OOM)</code> 的内存区域</strong></td></tr></tbody></table></div><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><code>虚拟机栈</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">描述<code>Java方法执行的线程内存模型</code>，每个Java方法被执行时，虚拟机都会同步创建一个栈帧</th></tr></thead><tbody><tr><td style="text-align:center"><strong>组成</strong></td><td style="text-align:center"><strong>Java虚拟机栈由一个个<code>栈帧</code>组成</strong></td></tr><tr><td style="text-align:center"><strong>栈帧</strong></td><td style="text-align:center"><strong>存储了<code>局部变量表</code>、操作数栈、动态链接、方法出口等信息</strong></td></tr><tr><td style="text-align:center"><strong>局部变量表</strong></td><td style="text-align:center"><strong>主要存放了编译期可知的各种<code>基本数据类型</code>（boolean、byte、char、short、int、float、long、double）、<code>对象引用</code>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型(指向了一条字节码指令的地址)。</strong></td></tr><tr><td style="text-align:center"><strong>生命周期</strong></td><td style="text-align:center"><strong>和线程相同</strong></td></tr><tr><td style="text-align:center"><strong>异常情况</strong></td><td style="text-align:center"><strong>如果线程请求的栈深度大于虚拟机允许的最大深度，就会抛出<code>StackOverflowError</code>异常(栈溢出异常)；如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常</strong></td></tr></tbody></table></div><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><code>本地方法栈</code></h4><p>为虚拟机使用到的本地方法服务。和Java虚拟机栈发挥的作用非常相似，和虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈动态扩展失败时分别抛出<code>StackOverflowError</code>异常和<code>OutOfMemoryError</code>异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译JDK</title>
    <link href="/2021/05/28/%E7%BC%96%E8%AF%91JDK/"/>
    <url>/2021/05/28/%E7%BC%96%E8%AF%91JDK/</url>
    
    <content type="html"><![CDATA[<h2 id="JDK编译"><a href="#JDK编译" class="headerlink" title="JDK编译"></a>JDK编译</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h3><ul><li>ubuntu 16.04 LTS</li><li>查看本地JDK版本，没有就去安装</li></ul><p>如果要编译的JDK版本为N，那么本地已安装的JDK的版本只能大于等于N-1。</p><h3 id="2-下载JDK源码包"><a href="#2-下载JDK源码包" class="headerlink" title="2.下载JDK源码包"></a>2.下载JDK源码包</h3><p><a href="http://jdk.java.net/">JDK源码下载地址</a></p><img src="/2021/05/28/%E7%BC%96%E8%AF%91JDK/image-20210526153227558.png" class=""><h3 id="3-解压"><a href="#3-解压" class="headerlink" title="3.解压"></a>3.解压</h3><pre><code class="hljs shell">unzip openjdk-11+28_src.zip</code></pre><h3 id="4-重命名为对应的JDK版本"><a href="#4-重命名为对应的JDK版本" class="headerlink" title="4.重命名为对应的JDK版本"></a>4.重命名为对应的JDK版本</h3><pre><code class="hljs she">mv openjdk&#x2F; openjdk11</code></pre><h3 id="5-配置生成"><a href="#5-配置生成" class="headerlink" title="5.配置生成"></a>5.配置生成</h3><pre><code class="hljs shell">sh configure</code></pre><p><code>结果</code></p><img src="/2021/05/28/%E7%BC%96%E8%AF%91JDK/image-20210526152404548.png" class=""><h3 id="6-全量编译"><a href="#6-全量编译" class="headerlink" title="6.全量编译"></a>6.全量编译</h3><pre><code class="hljs shell">make all</code></pre><img src="/2021/05/28/%E7%BC%96%E8%AF%91JDK/image-20210526153424947.png" class=""><h3 id="7-查看编译的JDK"><a href="#7-查看编译的JDK" class="headerlink" title="7.查看编译的JDK"></a>7.查看编译的JDK</h3><ul><li><p>进入编译后生成的JDK的文件夹的bin目录(<code>openjdk11/build/linux-x86_64-normal-server-release/jdk/bin</code>)</p></li><li><p>./java —version查看版本</p><img src="/2021/05/28/%E7%BC%96%E8%AF%91JDK/image-20210526154437048.png" class=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerZooKeeperInstallation</title>
    <link href="/2021/05/28/DockerZooKeeperInstallation/"/>
    <url>/2021/05/28/DockerZooKeeperInstallation/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker安装部署ZooKeeper"><a href="#Docker安装部署ZooKeeper" class="headerlink" title="Docker安装部署ZooKeeper"></a>Docker安装部署ZooKeeper</h2><h3 id="1-运行ZooKeeper容器"><a href="#1-运行ZooKeeper容器" class="headerlink" title="1.运行ZooKeeper容器"></a>1.运行ZooKeeper容器</h3><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">-e</span> TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span> <span class="hljs-literal">-p</span> <span class="hljs-number">21810</span>:<span class="hljs-number">2181</span> <span class="hljs-literal">-v</span> /f/docker/zookeeper/<span class="hljs-keyword">data</span>:/<span class="hljs-keyword">data</span> -<span class="hljs-literal">-name</span> myZk zookeeper</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-d</td><td style="text-align:center">容器后台运行</td></tr><tr><td style="text-align:center">-e</td><td style="text-align:center">设置时区</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">端口映射</td></tr><tr><td style="text-align:center">—name</td><td style="text-align:center">容器名</td></tr></tbody></table></div><h3 id="2-命令行连接ZooKeepper服务"><a href="#2-命令行连接ZooKeepper服务" class="headerlink" title="2.命令行连接ZooKeepper服务"></a>2.命令行连接ZooKeepper服务</h3><p><code>先进入ZooKeeper容器</code></p><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> myZk /bin/bash</code></pre><img src="/2021/05/28/DockerZooKeeperInstallation/image-20210527153648616.png" class=""> <p><code>连接ZooKeeper服务(进入bin目录执行)</code></p><pre><code class="hljs powershell">./zkCli.sh <span class="hljs-literal">-server</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2181</span></code></pre><img src="/2021/05/28/DockerZooKeeperInstallation/image-20210527153941835.png" class=""> <h3 id="3-ZooKeeper常见命令"><a href="#3-ZooKeeper常见命令" class="headerlink" title="3.ZooKeeper常见命令"></a>3.<a href="https://wandehua.gitee.io/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#ZK%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4">ZooKeeper常见命令</a></h3><h3 id="4-利用ZK客户端操作ZK"><a href="#4-利用ZK客户端操作ZK" class="headerlink" title="4.利用ZK客户端操作ZK"></a>4.<a href="https://wandehua.gitee.io/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#Java%E6%93%8D%E4%BD%9CZK">利用ZK客户端操作ZK</a></h3>]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerRedisInstallation</title>
    <link href="/2021/05/28/DockerRedisInstallation/"/>
    <url>/2021/05/28/DockerRedisInstallation/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker安装部署Redis"><a href="#Docker安装部署Redis" class="headerlink" title="Docker安装部署Redis"></a>Docker安装部署Redis</h2><h3 id="方式1——命令行部署-推荐"><a href="#方式1——命令行部署-推荐" class="headerlink" title="方式1——命令行部署(推荐)"></a>方式1——命令行部署(推荐)</h3><pre><code class="hljs reStructuredText">docker run \--restart&#x3D;always \-d \--privileged&#x3D;true \-p 6379:6379 \-v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data \-v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;opt&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf \--name myRedis \redis \--requirepass root \--appendonly yes</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">—name</td><td style="text-align:center">容器名</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">端口映射</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">容器卷映射</td></tr><tr><td style="text-align:center">—restart=always</td><td style="text-align:center">设置随docker自启动</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">后台运行</td></tr><tr><td style="text-align:center">—appendonly</td><td style="text-align:center">开启持久化</td></tr><tr><td style="text-align:center">—privileged=true</td><td style="text-align:center">使容器内的root拥有真正root权限</td></tr><tr><td style="text-align:center">—requirepass root</td><td style="text-align:center">设置redis-cli的密码</td></tr></tbody></table></div><ul><li><p>可执行命令启动redis容器</p><pre><code class="hljs powershell">docker run -<span class="hljs-literal">-restart</span>=always <span class="hljs-literal">-d</span> -<span class="hljs-literal">-privileged</span>=true <span class="hljs-literal">-p</span> <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> <span class="hljs-literal">-v</span> /f/docker/redis/<span class="hljs-keyword">data</span>:/<span class="hljs-keyword">data</span> <span class="hljs-literal">-v</span> /f/docker/redis/conf/redis.conf:/opt/docker/redis/conf/redis.conf -<span class="hljs-literal">-name</span> myRedis redis -<span class="hljs-literal">-requirepass</span> root -<span class="hljs-literal">-appendonly</span> yes</code></pre></li><li><p>进入redis客户端</p><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> myRedis redis<span class="hljs-literal">-cli</span></code></pre></li><li><p>输入密码进入客户端</p><img src="/2021/05/28/DockerRedisInstallation/image-20210526100004937.png" class=""></li><li><p>进入myRedis容器检查容器卷映射结果</p><img src="/2021/05/28/DockerRedisInstallation/image-20210526102056620.png" class=""></li><li><p>直观查看配置文件redis.conf的具体配置(grep -v “#”——显示不包含”#”的所有行)</p><pre><code class="hljs reStructuredText">cat redis.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;</code></pre><p>具体配置信息如下：</p><pre><code class="hljs reStructuredText">protected-mode noport 6379tcp-backlog 511timeout 0tcp-keepalive 300daemonize nosupervised nopidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pidloglevel noticelogfile &quot;&quot;databases 16always-show-logo yessave 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbrdb-del-sync-files nodir &#x2F;f&#x2F;docker&#x2F;redis&#x2F;datareplica-serve-stale-data yesreplica-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-diskless-load disabledrepl-disable-tcp-nodelay noreplica-priority 100acllog-max-len 128requirepass foobaredlazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush nolazyfree-lazy-user-del nooom-score-adj nooom-score-adj-values 0 200 800appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yesaof-use-rdb-preamble yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000stream-node-max-bytes 4096stream-node-max-entries 100activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit replica 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10dynamic-hz yesaof-rewrite-incremental-fsync yesrdb-save-incremental-fsync yesjemalloc-bg-thread yes</code></pre></li></ul><h3 id="方式二——Portainer图形化部署"><a href="#方式二——Portainer图形化部署" class="headerlink" title="方式二——Portainer图形化部署"></a>方式二——Portainer图形化部署</h3><ul><li><p>找到APP Templates，从利用模板redis容器</p><img src="/2021/05/28/DockerRedisInstallation/image-20210526100438944.png" class=""></li><li><p>配置redis.conf</p></li><li><p>进行容器配置</p><img src="/2021/05/28/DockerRedisInstallation/image-20210526100814655.png" class=""></li><li><p>设置自启动</p><pre><code class="hljs powershell">docker update myRedis -<span class="hljs-literal">-restart</span>=always</code></pre></li><li><p>容器启动结果</p><img src="/2021/05/28/DockerRedisInstallation/image-20210526101312218.png" class=""></li></ul><h3 id="Redis基础知识"><a href="#Redis基础知识" class="headerlink" title="Redis基础知识"></a><a href="https://wandehua.gitee.io/2021/01/15/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Redis基础知识</a></h3>]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerBasicCommands</title>
    <link href="/2021/05/28/DockerBasicCommands/"/>
    <url>/2021/05/28/DockerBasicCommands/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Basic-Commands"><a href="#Docker-Basic-Commands" class="headerlink" title="Docker Basic Commands"></a>Docker Basic Commands</h2><h3 id="Docker安装测试"><a href="#Docker安装测试" class="headerlink" title="Docker安装测试"></a>Docker安装测试</h3><pre><code class="hljs powershell">docker run debian <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world!&quot;</span></code></pre><ul><li>本地没有debian镜像，先pull</li><li>由debian镜像创建容器</li><li>执行命令行<code>echo &quot;hello world!&quot;</code></li></ul><img src="/2021/05/28/DockerBasicCommands/image-20210525102156216.png" class=""><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a><code>docker images</code></h4><p><code>查看本地镜像</code></p><pre><code class="hljs powershell">docker images</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525103825274.png" class=""><h4 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a><code>docker search</code></h4><p><code>搜索合适的镜像</code></p><pre><code class="hljs powershell">docker search ubuntu</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525103949538.png" class=""><h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a><code>docker pull</code></h4><p><code>拉取镜像源</code></p><pre><code class="hljs powershell">docker pull ubuntu</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525104201817.png" class=""><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><code>docker run</code></h4><p><code>根据镜像构建容器</code></p><pre><code class="hljs powershell">docker run -<span class="hljs-literal">-name</span> myDebian <span class="hljs-literal">-h</span> Debian <span class="hljs-literal">-it</span> debian /bin/bash</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525103244676.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-h</td><td style="text-align:center">指定容器的hostname</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">以交互模式运行容器，通常与 -t 同时使用</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">为容器重新分配一个伪输入终端，通常与 -i 同时使用</td></tr><tr><td style="text-align:center">/bin/bash</td><td style="text-align:center">docker后台必须运行一个进程，否则容器就会退出，所以启动容器后启动bash</td></tr></tbody></table></div><h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><code>docker ps</code></h4><p><code>列出容器(默认正在运行的)</code></p><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span></code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525110348609.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">显示所有容器（包括未运行的）</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">显示最近创建的容器</td></tr><tr><td style="text-align:center">-n + int</td><td style="text-align:center">列出最近创建的n个容器</td></tr></tbody></table></div><h4 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a><code>docker top</code></h4><p><code>查看容器中运行的进程信息</code></p><pre><code class="hljs powershell">docker top myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525110741899.png" class=""><h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a><code>docker logs</code></h4><p><code>获取容器日志</code></p><pre><code class="hljs powershell">docker logs -<span class="hljs-literal">-since</span>=<span class="hljs-string">&quot;2021-05-25&quot;</span> -<span class="hljs-literal">-tail</span>=<span class="hljs-number">10</span> myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525111118578.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">—since</td><td style="text-align:center">显示某个开始时间的所有日志</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">显示时间戳</td></tr><tr><td style="text-align:center">—tail</td><td style="text-align:center">仅列出最新N条容器日志</td></tr></tbody></table></div><p><code>动态跟踪容器日志</code></p><pre><code class="hljs powershell">docker logs <span class="hljs-literal">-tf</span> -<span class="hljs-literal">-tail</span>=<span class="hljs-number">10</span> myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525111341916.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-f</td><td style="text-align:center">跟踪日志输出</td></tr></tbody></table></div><h4 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a><code>docker inspect</code></h4><p><code>获取镜像的元数据</code></p><pre><code class="hljs powershell">docker inspect debian</code></pre><p>获取的镜像元数据如下：</p><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">&quot;Id&quot;</span>: <span class="hljs-string">&quot;sha256:4a7a1f4017349067a21bd2de060dcf8b41e49fabf61b0dc3cf86a87e1f6dba9d&quot;</span>,        <span class="hljs-attr">&quot;RepoTags&quot;</span>: [            <span class="hljs-string">&quot;debian:latest&quot;</span>        ],        <span class="hljs-attr">&quot;RepoDigests&quot;</span>: [            <span class="hljs-string">&quot;debian@sha256:acf7795dc91df17e10effee064bd229580a9c34213b4dba578d64768af5d8c51&quot;</span>        ],        <span class="hljs-attr">&quot;Parent&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-attr">&quot;Comment&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-attr">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2021-05-12T01:21:03.936921102Z&quot;</span>,        <span class="hljs-attr">&quot;Container&quot;</span>: <span class="hljs-string">&quot;efa20d864846ecdacfb84d82cd08335b1db4b2f74e09922d12fe3d8a084616a1&quot;</span>,        <span class="hljs-attr">&quot;ContainerConfig&quot;</span>: &#123;            <span class="hljs-attr">&quot;Hostname&quot;</span>: <span class="hljs-string">&quot;efa20d864846&quot;</span>,            <span class="hljs-attr">&quot;Domainname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;User&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;AttachStdin&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;AttachStdout&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;AttachStderr&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;Tty&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;OpenStdin&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;StdinOnce&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;Env&quot;</span>: [                <span class="hljs-string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>            ],            <span class="hljs-attr">&quot;Cmd&quot;</span>: [                <span class="hljs-string">&quot;/bin/sh&quot;</span>,                <span class="hljs-string">&quot;-c&quot;</span>,                <span class="hljs-string">&quot;#(nop) &quot;</span>,                <span class="hljs-string">&quot;CMD [\&quot;bash\&quot;]&quot;</span>            ],            <span class="hljs-attr">&quot;Image&quot;</span>: <span class="hljs-string">&quot;sha256:a1ab89980b2dbaf5ebaa889d14f26af111dd2726e5f05ebf2515176b3fea4c27&quot;</span>,            <span class="hljs-attr">&quot;Volumes&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;WorkingDir&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;Entrypoint&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;OnBuild&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;Labels&quot;</span>: &#123;&#125;        &#125;,        <span class="hljs-attr">&quot;DockerVersion&quot;</span>: <span class="hljs-string">&quot;19.03.12&quot;</span>,        <span class="hljs-attr">&quot;Author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-attr">&quot;Config&quot;</span>: &#123;            <span class="hljs-attr">&quot;Hostname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;Domainname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;User&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;AttachStdin&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;AttachStdout&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;AttachStderr&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;Tty&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;OpenStdin&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;StdinOnce&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;Env&quot;</span>: [                <span class="hljs-string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>            ],            <span class="hljs-attr">&quot;Cmd&quot;</span>: [                <span class="hljs-string">&quot;bash&quot;</span>            ],            <span class="hljs-attr">&quot;Image&quot;</span>: <span class="hljs-string">&quot;sha256:a1ab89980b2dbaf5ebaa889d14f26af111dd2726e5f05ebf2515176b3fea4c27&quot;</span>,            <span class="hljs-attr">&quot;Volumes&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;WorkingDir&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;Entrypoint&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;OnBuild&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">&quot;Labels&quot;</span>: <span class="hljs-literal">null</span>        &#125;,        <span class="hljs-attr">&quot;Architecture&quot;</span>: <span class="hljs-string">&quot;amd64&quot;</span>,        <span class="hljs-attr">&quot;Os&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span>,        <span class="hljs-attr">&quot;Size&quot;</span>: <span class="hljs-number">114112893</span>,        <span class="hljs-attr">&quot;VirtualSize&quot;</span>: <span class="hljs-number">114112893</span>,        <span class="hljs-attr">&quot;GraphDriver&quot;</span>: &#123;            <span class="hljs-attr">&quot;Data&quot;</span>: &#123;                <span class="hljs-attr">&quot;MergedDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/9bb7fe0d6c6c6758213a0391aed3660a516e024fed6abc054b7453ee72447f98/merged&quot;</span>,                <span class="hljs-attr">&quot;UpperDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/9bb7fe0d6c6c6758213a0391aed3660a516e024fed6abc054b7453ee72447f98/diff&quot;</span>,                <span class="hljs-attr">&quot;WorkDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/9bb7fe0d6c6c6758213a0391aed3660a516e024fed6abc054b7453ee72447f98/work&quot;</span>            &#125;,            <span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>        &#125;,        <span class="hljs-attr">&quot;RootFS&quot;</span>: &#123;            <span class="hljs-attr">&quot;Type&quot;</span>: <span class="hljs-string">&quot;layers&quot;</span>,            <span class="hljs-attr">&quot;Layers&quot;</span>: [                <span class="hljs-string">&quot;sha256:688e187d6c79c46e8261890f0010fd5d178b8faa178959b0b46b2635aa1eeff3&quot;</span>            ]        &#125;,        <span class="hljs-attr">&quot;Metadata&quot;</span>: &#123;            <span class="hljs-attr">&quot;LastTagTime&quot;</span>: <span class="hljs-string">&quot;0001-01-01T00:00:00Z&quot;</span>        &#125;    &#125;]</code></pre><p><code>获取容器的元数据</code></p><pre><code class="hljs powershell">docker inspect myDebian</code></pre><p>获取的容器的元数据</p><pre><code class="hljs csharp">C:\Users\wandehua&gt;docker inspect myDebian[<span class="hljs-meta"></span><span class="hljs-meta">    &#123;</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Id&quot;</span>: <span class="hljs-meta-string">&quot;a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Created&quot;</span>: <span class="hljs-meta-string">&quot;2021-05-25T02:32:08.9092537Z&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Path&quot;</span>: <span class="hljs-meta-string">&quot;/bin/bash&quot;</span>,</span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Args&quot;</span>: [</span>],        <span class="hljs-string">&quot;State&quot;</span>: &#123;            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;running&quot;</span>,            <span class="hljs-string">&quot;Running&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;Paused&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Restarting&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;OOMKilled&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Dead&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Pid&quot;</span>: <span class="hljs-number">7297</span>,            <span class="hljs-string">&quot;ExitCode&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;Error&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;StartedAt&quot;</span>: <span class="hljs-string">&quot;2021-05-25T02:54:24.9078658Z&quot;</span>,            <span class="hljs-string">&quot;FinishedAt&quot;</span>: <span class="hljs-string">&quot;2021-05-25T02:54:06.0940833Z&quot;</span>        &#125;,        <span class="hljs-string">&quot;Image&quot;</span>: <span class="hljs-string">&quot;sha256:4a7a1f4017349067a21bd2de060dcf8b41e49fabf61b0dc3cf86a87e1f6dba9d&quot;</span>,        <span class="hljs-string">&quot;ResolvConfPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac/resolv.conf&quot;</span>,        <span class="hljs-string">&quot;HostnamePath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac/hostname&quot;</span>,        <span class="hljs-string">&quot;HostsPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac/hosts&quot;</span>,        <span class="hljs-string">&quot;LogPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac/a73c1cb27f75b92800b558eb859c294155ef0a1143342a0d6122e172d1f61aac-json.log&quot;</span>,        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;/myDebian&quot;</span>,        <span class="hljs-string">&quot;RestartCount&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>,        <span class="hljs-string">&quot;Platform&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span>,        <span class="hljs-string">&quot;MountLabel&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ProcessLabel&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;AppArmorProfile&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ExecIDs&quot;</span>: [            <span class="hljs-string">&quot;c33fdb3d45c87cbceeb34cdd4ef6bcd326c6f991965341909e5c9e6bc6243df0&quot;</span>        ],        <span class="hljs-string">&quot;HostConfig&quot;</span>: &#123;            <span class="hljs-string">&quot;Binds&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;ContainerIDFile&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;LogConfig&quot;</span>: &#123;                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,                <span class="hljs-string">&quot;Config&quot;</span>: &#123;&#125;            &#125;,            <span class="hljs-string">&quot;NetworkMode&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,            <span class="hljs-string">&quot;PortBindings&quot;</span>: &#123;&#125;,            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;no&quot;</span>,                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span>            &#125;,            <span class="hljs-string">&quot;AutoRemove&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;VolumeDriver&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;VolumesFrom&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CapAdd&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CapDrop&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CgroupnsMode&quot;</span>: <span class="hljs-string">&quot;host&quot;</span>,            <span class="hljs-string">&quot;Dns&quot;</span>: [],            <span class="hljs-string">&quot;DnsOptions&quot;</span>: [],            <span class="hljs-string">&quot;DnsSearch&quot;</span>: [],            <span class="hljs-string">&quot;ExtraHosts&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;GroupAdd&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;IpcMode&quot;</span>: <span class="hljs-string">&quot;private&quot;</span>,            <span class="hljs-string">&quot;Cgroup&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Links&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OomScoreAdj&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;PidMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Privileged&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;PublishAllPorts&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;ReadonlyRootfs&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;SecurityOpt&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;UTSMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;UsernsMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;ShmSize&quot;</span>: <span class="hljs-number">67108864</span>,            <span class="hljs-string">&quot;Runtime&quot;</span>: <span class="hljs-string">&quot;runc&quot;</span>,            <span class="hljs-string">&quot;ConsoleSize&quot;</span>: [                <span class="hljs-number">17</span>,                <span class="hljs-number">85</span>            ],            <span class="hljs-string">&quot;Isolation&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;CpuShares&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;Memory&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;NanoCpus&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CgroupParent&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;BlkioWeight&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;BlkioWeightDevice&quot;</span>: [],            <span class="hljs-string">&quot;BlkioDeviceReadBps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceWriteBps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceReadIOps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceWriteIOps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CpuPeriod&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuQuota&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuRealtimePeriod&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuRealtimeRuntime&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpusetCpus&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;CpusetMems&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Devices&quot;</span>: [],            <span class="hljs-string">&quot;DeviceCgroupRules&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;DeviceRequests&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;KernelMemory&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;KernelMemoryTCP&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemoryReservation&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemorySwap&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemorySwappiness&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OomKillDisable&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;PidsLimit&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;Ulimits&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CpuCount&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuPercent&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IOMaximumIOps&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IOMaximumBandwidth&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MaskedPaths&quot;</span>: [                <span class="hljs-string">&quot;/proc/asound&quot;</span>,                <span class="hljs-string">&quot;/proc/acpi&quot;</span>,                <span class="hljs-string">&quot;/proc/kcore&quot;</span>,                <span class="hljs-string">&quot;/proc/keys&quot;</span>,                <span class="hljs-string">&quot;/proc/latency_stats&quot;</span>,                <span class="hljs-string">&quot;/proc/timer_list&quot;</span>,                <span class="hljs-string">&quot;/proc/timer_stats&quot;</span>,                <span class="hljs-string">&quot;/proc/sched_debug&quot;</span>,                <span class="hljs-string">&quot;/proc/scsi&quot;</span>,                <span class="hljs-string">&quot;/sys/firmware&quot;</span>            ],            <span class="hljs-string">&quot;ReadonlyPaths&quot;</span>: [                <span class="hljs-string">&quot;/proc/bus&quot;</span>,                <span class="hljs-string">&quot;/proc/fs&quot;</span>,                <span class="hljs-string">&quot;/proc/irq&quot;</span>,                <span class="hljs-string">&quot;/proc/sys&quot;</span>,                <span class="hljs-string">&quot;/proc/sysrq-trigger&quot;</span>            ]        &#125;,        <span class="hljs-string">&quot;GraphDriver&quot;</span>: &#123;            <span class="hljs-string">&quot;Data&quot;</span>: &#123;                <span class="hljs-string">&quot;LowerDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/839ffc25c92ca4697565e3b29bd5d8ba76ad0587da91b6989a14693441b5f952-init/diff:/var/lib/docker/overlay2/9bb7fe0d6c6c6758213a0391aed3660a516e024fed6abc054b7453ee72447f98/diff&quot;</span>,                <span class="hljs-string">&quot;MergedDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/839ffc25c92ca4697565e3b29bd5d8ba76ad0587da91b6989a14693441b5f952/merged&quot;</span>,                <span class="hljs-string">&quot;UpperDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/839ffc25c92ca4697565e3b29bd5d8ba76ad0587da91b6989a14693441b5f952/diff&quot;</span>,                <span class="hljs-string">&quot;WorkDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/839ffc25c92ca4697565e3b29bd5d8ba76ad0587da91b6989a14693441b5f952/work&quot;</span>            &#125;,            <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>        &#125;,        <span class="hljs-string">&quot;Mounts&quot;</span>: [],        <span class="hljs-string">&quot;Config&quot;</span>: &#123;            <span class="hljs-string">&quot;Hostname&quot;</span>: <span class="hljs-string">&quot;Debian&quot;</span>,            <span class="hljs-string">&quot;Domainname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;User&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;AttachStdin&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;AttachStdout&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;AttachStderr&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;Tty&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;OpenStdin&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;StdinOnce&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;Env&quot;</span>: [                <span class="hljs-string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>            ],            <span class="hljs-string">&quot;Cmd&quot;</span>: [                <span class="hljs-string">&quot;/bin/bash&quot;</span>            ],            <span class="hljs-string">&quot;Image&quot;</span>: <span class="hljs-string">&quot;debian&quot;</span>,            <span class="hljs-string">&quot;Volumes&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;WorkingDir&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Entrypoint&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OnBuild&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;Labels&quot;</span>: &#123;&#125;        &#125;,        <span class="hljs-string">&quot;NetworkSettings&quot;</span>: &#123;            <span class="hljs-string">&quot;Bridge&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;SandboxID&quot;</span>: <span class="hljs-string">&quot;1b53ae13f711f6ebe6752c889b66fe9917d5c2b51e8c9642af2bce3c79369755&quot;</span>,            <span class="hljs-string">&quot;HairpinMode&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;LinkLocalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;Ports&quot;</span>: &#123;&#125;,            <span class="hljs-string">&quot;SandboxKey&quot;</span>: <span class="hljs-string">&quot;/var/run/docker/netns/1b53ae13f711&quot;</span>,            <span class="hljs-string">&quot;SecondaryIPAddresses&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;SecondaryIPv6Addresses&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;30747fb38cb62326d6c430d4ba0111dad96e2d782b214c064d013746e56c54c2&quot;</span>,            <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.17.0.1&quot;</span>,            <span class="hljs-string">&quot;GlobalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;172.17.0.4&quot;</span>,            <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: <span class="hljs-number">16</span>,            <span class="hljs-string">&quot;IPv6Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:11:00:04&quot;</span>,            <span class="hljs-string">&quot;Networks&quot;</span>: &#123;                <span class="hljs-string">&quot;bridge&quot;</span>: &#123;                    <span class="hljs-string">&quot;IPAMConfig&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;Links&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;Aliases&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;NetworkID&quot;</span>: <span class="hljs-string">&quot;6645ff01f33f334a81b1a2b4ae2a8ba17982be784d39809503e1f4ae50132a5d&quot;</span>,                    <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;30747fb38cb62326d6c430d4ba0111dad96e2d782b214c064d013746e56c54c2&quot;</span>,                    <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.17.0.1&quot;</span>,                    <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;172.17.0.4&quot;</span>,                    <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: <span class="hljs-number">16</span>,                    <span class="hljs-string">&quot;IPv6Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;GlobalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,                    <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:11:00:04&quot;</span>,                    <span class="hljs-string">&quot;DriverOpts&quot;</span>: <span class="hljs-literal">null</span>                &#125;            &#125;        &#125;    &#125;]</code></pre><h4 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a><code>docker stop</code></h4><p><code>关闭容器</code></p><pre><code class="hljs powershell">docker stop myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525105413546.png" class=""><h4 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a><code>docker start</code></h4><p><code>启动容器</code></p><pre><code class="hljs powershell">docker <span class="hljs-built_in">start</span> myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525105342531.png" class=""><h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a><code>docker exec</code></h4><p><code>在运行的容器中开启一个交互终端</code></p><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> myDebian /bin/bash</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525105520356.png" class=""><p><code>在运行的容器中执行命令或脚本</code></p><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> myDebian <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world!!!&quot;</span></code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525110013855.png" class=""><h4 id="Ctrl-P-Q"><a href="#Ctrl-P-Q" class="headerlink" title="Ctrl + P + Q"></a><code>Ctrl + P + Q</code></h4><p><code>退出交互式终端但是保证容器在后台继续运行</code></p><h4 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a><code>docker attach</code></h4><p><code>进入正在运行的容器</code></p><pre><code class="hljs powershell">docker attach myDebian</code></pre><img src="/2021/05/28/DockerBasicCommands/image-20210525105840025.png" class=""><h4 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a><code>docker rm</code></h4><p><code>删除单个容器</code></p><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> myDebian</code></pre><p><code>删除所有已停止的容器</code></p><pre><code class="hljs reStructuredText">docker rm $(docker ps -a -q)</code></pre><h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a><code>docker rmi</code></h4><p><code>删除单个镜像</code></p><pre><code class="hljs powershell">docker rmi <span class="hljs-operator">-f</span> debian</code></pre>]]></content>
    
    
    <categories>
      
      <category>命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Desktop-Installation-On-Windows</title>
    <link href="/2021/05/28/Docker-Desktop-Installation-On-Windows/"/>
    <url>/2021/05/28/Docker-Desktop-Installation-On-Windows/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Desktop-Installation-For-Windows"><a href="#Docker-Desktop-Installation-For-Windows" class="headerlink" title="Docker Desktop Installation For Windows"></a>Docker Desktop Installation For Windows</h2><h3 id="1-启用Windows的Hyper-V功能"><a href="#1-启用Windows的Hyper-V功能" class="headerlink" title="1.启用Windows的Hyper-V功能"></a>1.启用Windows的Hyper-V功能</h3><h4 id="控制面板-gt-程序"><a href="#控制面板-gt-程序" class="headerlink" title="控制面板-&gt;程序"></a>控制面板-&gt;程序</h4><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524210324325.png" class=""><h4 id="打开Hyper-V功能"><a href="#打开Hyper-V功能" class="headerlink" title="打开Hyper-V功能"></a>打开Hyper-V功能</h4><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524210509915.png" class=""><h4 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h4><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524210552217.png" class=""><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h3><p><a href="https://www.docker.com/get-started">Docker Desktop For Windows</a></p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524210053456.png" class=""><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524211212591.png" class=""><h3 id="3-配置阿里云镜像加速"><a href="#3-配置阿里云镜像加速" class="headerlink" title="3.配置阿里云镜像加速"></a>3.配置阿里云镜像加速</h3><p><a href="https://www.aliyun.com/product/acr">阿里云容器镜像服务ACR</a></p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524211701661.png" class=""><p><code>创建个人实例</code></p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524211747724.png" class=""><p><code>获取镜像加速地址</code></p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524211826770.png" class=""><p><code>在Docker Desktop设置中配置阿里云镜像源</code></p><ul><li><p>打开设置</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524212345836.png" class=""></li><li><p>打开具体Docker Engine设置</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524212403632.png" class=""></li><li><p>配置镜像源</p><p>用我的也行: <a href="https://x4izdw0s.mirror.aliyuncs.com">https://x4izdw0s.mirror.aliyuncs.com</a></p></li></ul><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524212037010.png" class=""><h3 id="4-Docker图形化工具Portainer的使用"><a href="#4-Docker图形化工具Portainer的使用" class="headerlink" title="4.Docker图形化工具Portainer的使用"></a>4.Docker图形化工具Portainer的使用</h3><ul><li><p>下载portainer/portainer镜像</p><pre><code class="hljs shell">docker pull portainer/portainer</code></pre></li><li><p>运行Portainer容器</p><p><code>配置解释</code></p><ul><li>-p port:port —— 端口映射</li><li>—name container_name —— 指定容器的名字</li><li>—restart=always —— 以守护(后台)进程的方式运行</li><li>-v —— 将容器目录挂载到宿主机的对应路径</li><li>-d —— 后台运行容器，并返回容器ID</li></ul><pre><code class="hljs reStructuredText">docker run -p 9000:9000 -p 8000:8000 --name portainer \--restart&#x3D;always \-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \-v &#x2F;mydata&#x2F;portainer&#x2F;data:&#x2F;data \-d portainer&#x2F;portainer</code></pre><p><code>可执行命令行</code></p><pre><code class="hljs shell">docker run -p 9000:9000 -p 8000:8000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /mydata/portainer/data:/data -d portainer/portainer</code></pre></li><li><p><a href="http://localhost:9000">访问本机的9000端口</a></p></li><li><p>首次登陆设置root账号</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524214031759.png" class=""></li><li><p>选择管理本地的Docker环境</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524214112064.png" class=""></li><li><p>管理本地的Docker环境</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524214326594.png" class=""></li><li><p>App Templates —— 支持快速生成常用的容器</p><p>以运行一个Nginx容器为例，完成如下设置后，即可运行容器。</p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524214638158.png" class=""><p><a href="http://localhost:80">访问80端口</a></p><img src="/2021/05/28/Docker-Desktop-Installation-On-Windows/image-20210524214743757.png" class=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TX笔试</title>
    <link href="/2021/05/03/TX%E7%AC%94%E8%AF%95/"/>
    <url>/2021/05/03/TX%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206-反转链表"></a>206-反转链表</h2><p><code>头插法</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//结果链表的表头</span>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        <span class="hljs-comment">//链表尾部置null</span>        pre.next = <span class="hljs-keyword">null</span>;                <span class="hljs-comment">//头插法</span>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//先把插入位置后一个节点记录下来</span>            ListNode temp = pre.next;            <span class="hljs-comment">//遍历到的节点接到pre的后面</span>            ListNode ist = <span class="hljs-keyword">new</span> ListNode(head.val);            pre.next = ist;            <span class="hljs-comment">//把尾部也接上</span>            ist.next = temp;            <span class="hljs-comment">//遍历原链表</span>            head = head.next;        &#125;        <span class="hljs-comment">//返回结果链表</span>        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><p><code>扭一扭</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210318164102494.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        pre.next = head;        ListNode p = head;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.next != <span class="hljs-keyword">null</span>)&#123;            ListNode tmp = pre.next;            pre.next = p.next;            p.next = p.next.next;            pre.next.next = tmp;        &#125;        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148-排序链表"></a>148-排序链表</h2><p>给你链表的头结点 head ，请将其按升序排列并返回排序后的链表 。</p><p><code>进阶</code>：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210329091852105.png" class=""><p><code>归并排序 + 快慢指针</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">//归并排序O(NlogN)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//归并排序</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;        <span class="hljs-comment">//快慢指针找中间节点</span>        ListNode slowPtr = head, fastPtr = head.next;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            fastPtr = fastPtr.next.next;            slowPtr = slowPtr.next;        &#125;        <span class="hljs-comment">//记录后半部分链表的表头指针</span>        ListNode lastHalf = slowPtr.next;        <span class="hljs-comment">//将slowPtr所在位置后面的链表全部断开</span>        slowPtr.next = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//递归</span>        ListNode leftHalf = sortList(head);        ListNode rightHalf = sortList(lastHalf);        <span class="hljs-keyword">return</span> merge(leftHalf, rightHalf);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode p, ListNode q)</span></span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode pre = res;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (p.val &lt;= q.val)&#123;                pre.next = p;                p = p.next;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.next = q;                q = q.next;            &#125;            pre = pre.next;        &#125;        pre.next = p != <span class="hljs-keyword">null</span> ? p : q;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h2 id="剑指Offer54-二叉搜索树的第k大节点"><a href="#剑指Offer54-二叉搜索树的第k大节点" class="headerlink" title="剑指Offer54-二叉搜索树的第k大节点"></a>剑指Offer54-二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><code>改造中序遍历即可</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cnt = k;        inorderReverse(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorderReverse</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">//先访问右节点</span>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;            inorderReverse(node.right);        &#125;        <span class="hljs-comment">//cnt==0说明已经对res赋予了第k大的值，可以返回</span>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">//对res赋值</span>        <span class="hljs-keyword">if</span> (--cnt == <span class="hljs-number">0</span>)&#123;            res = node.val;        &#125;        <span class="hljs-comment">//访问左节点</span>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;            inorderReverse(node.left);        &#125;    &#125;&#125;</code></pre><h2 id="3-无重复字符的最长连续子串"><a href="#3-无重复字符的最长连续子串" class="headerlink" title="3-无重复字符的最长连续子串"></a>3-无重复字符的最长连续子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><code>HashMap + 双指针</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-comment">//字符串长度小于等于1的情况直接返回长度</span>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, maxLen = Integer.MIN_VALUE;        <span class="hljs-keyword">while</span> (right &lt; n)&#123;            <span class="hljs-keyword">char</span> tmp = s.charAt(right);              map.put(tmp, map.getOrDefault(tmp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span> (map.get(tmp) &gt; <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">char</span> d = s.charAt(left);                left++;                <span class="hljs-comment">//收缩窗口，计数减1</span>                map.put(d, map.get(d) - <span class="hljs-number">1</span>);            &#125;            <span class="hljs-comment">//循环更新最大长度</span>            maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);            right++;                  &#125;        <span class="hljs-keyword">return</span> maxLen;    &#125;&#125;</code></pre><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300-最长递增子序列"></a>300-最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">//动态规划，dp[i]代表以nums[i]结尾的严格递增子序列的最长长度</span>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(dp, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;                <span class="hljs-comment">//状态更新</span>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])&#123;                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">int</span> maxLen = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len : dp)&#123;            maxLen = Math.max(maxLen, len);        &#125;        <span class="hljs-keyword">return</span> maxLen;    &#125;&#125;</code></pre><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2-两数相加"></a>2-两数相加</h2><p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210318152945850.png" class=""><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="hljs-comment">//结果指针</span>        ListNode p = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode p1 = l1, p2 = l2, q = p;        <span class="hljs-comment">//进位初始化</span>        <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;        <span class="hljs-comment">//两个链表必须全部到底才能完成之前位上的加法</span>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">null</span> || p2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> sum = add;            <span class="hljs-keyword">if</span> (p1 != <span class="hljs-keyword">null</span>)&#123;                sum += p1.val;                p1 = p1.next;            &#125;             <span class="hljs-keyword">if</span> (p2 != <span class="hljs-keyword">null</span>)&#123;                sum += p2.val;                p2 = p2.next;            &#125;            <span class="hljs-comment">//进位更新</span>            add = sum / <span class="hljs-number">10</span>;            p.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);            p = p.next;        &#125;        <span class="hljs-comment">//还有进位，则直接在末尾添上节点1</span>        <span class="hljs-keyword">if</span> (add != <span class="hljs-number">0</span>)&#123;            p.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//返回之前暂存的结果指针后面的节点</span>        <span class="hljs-keyword">return</span> q.next;    &#125;&#125;</code></pre><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25-K个一组翻转链表"></a>25-K个一组翻转链表</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点<code>保持原有顺序</code>。</p><p><code>进阶</code>：</p><p>你可以设计一个只使用<code>常数额外空间</code>的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210318155055481.png" class=""><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        <span class="hljs-comment">//记录结果指针</span>        ListNode res = pre;        pre.next = head;        ListNode p = head, q = head;        <span class="hljs-keyword">int</span> listLen = <span class="hljs-number">0</span>;        <span class="hljs-comment">//得到链表长度</span>        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>)&#123;            q = q.next;            listLen++;        &#125;        <span class="hljs-comment">//得到需要翻转的链表的组数</span>        <span class="hljs-keyword">int</span> groupNum = listLen / k;                <span class="hljs-keyword">while</span> (groupNum-- &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.next != <span class="hljs-keyword">null</span> &amp;&amp; ++cnt &lt; k)&#123;                ListNode tmp = pre.next;                pre.next = p.next;                p.next = p.next.next;                pre.next.next = tmp;            &#125;            <span class="hljs-comment">//重置链表开始翻转的位置</span>            pre = p;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> res.next;                    &#125;&#125;</code></pre><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42-接雨水"></a>42-接雨水</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210319094640704.png" class=""><p><code>按列计算的普通解法</code>——某列能存水的数目等于左右两侧最高处中的最小值(比该列高)减去该列的高度</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210319100446457.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<span class="hljs-comment">//按列的普通解法O(n^2)</span>        <span class="hljs-keyword">int</span> n = height.length;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-comment">//第一个位置和最后一个位置肯定存不了水，所以掐头去尾</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">int</span> maxLeft = Integer.MIN_VALUE, maxRight = Integer.MIN_VALUE;            <span class="hljs-comment">//找左侧最高</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;                maxLeft = Math.max(maxLeft, height[j]);            &#125;            <span class="hljs-comment">//找右侧最高</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                maxRight = Math.max(maxRight, height[j]);            &#125;            <span class="hljs-keyword">int</span> minHeight = Math.min(maxLeft, maxRight);            <span class="hljs-comment">//两边的最高柱一定要比当前位置高度高才能存水</span>            <span class="hljs-keyword">if</span> (minHeight &gt; height[i])&#123;                <span class="hljs-comment">//第i个位置能盛多少容积的水？ —— 位置i的左右两侧柱子的最高高度中的最小值减去自身高度</span>                res += (minHeight - height[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><code>动态规划</code>——空间换时间，在进行按列遍历前就求好左右两侧最高柱的高度O(N^2)-&gt;O(2*N)</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<span class="hljs-comment">//动态规划，空间换时间，事先就求好位置i左右两侧的最高柱的高度</span>        <span class="hljs-keyword">int</span> n = height.length;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] maxLeft = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] maxRight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-comment">//左侧</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;            maxLeft[i] = Math.max(maxLeft[i - <span class="hljs-number">1</span>] , height[i - <span class="hljs-number">1</span>]);        &#125;        <span class="hljs-comment">//右侧</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;            maxRight[i] = Math.max(maxRight[i + <span class="hljs-number">1</span>], height[i + <span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">int</span> minHeight = Math.min(maxLeft[i], maxRight[i]);            <span class="hljs-keyword">if</span> (minHeight &gt; height[i])&#123;                <span class="hljs-comment">//第i个位置能盛多少容积的水？ —— 位置i的左右两侧柱子的最高高度中的最小值减去自身高度</span>                res += (minHeight - height[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><code>双指针 + 动态规划</code>：时O(N)，空O(1)</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<span class="hljs-comment">//双指针 + 动态规划，时O(N) , 空O(1)</span>        <span class="hljs-keyword">int</span> n = height.length;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;        <span class="hljs-comment">//分别存储左右两侧的最高值</span>        <span class="hljs-keyword">int</span> leftMax = <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;        <span class="hljs-comment">//双指针对象遍历</span>        <span class="hljs-keyword">while</span> (left &lt; right)&#123;   <span class="hljs-comment">//保证当前列是和左右两侧最低的比</span>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right])&#123;                <span class="hljs-comment">//比左边最高还要高，存不了水，更新左侧最高值即可</span>                <span class="hljs-keyword">if</span> (height[left] &gt;= leftMax)&#123;                    leftMax = height[left];                &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//将当前列能存储的水累加到res</span>                    res += (leftMax - height[left]);                &#125;                <span class="hljs-comment">//左指针右移</span>                left++;            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//若右侧较低时，同理</span>                <span class="hljs-keyword">if</span> (height[right] &gt;= rightMax)&#123;                    rightMax = height[right];                &#125; <span class="hljs-keyword">else</span> &#123;                    res += (rightMax - height[right]);                &#125;                <span class="hljs-comment">//右指针左移</span>                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328-奇偶链表"></a>328-奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><code>示例1:</code></p><pre><code class="hljs text">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><p><code>图解</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210319103411691.png" class=""><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//链表为空，或者只有一个节点，直接返回null或者那个唯一的节点，即head</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;        ListNode p = head, q = head.next, evenBegin = q;        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span> &amp;&amp; q.next != <span class="hljs-keyword">null</span>)&#123;            p.next = q.next;            q.next = q.next.next;            p = p.next;            q = q.next;        &#125;        p.next = evenBegin;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4-寻找两个正序数组的中位数"></a>4-寻找两个正序数组的中位数</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p> <code>优先权队列</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;            pq.offer(num);            cnt++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums2) &#123;            pq.offer(num);            cnt++;        &#125;        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (k &lt; cnt)&#123;            <span class="hljs-keyword">double</span> tmp = pq.poll() * <span class="hljs-number">1.0</span>;            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span> (k == cnt / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> tmp;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (k == cnt / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (tmp + pq.poll() * <span class="hljs-number">1.0</span>) / <span class="hljs-number">2</span>;            &#125;            k++;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;    &#125;&#125;</code></pre><p><code>二分查找</code>  —— 不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度m和n已知，因此中位数对应的两个数组的下标之和也是已知的。问题转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1。<a href="https://blog.csdn.net/en_joker/article/details/107179641">解法来源</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> totalLength = length1 + length2;        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> midIndex = totalLength / <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> median;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> midIndex1 = totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;            <span class="hljs-keyword">return</span> median;        &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><span class="hljs-comment">         */</span>         <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> kthElement = <span class="hljs-number">0</span>;         <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">// 边界情况</span>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (index2 == length2) &#123;                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);            &#125;                        <span class="hljs-comment">// 正常情况</span>            <span class="hljs-keyword">int</span> half = k / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);                index1 = newIndex1 + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);                index2 = newIndex2 + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141-环形链表"></a>141-环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p><code>快慢指针</code> —— 快指针比慢指针每次多走一步，没环不可能相等，有环，环中节点数==快指针比慢指针多走的步数。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode fastPtr = head, slowPtr = head;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            fastPtr = fastPtr.next.next;            slowPtr = slowPtr.next;            <span class="hljs-keyword">if</span> (fastPtr == slowPtr) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h2 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142-环形链表Ⅱ"></a>142-环形链表Ⅱ</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p><code>HashSet</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//HashSet</span>        HashSet&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (set.contains(head))&#123;                <span class="hljs-keyword">return</span> head;            &#125; <span class="hljs-keyword">else</span> &#123;                set.add(head);                head = head.next;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p><code>快慢指针</code>，非环节点数为a，环节点数为b，走<code>a+nb</code>步一定在环的入口节点</p><ul><li>第一次相遇，快指针走的步数为慢指针的两倍，快出来的部分是环的长度的若干倍nb，所以慢指针此时也走了nb步；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//快慢指针</span>        ListNode slowPtr = head, fastPtr = head;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            slowPtr = slowPtr.next;            fastPtr = fastPtr.next.next;            <span class="hljs-comment">//第一次相遇，这时候，快指针比慢指针已经多走了链表环的长度</span>            <span class="hljs-keyword">if</span> (fastPtr == slowPtr) <span class="hljs-keyword">break</span>;        &#125;<span class="hljs-comment">//无环情况</span>        <span class="hljs-keyword">if</span> (fastPtr == <span class="hljs-keyword">null</span> || fastPtr.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//慢指针从头开始，快指针模仿慢指针继续每次走一步，两方相遇点即为环的入口节点</span>        slowPtr = head;        <span class="hljs-comment">//第二次相遇即环的入口节点</span>        <span class="hljs-keyword">while</span> (slowPtr != fastPtr)&#123;            slowPtr = slowPtr.next;            fastPtr = fastPtr.next;        &#125;        <span class="hljs-keyword">return</span> slowPtr;    &#125;&#125;</code></pre><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146-LRU缓存机制"></a>146-LRU缓存机制</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p><code>示例</code></p><pre><code class="hljs text">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p><code>LinkedHashMap</code></p><p>加入插入顺序为key1，key2，key3，key4，那么就会维护一个红线所示的双向链表。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210320153900676.png" class=""><p>get实现：</p><ul><li>map中不包含当前key，返回-1；</li><li>包含当前key，先从LinkedHashMap中删除它，再添加到双向链表的末尾，刷新最久未使用时间（放入双向链表末尾）；</li></ul><p>put实现：</p><ul><li>map中包含key，则修改其key值并同时刷新最久未使用时间（放入双向链表末尾）；</li><li>map中不包含key，且容量已经满了，则使用迭代器遍历LinkedHashMap中的entry，此时双向链表第一个非头节点的key就是需要淘汰的最久未使用的key，淘汰它，并把新的key放入双向链表末尾；</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key))&#123;            <span class="hljs-keyword">int</span> val = map.get(key);            <span class="hljs-comment">//先移除再添加，保证每次查询后的key都在双向链表的末尾</span>            map.remove(key);            map.put(key, val);            <span class="hljs-keyword">return</span> val;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;        <span class="hljs-comment">//put操作也会访问key，所以也要先移除再更新</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;map.remove(key);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.size() == capacity) &#123;            <span class="hljs-comment">//移除链表头节点，即最近最久未使用的节点</span><span class="hljs-keyword">int</span> oldestKey = map.keySet().iterator().next();            map.remove(oldestKey);&#125;        <span class="hljs-comment">//更新map中键key对应的value</span>map.put(key, value);    &#125;    &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><span class="hljs-comment"> * int param_1 = obj.get(key);</span><span class="hljs-comment"> * obj.put(key,value);</span><span class="hljs-comment"> */</span></code></pre><h2 id="169-多数元素（求众数）"><a href="#169-多数元素（求众数）" class="headerlink" title="169-多数元素（求众数）"></a>169-多数元素（求众数）</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><code>投票法</code></p><p>从第一个数开始，有自己的一票，如果当前元素和候选元素相同，则候选元素票数+1；如果不同，候选元素票数-1，同时判断票数是否减为0了，是的话就更换候选众数为当前遍历到的数。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> candidate = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> vote = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span> (candidate == nums[i])&#123;                vote++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (--vote == <span class="hljs-number">0</span>)&#123;                candidate = nums[i];                vote = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> candidate;    &#125;&#125;</code></pre><h2 id="229-求众数"><a href="#229-求众数" class="headerlink" title="229-求众数"></a>229-求众数</h2><p>给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p>进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题</p><p><code>Map</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        Iterator&lt;Integer&gt; iter = map.keySet().iterator();        <span class="hljs-keyword">while</span> (iter.hasNext())&#123;            <span class="hljs-keyword">int</span> key = iter.next();            <span class="hljs-keyword">if</span> (map.get(key) &gt;= n / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)&#123;                res.add(key);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><code>投票法</code>，显然最多有2个出现次数超过 ⌊ n/3 ⌋ 次的元素，所以同时推选两个候选人并配对计数就行</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 创建返回值</span>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-comment">// 初始化两个候选人candidate，和他们的计票</span>        <span class="hljs-keyword">int</span> cand1 = nums[<span class="hljs-number">0</span>], count1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cand2 = nums[<span class="hljs-number">0</span>], count2 = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 摩尔投票法，分为两个阶段：配对阶段和计数阶段</span>        <span class="hljs-comment">// 配对阶段</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-comment">// 投票</span>            <span class="hljs-keyword">if</span> (cand1 == num) &#123;                count1++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (cand2 == num) &#123;                count2++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 第1个候选人配对</span>            <span class="hljs-keyword">if</span> (count1 == <span class="hljs-number">0</span>) &#123;                cand1 = num;                count1++;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 第2个候选人配对</span>            <span class="hljs-keyword">if</span> (count2 == <span class="hljs-number">0</span>) &#123;                cand2 = num;                count2++;                <span class="hljs-keyword">continue</span>;            &#125;            count1--;            count2--;        &#125;        <span class="hljs-comment">// 计数阶段</span>        <span class="hljs-comment">// 找到了两个候选人之后，需要确定票数是否满足大于 N/3</span>        count1 = <span class="hljs-number">0</span>;        count2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (cand1 == num) count1++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cand2 == num) count2++;        &#125;        <span class="hljs-keyword">if</span> (count1 &gt; nums.length / <span class="hljs-number">3</span>) res.add(cand1);        <span class="hljs-keyword">if</span> (count2 &gt; nums.length / <span class="hljs-number">3</span>) res.add(cand2);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234-回文链表"></a>234-回文链表</h2><p>请判断一个链表是否为回文链表。</p><p><code>栈 + 快慢指针</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        ListNode slowPtr = head;        ListNode fastPtr = head;        <span class="hljs-comment">//快指针走到最后一个节点或者空节点时，慢指针正好走到链表的中间节点</span>        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//前一半元素压栈</span>            stk.push(slowPtr.val);            slowPtr = slowPtr.next;            fastPtr = fastPtr.next.next;        &#125;        <span class="hljs-comment">//奇长链表，此时slowPtr在正中间，且唯一，没被压进栈中</span>        <span class="hljs-keyword">if</span> (fastPtr != <span class="hljs-keyword">null</span>) &#123;            stk.push(slowPtr.val);        &#125;       <span class="hljs-comment">//依次出栈比较</span>        <span class="hljs-keyword">while</span> (slowPtr != <span class="hljs-keyword">null</span> &amp;&amp; !stk.isEmpty())&#123;            <span class="hljs-keyword">int</span> tmp = stk.pop();            <span class="hljs-keyword">if</span> (slowPtr.val != tmp) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            slowPtr = slowPtr.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102-二叉树的层序遍历"></a>102-二叉树的层序遍历</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><code>队列</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.offer(root);        <span class="hljs-keyword">while</span> (!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.poll();                tmp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.offer(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.offer(cur.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19-删除链表的倒数第N个节点"></a>19-删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210322093937080.png" class=""><p><code>前后双指针</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-comment">//链表长度为1，删除完就返回null</span>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        res.next = head;        ListNode backPtr = res, frontPtr = res;        <span class="hljs-comment">//让frontPtr多走n步,等到frontPtr走到末尾，backPtr就走到了要删除的位置的前一个位置</span>        <span class="hljs-keyword">while</span> (frontPtr.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)&#123;                frontPtr = frontPtr.next;                n--;                <span class="hljs-keyword">continue</span>;            &#125;            frontPtr = frontPtr.next;            backPtr = backPtr.next;        &#125;        <span class="hljs-comment">//删除backPtr指向节点的后一个节点</span>        backPtr.next = backPtr.next.next;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61-旋转链表"></a>61-旋转链表</h2><p>给定一个链表，向右旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><code>示例</code></p><pre><code class="hljs text">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p><code>前后指针</code>——前面的指针比后面的指针多走k步</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-comment">//链表为空 || 链表长为1 || 向右旋转位数为0，返回head即可</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;        ListNode backPtr = head, frontPtr = head, q = head;        <span class="hljs-comment">//得到链表长度</span>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>)&#123;            cnt++;            q = q.next;        &#125;        <span class="hljs-comment">//旋转次数超过链表长度，取下模即可</span>        <span class="hljs-keyword">int</span> add = k % cnt;        <span class="hljs-comment">//取模后为0，相当于不旋转</span>        <span class="hljs-keyword">if</span> (add == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;                <span class="hljs-keyword">while</span> (frontPtr.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (add-- &gt; <span class="hljs-number">0</span>)&#123;                frontPtr = frontPtr.next;                <span class="hljs-keyword">continue</span>;            &#125;            backPtr = backPtr.next;            frontPtr = frontPtr.next;        &#125;        <span class="hljs-comment">//记录旋转位置</span>        ListNode rotateHead = backPtr.next;        <span class="hljs-comment">//链表前面部分的尾部置null</span>        backPtr.next = <span class="hljs-keyword">null</span>;        ListNode p = rotateHead;        <span class="hljs-comment">//遍历到尾部</span>        <span class="hljs-keyword">while</span> (p.next != <span class="hljs-keyword">null</span>)&#123;            p = p.next;        &#125;        <span class="hljs-comment">//拼接</span>        p.next = head;        <span class="hljs-keyword">return</span> rotateHead;            &#125;&#125;</code></pre><p><code>构造环形链表</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">//构造环形链表</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        ListNode p = head;        <span class="hljs-keyword">while</span> (p.next != <span class="hljs-keyword">null</span>)&#123;            cnt++;            p = p.next;        &#125;        <span class="hljs-comment">//注意，这里需要再加1才是链表长度</span>        cnt++;        <span class="hljs-comment">//偏移量取模</span>        k = k % cnt;        <span class="hljs-comment">//找到尾部成环</span>        p.next = head;        <span class="hljs-comment">//再遍历cnt - K个位置拆开环即可</span>        <span class="hljs-keyword">int</span> offset = cnt - k;        <span class="hljs-keyword">while</span> (offset-- &gt; <span class="hljs-number">0</span>)&#123;            head = head.next;            p = p.next;        &#125;        p.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153-寻找旋转排序数组中的最小值"></a>153-寻找旋转排序数组中的最小值</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><p><code>二分搜素</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210322140518129.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-comment">//注意left &lt; right - 1</span>        <span class="hljs-keyword">while</span> (left &lt; right - <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid])&#123;                left = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid;            &#125;            <span class="hljs-keyword">return</span> nums[right];        &#125;    &#125;&#125;</code></pre><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215-数组中的第K个最大元素"></a>215-数组中的第K个最大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><code>优先权队列</code>——最大堆/最小堆</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (k &gt; n / <span class="hljs-number">2</span>)&#123;            PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n, (a, b) -&gt; b - a);            getRes(maxHeap, nums, k);        &#125; <span class="hljs-keyword">else</span> &#123;            PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n);            getRes(minHeap, nums, n - k + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">//从最大堆或者最小堆中获取结果</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRes</span><span class="hljs-params">(PriorityQueue&lt;Integer&gt; heap, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> cnt)</span></span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            heap.offer(num);        &#125;        <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>)&#123;            res = heap.poll();        &#125;    &#125;&#125;</code></pre><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155-最小栈"></a>155-最小栈</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    Deque&lt;Integer&gt; stk1;    Deque&lt;Integer&gt; stk2;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        stk1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        stk2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">//当前栈中无元素，所以设置辅助栈最小元素为Integer.MAX_VALUE，使之不会为空</span>        stk2.push(Integer.MAX_VALUE);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;        stk1.push(val);        stk2.push(Math.min(val, stk2.peek()));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!stk1.isEmpty())&#123;            stk1.pop();            stk2.pop();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span>;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> stk1.peek();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> stk2.peek();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><span class="hljs-comment"> * MinStack obj = new MinStack();</span><span class="hljs-comment"> * obj.push(val);</span><span class="hljs-comment"> * obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.top();</span><span class="hljs-comment"> * int param_4 = obj.getMin();</span><span class="hljs-comment"> */</span></code></pre><h2 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240-搜索二维矩阵"></a>240-搜索二维矩阵</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列</li><li>每列的元素从上到下升序排列</li></ul><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210322144900866.png" class=""><p><code>双指针</code> —— 从右上角开始找</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (row &lt;= m - <span class="hljs-number">1</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target)&#123;                col--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target)&#123;                row++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21-合并两个有序链表"></a>21-合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210322145657980.png" class=""><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode p = res;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val)&#123;                p.next = <span class="hljs-keyword">new</span> ListNode(l1.val);                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                p.next = <span class="hljs-keyword">new</span> ListNode(l2.val);                l2 = l2.next;            &#125;            p = p.next;        &#125;        p.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53-最大子序和"></a>53-最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><code>动态规划</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];         <span class="hljs-keyword">int</span> sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> dp_0 = nums[<span class="hljs-number">0</span>], dp_1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            dp_1 = Math.max(dp_0 + nums[i], nums[i]);            <span class="hljs-comment">//在所有以nums[i]结尾的子数组最大和中取最大的</span>            sum = Math.max(sum, dp_1);            dp_0 = dp_1;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160-相交链表"></a>160-相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<strong>：</strong></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/160_statement.png" class=""><p>在节点 c1 开始相交。</p><p><code>双指针</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;        ListNode p = headA, q = headB;        <span class="hljs-keyword">while</span> (p != q)&#123;            p = p == <span class="hljs-keyword">null</span> ? headB : p.next;            q = q == <span class="hljs-keyword">null</span> ? headA : q.next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232-用栈实现队列"></a>232-用栈实现队列</h2><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210322164318139.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;    Deque&lt;Integer&gt; stk1;    Deque&lt;Integer&gt; stk2;    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;        stk1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        stk2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;        <span class="hljs-comment">/** Push element x to the back of queue. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        stk1.push(x);    &#125;        <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (stk2.isEmpty())&#123;            <span class="hljs-keyword">while</span> (!stk1.isEmpty())&#123;                stk2.push(stk1.pop());            &#125;        &#125;        <span class="hljs-keyword">return</span> stk2.pop();    &#125;        <span class="hljs-comment">/** Get the front element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (stk2.isEmpty())&#123;            <span class="hljs-keyword">while</span> (!stk1.isEmpty())&#123;                stk2.push(stk1.pop());            &#125;                    &#125;        <span class="hljs-keyword">return</span> stk2.peek();    &#125;        <span class="hljs-comment">/** Returns whether the queue is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//两个栈都必须为空，队列才为空</span>        <span class="hljs-keyword">return</span> stk2.isEmpty() &amp;&amp; stk1.isEmpty();    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><span class="hljs-comment"> * obj.push(x);</span><span class="hljs-comment"> * int param_2 = obj.pop();</span><span class="hljs-comment"> * int param_3 = obj.peek();</span><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><span class="hljs-comment"> */</span></code></pre><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20-有效的括号"></a>20-有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">//top从1开始</span>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">1</span>;        <span class="hljs-keyword">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length() + <span class="hljs-number">1</span>];        <span class="hljs-comment">//遍历字符串中每个字符的简便写法</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: s.toCharArray())&#123;            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                <span class="hljs-comment">//遇左括号入栈</span>                stack[top++] = c;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stack[--top] != <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<span class="hljs-comment">//遇右括号则判断是否与此时栈顶元素匹配</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   <span class="hljs-comment">//不匹配则直接返回false</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stack[--top] != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stack[--top] != <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> top == <span class="hljs-number">1</span>; <span class="hljs-comment">//判断空栈条件是否成立，若&quot;top==1为真&quot;说,明此时栈中元素全部成功匹配</span>    &#125;&#125;</code></pre><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136-只出现一次的数字"></a>136-只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><code>位运算</code>—— 异或</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            sum ^= num;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23-合并K个排序链表"></a>23-合并K个排序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = lists.length;        ListNode res = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-comment">//两个两个合并</span>            res = mergeTwoLists(res, lists[i]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span></span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode pre = res;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val)&#123;                pre.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.next = l2;                l2 = l2.next;            &#125;            pre = pre.next;        &#125;        pre.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236-二叉树的最近公共祖先"></a>236-二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<strong>一个节点也可以是它自己的祖先</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-comment">//root为空，返回null;</span>        <span class="hljs-comment">//p或q为当前子树的根，则LCA为p或q</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || p == root || q == root) <span class="hljs-keyword">return</span> root;                TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);                <span class="hljs-comment">//p,q分别在左右子树，左右子树的根就是LCA</span>        <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">//p,q在同一子树，要么p为LCA，要么q为LCA</span>        <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : left;    &#125;&#125;</code></pre><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144-二叉树的前序遍历"></a>144-二叉树的前序遍历</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        preOrder(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        res.add(node.val);        preOrder(node.left);        preOrder(node.right);    &#125;&#125;</code></pre><h2 id="172-阶乘后的0"><a href="#172-阶乘后的0" class="headerlink" title="172-阶乘后的0"></a>172-阶乘后的0</h2><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量</p><p><code>数学</code></p><ul><li>每个5可以提供一个0</li><li>每个25可以提供两个0</li><li>每个125可以提供3个0</li><li>。。。</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>;        <span class="hljs-comment">//等价于求1~n中，质因子5出现的次数</span>        <span class="hljs-keyword">while</span> (base &lt; n)&#123;            base = base * <span class="hljs-number">5</span>;            cnt += n / base;        &#125;        <span class="hljs-keyword">return</span> cnt;            &#125;&#125;</code></pre><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110-平衡二叉树"></a>110-平衡二叉树</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (Math.abs(getHeight(root.left) - getHeight(root.right)) &gt; <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));    &#125;&#125;</code></pre><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112-路径总和"></a>112-路径总和</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p><code>DFS</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//符合路径目标和的叶子节点</span>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; root.val == targetSum) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">boolean</span> left = hasPathSum(root.left, targetSum - root.val);        <span class="hljs-keyword">boolean</span> right = hasPathSum(root.right, targetSum - root.val);        <span class="hljs-comment">//左子树和右子树有一个满足路径和就返回true</span>        <span class="hljs-keyword">if</span> (left || right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    &#125;</code></pre><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33-搜索旋转排序数组"></a>33-搜索旋转排序数组</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><p><code>找分割点，分别进行二分搜索</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span> split = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">if</span> (nums[i + <span class="hljs-number">1</span>] &lt; nums[i])&#123;                split = i + <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> res1 = binarySearch(Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, split), target);        <span class="hljs-keyword">int</span> res2 = binarySearch(Arrays.copyOfRange(nums, split, len), target);        <span class="hljs-keyword">if</span> (res1 != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res1;        <span class="hljs-keyword">if</span> (res2 != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res2 + split;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> (arr[mid] &gt; k)&#123;                right = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; k)&#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><code>直接进行二分搜素</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;                <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;            <span class="hljs-comment">//nums[mid]在左半部分</span>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[left])&#123;                <span class="hljs-comment">//target的值也在左半部分之间</span>                <span class="hljs-keyword">if</span> (nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)&#123;                    right = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    right = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="239-滑动窗口的最大值"><a href="#239-滑动窗口的最大值" class="headerlink" title="239-滑动窗口的最大值"></a>239-滑动窗口的最大值</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">// //双指针</span>        <span class="hljs-comment">// int n = nums.length;</span>        <span class="hljs-comment">// if (n &lt;= 1) return nums;</span>        <span class="hljs-comment">// int[] res = new int[n - k + 1];</span>        <span class="hljs-comment">// int left = 0, right = k - 1;</span>        <span class="hljs-comment">// while (right &lt; n)&#123;</span>        <span class="hljs-comment">//     int maxVal = Integer.MIN_VALUE;</span>        <span class="hljs-comment">//     for (int i = left; i &lt;= right; i++)&#123;</span>        <span class="hljs-comment">//         maxVal = Math.max(maxVal, nums[i]);</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">//     res[left] = maxVal;</span>        <span class="hljs-comment">//     left++;</span>        <span class="hljs-comment">//     right++;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return res;</span>        <span class="hljs-comment">//最大堆 + 双指针</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || n &lt; k) <span class="hljs-keyword">return</span> nums;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b - a));        <span class="hljs-comment">//n-k+1为长度为n的数组中大小为k的滑动窗口个数</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n - k + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; right &lt; k; right++)&#123;            pq.offer(nums[right]);        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (right &lt; n)&#123;            res[left++] = pq.peek();            <span class="hljs-comment">//移除第一个元素</span>            pq.remove(nums[right - k]);            <span class="hljs-comment">//nums[right]入堆</span>            pq.add(nums[right]);            right++;        &#125;        <span class="hljs-comment">//最后一次入堆没有放元素到res中</span>        res[left] = pq.peek();        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480-滑动窗口中位数"></a>480-滑动窗口中位数</h2><p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><p>例如：</p><ul><li>[2,3,4]，中位数是 3</li><li>[2,3]，中位数是 (2 + 3) / 2 = 2.5</li></ul><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210329095743208.png" class=""><p><code>堆</code> —— <em>小顶堆存放较大的一半元素， 大顶堆存放较小的一半元素(保证小根堆元素数目不比大根堆少)</em></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    PriorityQueue&lt;Integer&gt; minHeap;    PriorityQueue&lt;Integer&gt; maxHeap;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] medianSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n - k + <span class="hljs-number">1</span>];        minHeap  = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(a, b));         maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(b, a));         <span class="hljs-comment">//小顶堆存放较大的一半元素， 大顶堆存放较小的一半元素(保证小根堆元素数目不比大根堆少)</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) minHeap.add(nums[i]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k / <span class="hljs-number">2</span>; i++) maxHeap.add(minHeap.poll());        res[<span class="hljs-number">0</span>] = getMid();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; n; i++) &#123;            <span class="hljs-comment">//滑动窗口要删除的元素</span>            <span class="hljs-keyword">int</span> del = nums[i - k];            <span class="hljs-comment">//入小顶堆</span>            <span class="hljs-keyword">if</span> (nums[i] &gt;= minHeap.peek()) &#123;                minHeap.add(nums[i]);            &#125; <span class="hljs-keyword">else</span> &#123;                maxHeap.add(nums[i]);            &#125;            <span class="hljs-comment">//要删除的元素在小顶堆</span>            <span class="hljs-keyword">if</span> (del &gt;= minHeap.peek()) &#123;                minHeap.remove(del);            &#125; <span class="hljs-keyword">else</span> &#123;                maxHeap.remove(del);            &#125;            adjust();            res[i - k + <span class="hljs-number">1</span>] = getMid();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (maxHeap.size() &gt; minHeap.size()) minHeap.add(maxHeap.poll());        <span class="hljs-keyword">while</span> (minHeap.size() - maxHeap.size() &gt; <span class="hljs-number">1</span>) maxHeap.add(minHeap.poll());    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getMid</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;            <span class="hljs-keyword">return</span> (maxHeap.peek() / <span class="hljs-number">2.0</span>) + (minHeap.peek() / <span class="hljs-number">2.0</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> minHeap.peek() * <span class="hljs-number">1.0</span>;        &#125;    &#125;&#125;</code></pre><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54-螺旋矩阵"></a>54-螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210323102406007.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">//记录起止位置</span>        <span class="hljs-keyword">int</span> rowStart = <span class="hljs-number">0</span>, rowEnd = m - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> colStart = <span class="hljs-number">0</span>, colEnd = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd)&#123;            <span class="hljs-comment">//向右</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = colStart; i &lt;= colEnd; i++)&#123;                res.add(matrix[rowStart][i]);            &#125;            <span class="hljs-comment">//少一行</span>            rowStart++;            <span class="hljs-comment">//向下</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = rowStart; i &lt;= rowEnd; i++)&#123;                res.add(matrix[i][colEnd]);            &#125;            <span class="hljs-comment">//少一列</span>            colEnd--;            <span class="hljs-comment">//还能向左</span>            <span class="hljs-keyword">if</span> (rowStart &lt;= rowEnd)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = colEnd; i &gt;= colStart; i--)&#123;                    res.add(matrix[rowEnd][i]);                &#125;                rowEnd--;            &#125;                        <span class="hljs-comment">//还能向上</span>            <span class="hljs-keyword">if</span> (colStart &lt;= colEnd)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = rowEnd; i &gt;= rowStart; i--)&#123;                    res.add(matrix[i][colStart]);                &#125;                colStart++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="59-螺旋矩阵Ⅱ"><a href="#59-螺旋矩阵Ⅱ" class="headerlink" title="59-螺旋矩阵Ⅱ"></a>59-螺旋矩阵Ⅱ</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210325145819645.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-keyword">int</span> rowStart = <span class="hljs-number">0</span>, rowEnd = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> colStart = <span class="hljs-number">0</span>, colEnd = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd &amp;&amp; cnt &lt;= n * n)        &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = colStart; i &lt;= colEnd; i++)&#123;                res[rowStart][i] = cnt++;            &#125;            rowStart++;            <span class="hljs-comment">//向下</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = rowStart; i &lt;= rowEnd; i++)&#123;                res[i][colEnd] = cnt++;            &#125;            colEnd--;            <span class="hljs-comment">//如果还能向左</span>            <span class="hljs-keyword">if</span> (rowStart &lt;= rowEnd)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = colEnd; i &gt;= colStart; i--)&#123;                    res[rowEnd][i] = cnt++;                &#125;                rowEnd--;            &#125;            <span class="hljs-comment">//如果还能向上</span>            <span class="hljs-keyword">if</span> (colStart &lt;= colEnd)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = rowEnd; i &gt;= rowStart; i--)&#123;                    res[i][colStart] = cnt++;                &#125;                colStart++;            &#125;                    &#125;        <span class="hljs-keyword">return</span> res;                &#125;&#125;</code></pre><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189-旋转数组"></a>189-旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数;</p><p><code>进阶</code>：</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>        你可以使用空间复杂度为 <code>O(1)</code> 的 原地 算法解决这个问题吗？</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = arr.length;        <span class="hljs-comment">//k取模，防止比n大时避免多余的旋转</span>        k %= len;        <span class="hljs-comment">//先翻转前半部分</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - k - <span class="hljs-number">1</span>; i &lt; j; i++, j--)&#123;            <span class="hljs-keyword">int</span> tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;        &#125;        <span class="hljs-comment">//再翻转后半部分</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - k, j = len - <span class="hljs-number">1</span>; i &lt; j; i++, j--)&#123;            <span class="hljs-keyword">int</span> tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;        &#125;        <span class="hljs-comment">//最后整体反转</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - <span class="hljs-number">1</span>; i &lt; j; i++, j--)&#123;            <span class="hljs-keyword">int</span> tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;        &#125;    &#125;&#125;</code></pre><h2 id="53-最大子序和-1"><a href="#53-最大子序和-1" class="headerlink" title="53-最大子序和"></a>53-最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><code>动态规划</code> —— dp[i]为以nums[i]结尾的具有最大和的连续子数组</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];         <span class="hljs-keyword">int</span> sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> dp_0 = nums[<span class="hljs-number">0</span>], dp_1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            dp_1 = Math.max(dp_0 + nums[i], nums[i]);            sum = Math.max(sum, dp_1);            dp_0 = dp_1;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287-寻找重复数"></a>287-寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p><code>HashSet</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span> (set.contains(num))&#123;                <span class="hljs-keyword">return</span> num;            &#125; <span class="hljs-keyword">else</span> &#123;                set.add(num);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494-目标和"></a>494-目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><code>回溯法</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        backTrack(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, S);        <span class="hljs-keyword">return</span> cnt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-comment">//终止条件 —— 处理到数组末尾</span>        <span class="hljs-keyword">if</span> (idx == arr.length)&#123;            <span class="hljs-keyword">if</span> (sum == target)&#123;                cnt++;            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//选择&quot;+&quot;</span>        sum += arr[idx];        backTrack(arr, idx + <span class="hljs-number">1</span>, sum, target);        <span class="hljs-comment">//撤销选择</span>        sum -= arr[idx];        <span class="hljs-comment">//选择&quot;-&quot;</span>        sum -= arr[idx];        backTrack(arr, idx + <span class="hljs-number">1</span>, sum, target);        <span class="hljs-comment">//撤销选择</span>        sum += arr[idx];    &#125;&#125;</code></pre><p><code>动态规划之01背包问题</code></p><ul><li>假设nums中，正数的和为x，负数的和为y，则S=x-y，sum(nums) = x + y，由此推出x = (S + sum) / 2，问题转化为在nums中寻找若干数使得和为(S+sum)/2，这时问题转化为了01背包问题。</li><li>dp[j] —— 填满容量为j的背包，有dp[j]种方法。</li><li>状态转移 —— dp[j] = dp[j] + dp[j - num]; 当前填满容量为j的包的方法数 = 之前填满容量为j的包的方法数 + 之前填满容量为j - num的包的方法数。也就是当前数num的加入，可以把之前和为j - num的方法数加入进来。</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) sum += num;        <span class="hljs-comment">//不可能有解的情况</span>        <span class="hljs-comment">//1. 数组中全部数字(正)的和小于S</span>        <span class="hljs-comment">//2. (sum + S) / 2 为奇数，此时x不是整数</span>        <span class="hljs-keyword">if</span> (sum &lt; S || (sum + S) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> subset(nums, (sum + S) / <span class="hljs-number">2</span>);            &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= arr.length; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= <span class="hljs-number">0</span>; j--)&#123;                <span class="hljs-keyword">if</span> (j &gt;= arr[i - <span class="hljs-number">1</span>])&#123;                    dp[j] = dp[j] + dp[j - arr[i - <span class="hljs-number">1</span>]];                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[j] = dp[j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[target];    &#125;        &#125;</code></pre><h2 id="227-基本计算器Ⅱ"><a href="#227-基本计算器Ⅱ" class="headerlink" title="227-基本计算器Ⅱ"></a>227-基本计算器Ⅱ</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> preOps = <span class="hljs-string">&#x27;+&#x27;</span>;        Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i)))&#123;                num  = num * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);            &#125;            <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> || !Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;                <span class="hljs-keyword">switch</span>(preOps)&#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:                        stk.push(num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:                        stk.push(-num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:                        stk.push(stk.pop() * num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:                        stk.push(stk.pop() / num);                        <span class="hljs-keyword">break</span>;                                    &#125;                preOps = s.charAt(i);                num = <span class="hljs-number">0</span>;                            &#125;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            res += stk.pop();        &#125;        <span class="hljs-keyword">return</span> res;            &#125;&#125;</code></pre><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43-字符串相乘"></a>43-字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210325141523203.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        &#125;        <span class="hljs-comment">//相乘的总位数为 M + N</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num1.length() + num2.length()];        <span class="hljs-comment">//从尾至头</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">int</span> n1 = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = num2.length() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;                <span class="hljs-keyword">int</span> n2 = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;                <span class="hljs-keyword">int</span> sum = (res[i + j + <span class="hljs-number">1</span>] + n1 * n2);                <span class="hljs-comment">//该位累加后的和</span>                res[i + j + <span class="hljs-number">1</span>] = sum % <span class="hljs-number">10</span>;                <span class="hljs-comment">//向前进位</span>                res[i + j] += sum / <span class="hljs-number">10</span>;            &#125;        &#125;        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; res[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            result.append(res[i]);        &#125;        <span class="hljs-keyword">return</span> result.toString();    &#125;        &#125;</code></pre><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103-二叉树的锯齿形层序遍历"></a>103-二叉树的锯齿形层序遍历</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><code>BFS</code>——层次遍历，偶数层的结果翻转一下</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.offer(root);        <span class="hljs-keyword">while</span> (!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.poll();                tmp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.offer(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.offer(cur.right);            &#125;            <span class="hljs-keyword">if</span> (res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;                Collections.reverse(tmp);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104-二叉树的最大深度"></a>104-二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><code>递归</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));    &#125;&#125;</code></pre><h2 id="剑指Offer65-不用加减乘除做加法"><a href="#剑指Offer65-不用加减乘除做加法" class="headerlink" title="剑指Offer65-不用加减乘除做加法"></a>剑指Offer65-不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p><code>位运算</code>——异或和不带进位，所以每次异或的结果与进位再次异或，直到进位为0，此时的和就是两数的和。</p><div class="table-container"><table><thead><tr><th style="text-align:center">位运算</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">num1 ^ num2</td><td style="text-align:center">执行加法</td></tr><tr><td style="text-align:center">(num1 &amp; num2) &lt;&lt; 1</td><td style="text-align:center">进位</td></tr></tbody></table></div><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, append = <span class="hljs-number">0</span>;        <span class="hljs-keyword">do</span> &#123;            sum = a ^ b;            append = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;            a = sum;            b = append;        &#125; <span class="hljs-keyword">while</span> (append != <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37-解数独"></a>37-解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li><li>空白格用 ‘.’ 表示。</li></ul><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210325144622457.png" class=""><p><code>回溯</code></p><ul><li>只能一行一行地填元素</li><li>跳过本来就有数字的位置</li><li>做选择时判断选择合不合法， 即行、列、3×3方格内元素不能有重复</li><li>找到可行解及时返回</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        backTrack(board, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] arr, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;        <span class="hljs-keyword">int</span> m = <span class="hljs-number">9</span>, n = <span class="hljs-number">9</span>;        <span class="hljs-comment">//穷举到最后一列，则从下一行开始</span>        <span class="hljs-keyword">if</span> (col == n) <span class="hljs-keyword">return</span> backTrack(arr, row + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-comment">//base case， 把所有数字填完了，即找到一个可行解</span>        <span class="hljs-keyword">if</span> (row == m) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &lt; n; j++)&#123;                <span class="hljs-comment">//board[i][j]上已经有数字了</span>                <span class="hljs-keyword">if</span> (arr[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;                    <span class="hljs-keyword">return</span> backTrack(arr, i, j + <span class="hljs-number">1</span>);                &#125;                <span class="hljs-comment">//在1~9中做选择</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;1&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; c++)&#123;                    <span class="hljs-comment">//选择的数字不合法(违反数独规则)</span>                    <span class="hljs-keyword">if</span> (!isValid(arr, i, j, c))&#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">//做选择，即填数字</span>                    arr[i][j] = c;                    <span class="hljs-comment">//出现可行解，返回true</span>                    <span class="hljs-keyword">if</span> (backTrack(arr, i, j + <span class="hljs-number">1</span>))&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                    <span class="hljs-comment">//撤销选择,回置&#x27;.&#x27;</span>                    arr[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;                &#125;                <span class="hljs-comment">//穷举完1~9仍然没找到可行解，返回false</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">char</span> c)</span></span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;            <span class="hljs-keyword">if</span> (matrix[a][i] == c) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (matrix[i][b] == c) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 判断 3 x 3 方框是否存在重复</span>            <span class="hljs-keyword">if</span> (matrix[(a / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>][(b / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>] == c) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h2 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384-打乱数组"></a>384-打乱数组</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p><p>实现 Solution class:</p><ul><li>Solution(int[] nums) 使用整数数组 nums 初始化对象</li><li>int[] reset() 重设数组到它的初始状态并返回</li><li>int[] shuffle() 返回数组随机打乱后的结果</li></ul><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210325152948253.png" class=""><pre><code class="hljs java"></code></pre><h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162-寻找峰值"></a>162-寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞。</p><p><code>普通解法</code>——时O(N)，空O(1)</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-comment">//处理左边界</span>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; nums[i + <span class="hljs-number">1</span>] &lt; nums[i])&#123;                <span class="hljs-keyword">return</span> i;            &#125;            <span class="hljs-comment">//处理右边界</span>            <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &lt; nums[i])&#123;                <span class="hljs-keyword">return</span> i;            &#125;                        <span class="hljs-comment">//普通情况</span>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>] &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">return</span> i;            &#125;                    &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><code>二分查找</code>——时O(logN)，空O(1)</p><p><code>nums[-1] = nums[n] = -∞</code>，这就代表着 <strong>只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值</strong>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">//二分查找</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right)&#123;            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-comment">//因为nums[n]为负无穷，因此mid右侧会出现峰值</span>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>])&#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//因为nums[-1]为负无穷，因此mid左侧会出现峰值</span>                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre><h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179-最大数"></a>179-最大数</h2><p>给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><code>自定义比较器</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">largestNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> String.valueOf(nums[<span class="hljs-number">0</span>]);        String[] arr = <span class="hljs-keyword">new</span> String[n];        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            arr[i] = String.valueOf(nums[i]);        &#125;        <span class="hljs-comment">//自定义排序</span>        Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;                <span class="hljs-keyword">return</span> (b + a).compareTo(a + b);            &#125;        &#125;);        <span class="hljs-comment">//排序后最大的是0</span>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;0&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        <span class="hljs-keyword">for</span> (String s : arr)&#123;            sb.append(s);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><h2 id="剑指Offer40-最小的K个数"><a href="#剑指Offer40-最小的K个数" class="headerlink" title="剑指Offer40-最小的K个数"></a>剑指Offer40-最小的K个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><code>小根堆</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) &#123;            pq.offer(num);        &#125;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (cnt &lt; k)&#123;            res[cnt++] = pq.poll();        &#125;                <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><code>快排</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-comment">//快排</span>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> Arrays.copyOf(arr, k);    &#125;    <span class="hljs-comment">//快排</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> i = left, j = right;        <span class="hljs-keyword">while</span> (i &lt; j)&#123;            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= array[left]) j--;            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= array[left]) i++;            swap(array, i, j);        &#125;        swap(array, i, left);        <span class="hljs-comment">// 递归左（右）子数组执行哨兵划分</span>        quickSort(array, left, i - <span class="hljs-number">1</span>);        quickSort(array, i + <span class="hljs-number">1</span>, right);    &#125;    <span class="hljs-comment">//交换函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre><p><code>基于快排的数组划分</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;            <span class="hljs-comment">//基于快排的数组划分</span>        <span class="hljs-keyword">if</span> (k &gt;= arr.length) <span class="hljs-keyword">return</span> arr;        <span class="hljs-keyword">return</span> quickSort(arr, k, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//基于快排的数组划分</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)&#123;        <span class="hljs-keyword">int</span> i = left, j = right;        <span class="hljs-keyword">while</span> (i &lt; j)&#123;            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= array[left]) j--;            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= array[left]) i++;            swap(array, i, j);        &#125;        swap(array, i, left);                <span class="hljs-comment">//前k小的元素在左子数组中</span>        <span class="hljs-keyword">if</span> (cnt &lt; i) quickSort(array, cnt, left, i - <span class="hljs-number">1</span>);        <span class="hljs-comment">//前k小的元素在右子数组中</span>        <span class="hljs-keyword">if</span> (cnt &gt; i) quickSort(array, cnt, i + <span class="hljs-number">1</span>, right);        <span class="hljs-comment">//k == i， 说明array[k] 即为第 k + 1小的数字，则直接返回数组前 k 个数字即可</span>        <span class="hljs-keyword">return</span> Arrays.copyOf(array, cnt);    &#125;    <span class="hljs-comment">//交换函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;&#125;</code></pre><h2 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525-连续数组"></a>525-连续数组</h2><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p><p><code>前缀和 + HashMap</code></p><p>把(cnt, i)看作nums[i]的一种状态表示，表明该元素及其前面的全部元素中，1和0的个数差为cnt，如果map不包含key——cnt，则put；包含，则说明此位置和上一个位置这一段区间中，0和1的个数相同。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-comment">//遇0减1，遇1加1</span>            cnt += (nums[i] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (map.containsKey(cnt))&#123;                <span class="hljs-comment">//求区间含0、1个数相同的区间的最大长度</span>                maxLen = Math.max(maxLen, i - map.get(cnt));            &#125; <span class="hljs-keyword">else</span> &#123;                map.put(cnt, i);            &#125;        &#125;        <span class="hljs-keyword">return</span> maxLen;    &#125;&#125;</code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15-三数之和"></a>15-三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><code>HashMap</code>—— 很难去重，以下代码无法去重</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">//返回[]的情况</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">int</span> sum = nums[i];            HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                <span class="hljs-keyword">if</span> (map.containsKey(nums[j]))&#123;                    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[j], nums[map.get(nums[j])])));                &#125; <span class="hljs-keyword">else</span> &#123;                    map.put(-sum - nums[j], j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><code>排序 + 双指针</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">//返回[]的情况</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-comment">//先排序</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n - <span class="hljs-number">2</span>; k++)&#123;            <span class="hljs-comment">//nums[j] &gt;= nums[i] &gt;= nums[k],如果nums[k] &gt; 0，无解</span>            <span class="hljs-keyword">if</span>(nums[k] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有可能组合加入到结果中</span>            <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">//双指针对向移动</span>            <span class="hljs-keyword">int</span> i = k + <span class="hljs-number">1</span>, j = nums.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(i &lt; j)&#123;                <span class="hljs-keyword">int</span> sum = nums[k] + nums[i] + nums[j];                <span class="hljs-comment">//和过小，左指针右移；和过大，右指针左移</span>                <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);                &#125; <span class="hljs-keyword">else</span> &#123;                    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));                    <span class="hljs-comment">//跳过重复的nums[i]和nums[j]</span>                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);                    <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31-下一个排列"></a>31-下一个排列</h2><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成<code>字典序</code>中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即<code>升序</code>排列）。</p><p>必须 <code>原地</code> 修改，只允许使用额外常数空间。</p><ul><li>先从后往前查找第一个递减的元素位置i，保证最小幅度增大排列<ul><li>找到了，再从后往前找比交换位置元素大的第一个元素，交换；再把交换位置后面的元素改为升序</li><li>没找到，说明此时排列已经最大，返回升序序列即可</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;            i--;        &#125;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;                j--;            &#125;            swap(nums, i, j);        &#125;        <span class="hljs-comment">//Arrays.sort(nums, i + 1, nums.length);</span>        reverse(nums, i + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = start, right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            swap(nums, left, right);            left++;            right--;        &#125;    &#125;&#125;</code></pre><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199-二叉树的右视图"></a>199-二叉树的右视图</h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><code>深度优先搜索</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        helper(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (level == res.size())&#123;            res.add(node.val);        &#125;        <span class="hljs-comment">//先右后左</span>        helper(node.right, level + <span class="hljs-number">1</span>);        helper(node.left, level + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26-删除有序数组中的重复项"></a>26-删除有序数组中的重复项</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] != nums[i])&#123;                nums[cnt++] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;</code></pre><h2 id="706-设计Hash映射"><a href="#706-设计Hash映射" class="headerlink" title="706-设计Hash映射"></a>706-设计Hash映射</h2><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><ul><li>MyHashMap() 用空映射初始化对象</li><li>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</li><li>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</li><li>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</li></ul><pre><code class="hljs java"></code></pre><h2 id="剑指Offer03-数组中重复的数字"><a href="#剑指Offer03-数组中重复的数字" class="headerlink" title="剑指Offer03-数组中重复的数字"></a>剑指Offer03-数组中重复的数字</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><code>原地置换</code> —— 如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是从头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m），那么我们就拿与下标m的数字交换，即换到本来顺序的位置上。在交换过程中，如果有重复的数字发生，那么终止返回ture</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// //HashSet</span>        <span class="hljs-comment">// int n = nums.length;</span>        <span class="hljs-comment">// HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span>        <span class="hljs-comment">// for (int num : nums)&#123;</span>        <span class="hljs-comment">//     if (set.contains(num))&#123;</span>        <span class="hljs-comment">//         return num;</span>        <span class="hljs-comment">//     &#125; else &#123;</span>        <span class="hljs-comment">//         set.add(num);</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return -1;</span>        <span class="hljs-comment">//原地置换，一个萝卜一个坑</span>        <span class="hljs-keyword">int</span> tmp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-comment">//不在顺序排序的位置上</span>            <span class="hljs-keyword">while</span> (nums[i] != i)&#123;                <span class="hljs-comment">//发生相等的情况，把重复数字返回即可</span>                <span class="hljs-keyword">if</span>(nums[i] == nums[nums[i]])&#123;                    <span class="hljs-keyword">return</span> nums[i];                &#125;                <span class="hljs-comment">//交换到顺序排序的位置上</span>                tmp = nums[i];                nums[i] = nums[tmp];                nums[tmp] = tmp;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46-全排列"></a>46-全排列</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列</p><p><code>回溯法</code>—— swap()</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            permuteList.add(nums[i]);        &#125;        backTrack(<span class="hljs-number">0</span>, nums.length);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> last)</span></span>&#123;        <span class="hljs-comment">//终止条件</span>        <span class="hljs-keyword">if</span> (begin == last)&#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList));        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i &lt; last; i++)&#123;            <span class="hljs-comment">//做选择，即交换</span>            <span class="hljs-comment">//Collections.swap(permuteList, begin, i);</span>            swap(begin, i);            <span class="hljs-comment">//继续回溯</span>            backTrack(begin + <span class="hljs-number">1</span>, last);            <span class="hljs-comment">//撤销选择，换回来</span>            <span class="hljs-comment">//Collections.swap(permuteList, begin, i);</span>            swap(begin, i);        &#125;    &#125;    <span class="hljs-comment">//交换</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = permuteList.get(j);        permuteList.set(j, permuteList.get(k));        permuteList.set(k, temp);    &#125;&#125;</code></pre><h2 id="200-岛屿数目"><a href="#200-岛屿数目" class="headerlink" title="200-岛屿数目"></a>200-岛屿数目</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><code>深度优先搜索DFS</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> islands = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;                <span class="hljs-comment">//碰到1，说明就是新的陆地</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                    islands++;                    <span class="hljs-comment">//深度优先搜索，把和(i, j)相连的所在岛的全部陆地的都变为0</span>                    dfs(grid, i , j);                &#125;                            &#125;        &#125;        <span class="hljs-keyword">return</span> islands;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-comment">//停止搜索的条件</span>        <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;                <span class="hljs-comment">//置“0”操作</span>        arr[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-comment">//向上搜索</span>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dfs(arr, i - <span class="hljs-number">1</span>, j);        <span class="hljs-comment">//向下搜索</span>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= arr.length - <span class="hljs-number">1</span>) dfs(arr, i + <span class="hljs-number">1</span>, j);        <span class="hljs-comment">//向左搜索</span>        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dfs(arr, i, j - <span class="hljs-number">1</span>);        <span class="hljs-comment">//向右搜索</span>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= arr[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) dfs(arr, i, j + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h2 id="292-Nim游戏"><a href="#292-Nim游戏" class="headerlink" title="292-Nim游戏"></a>292-Nim游戏</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉 1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者</li></ul><p>假设你们每一步都是<code>最优解</code>。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p><p><code>数学</code> —— 每次拿完石头给对手剩4块石头，就稳赢，换言之，在自己的回合中，必须避免石头堆中的石子数为 4 的情况。同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> (n % <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258-各位相加"></a>258-各位相加</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = num;        <span class="hljs-keyword">while</span> (res &gt;= <span class="hljs-number">10</span>)&#123;            res = getDigitSum(res);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">//获取数字各位的和</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigitSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> digit = n % <span class="hljs-number">10</span>;            n /= <span class="hljs-number">10</span>;            sum += digit;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h2 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="378-有序矩阵中第K小的元素"></a>378-有序矩阵中第K小的元素</h2><p>给你一个 n x n 矩阵 matrix ，其中<code>每行和每列元素均按升序</code>排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素.</p><p><code>最小堆</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">//最大堆，只留下最小的k个元素</span>        PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k + <span class="hljs-number">1</span>, (a, b) -&gt; (b - a));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;                maxHeap.offer(matrix[i][j]);                <span class="hljs-keyword">if</span> (maxHeap.size() == k + <span class="hljs-number">1</span>)&#123;                    maxHeap.poll();                &#125;            &#125;        &#125;        <span class="hljs-comment">//此时的堆顶元素就是有序矩阵中第K小的元素</span>        <span class="hljs-keyword">return</span> maxHeap.poll();    &#125;&#125;</code></pre><p><code>二分搜索</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210328094405558.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> row = matrix.length;        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> left = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> right = matrix[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-comment">// 每次循环都保证第K小的数在start~end之间，当start==end，第k小的数就是start</span>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-comment">// 找二维矩阵中&lt;=mid的元素总个数</span>            <span class="hljs-keyword">int</span> count = findNotBiggerThanMid(matrix, mid, row, col);            <span class="hljs-keyword">if</span> (count &lt; k) &#123;                <span class="hljs-comment">// 第k小的数在右半部分，且不包含mid</span>                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 第k小的数在左半部分，可能包含mid</span>                right = mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> right;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNotBiggerThanMid</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-comment">// 以列为单位找，找到每一列最后一个&lt;=mid的数即知道每一列有多少个数&lt;=mid</span>        <span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; col) &#123;            <span class="hljs-keyword">if</span> (matrix[i][j] &lt;= mid) &#123;                <span class="hljs-comment">// 第j列有i+1个元素&lt;=mid</span>                count += i + <span class="hljs-number">1</span>;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 第j列目前的数大于mid，需要继续在当前列往上找</span>                i--;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9-回文数"></a>9-回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> cmp = x;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (cmp != <span class="hljs-number">0</span>)&#123;            sum = sum * <span class="hljs-number">10</span> + cmp % <span class="hljs-number">10</span>;            cmp /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> sum == x;    &#125;&#125;</code></pre><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5-最长回文子串"></a>5-最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><code>动态规划</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;        <span class="hljs-comment">//dp[i][j]指示从chars[i]到chars[j]这段子串是否是回文的</span>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();                <span class="hljs-keyword">boolean</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];        <span class="hljs-comment">//记录最大回文子串的起止位置</span>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;        <span class="hljs-comment">//动态规划</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;            <span class="hljs-comment">//base case</span>            dp[j][j] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)&#123;                <span class="hljs-comment">//子串长为2</span>                <span class="hljs-keyword">if</span> (i == j - <span class="hljs-number">1</span>)&#123;                    <span class="hljs-comment">//回文取决于这两个字符是否相等</span>                    dp[i][j] = chars[i] == chars[j];                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//回文取决于dp[i + 1][j - 1]以及最外侧两侧的字符是否相等</span>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; chars[i] == chars[j];                &#125;                <span class="hljs-comment">//更新最大回文子串的起止位置</span>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i &gt; end - begin)&#123;                    begin = i;                    end = j;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substring(begin, end + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516-最长回文子序列"></a>516-最长回文子序列</h2><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210328104409216.png" class=""><p><code>动态规划</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;        <span class="hljs-comment">//dp[i][j]代表从s.charAt(i)到s.charAt(j)的最长回文子序列的长度</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-comment">//长度至少为1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            dp[i][i] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//动态规划，i要从后往前，因为根据我们的dp定义和题目要求，我们要得到dp[0][n - 1]</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j))&#123;                    <span class="hljs-comment">//长度+2</span>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//区间左边界向右进1或者右区间向左退1</span>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994-腐烂的橘子"></a>994-腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><ul><li>值 0 代表空单元格；</li><li>值 1 代表新鲜橘子；</li><li>值 2 代表腐烂的橘子；</li><li>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</li></ul><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210328105332143.png" class=""><p>与岛屿类的题目很像，都是<code>用不同数字代表状态</code>，每次遍历矩阵时改变符合条件的元素的值，这里腐烂的橘子代表“2”，它会传染相邻的值为“1”的新鲜橘子，最终要求出感染的时间，所以可以在感染新鲜的橘子时，将值为“1”的新鲜橘子修改为感染对应的第几趟（这个橘子是第几趟感染的），比如被“2”的橘子感染，则值变为“3”（第一趟被感染，3-2），被“3”的橘子感染，则值变为“4”（第二趟被感染，4-2），依此类推，最后得到的数值index-3就是被感染的时间了。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> minutes = <span class="hljs-number">3</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">// 这里flag是循环跳出的条件，如果这一次while循环中没有橘子被感染，break;</span>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m - <span class="hljs-number">1</span>; i++)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n - <span class="hljs-number">1</span>; j++)&#123;                    <span class="hljs-comment">//遇到的腐烂橘子</span>                    <span class="hljs-keyword">if</span> (grid[i][j] == minutes - <span class="hljs-number">1</span>)&#123;                        <span class="hljs-comment">//四个方向如果还有新鲜橘子就让它腐烂</span>                        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;                            grid[i - <span class="hljs-number">1</span>][j] = minutes;                            flag = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= grid.length - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;                            grid[i + <span class="hljs-number">1</span>][j] = minutes;                            flag = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;                            grid[i][j - <span class="hljs-number">1</span>] = minutes;                            flag = <span class="hljs-keyword">true</span>;                        &#125;                        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;                            grid[i][j + <span class="hljs-number">1</span>] = minutes;                            flag = <span class="hljs-keyword">true</span>;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//橘子全部腐烂或者所有橘子没有完全腐烂，退出循环</span>            <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//一轮结束还有橘子未腐烂，分钟数+1</span>            minutes++;        &#125;        <span class="hljs-comment">//添加一轮检查，查看是全部腐烂的情况还是没完全腐烂的情况</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;                <span class="hljs-comment">//还有新鲜橘子，则返回-1</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">//否则返回分钟数，即minutes减去基数3</span>        <span class="hljs-keyword">return</span> minutes - <span class="hljs-number">3</span>;            &#125;&#125;</code></pre><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48-旋转图像"></a>48-旋转图像</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像<code>顺时针旋转 90 度</code>。</p><p>你必须在<code>原地</code>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210329143029666.png" class=""><p><code>90度旋转</code>：</p><p>顺时针替换即可</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210329145727697.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">//只需要一半进行顺时针轮转交换</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++)&#123;                <span class="hljs-comment">// temp = 7</span>                <span class="hljs-keyword">int</span> temp = matrix[n - <span class="hljs-number">1</span> - j][i];                <span class="hljs-comment">// 9 -&gt; 7(同一行)</span>                matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j];                <span class="hljs-comment">// 3 -&gt; 9(同一列))</span>                matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j] = matrix[j][n - <span class="hljs-number">1</span> - i];                <span class="hljs-comment">// 1 -&gt; 3(同一行)</span>                matrix[j][n - <span class="hljs-number">1</span> - i] = matrix[i][j];                <span class="hljs-comment">// temp = 7 -&gt; 1</span>                matrix[i][j] = temp;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="1044-最长重复子串"><a href="#1044-最长重复子串" class="headerlink" title="1044-最长重复子串"></a>1044-最长重复子串</h2><p>给出一个字符串 S，考虑其所有重复子串（S 的<code>连续子串</code>，出现<code>两次或多次</code>，可能会有重叠）。</p><p>返回任何具有最长可能长度的重复子串。（如果 S 不含重复子串，那么答案为 “”。）</p><p><code>HashSet</code>——超时</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestDupSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = s.length();        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;        String res = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= len; j++)&#123;                <span class="hljs-comment">//获取子串</span>                String temp = s.substring(i, j);                <span class="hljs-comment">//重复性和最大性判断</span>                <span class="hljs-keyword">if</span> (set.contains(temp) &amp;&amp; j - i &gt; maxLen)&#123;                    <span class="hljs-comment">//更新最大重复子串长度</span>                    maxLen = j - i;                    res = temp;                &#125; <span class="hljs-keyword">else</span> &#123;                    set.add(temp);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11-盛最多水的容器"></a>11-盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330085345954.png" class=""><p><code>双指针</code>——<em>只有当前首尾指针指向位置的height小于h(等于是一开始的情况)，此时移动指针才有可能使maxVolume增大</em></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = height.length;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> maxVolume = <span class="hljs-number">0</span>;        <span class="hljs-comment">//首尾指针</span>        <span class="hljs-keyword">int</span> leftPtr = <span class="hljs-number">0</span>, rightPtr = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (leftPtr &lt; rightPtr)&#123;            <span class="hljs-comment">//高度h</span>            <span class="hljs-keyword">int</span> h = Math.min(height[leftPtr], height[rightPtr]);            <span class="hljs-comment">//更新最大容量</span>            maxVolume = Math.max(maxVolume, (rightPtr - leftPtr) * h);                        <span class="hljs-comment">//若当前首尾指针指向位置的height小于h(等于是一开始的情况)，此时移动指针才有可能使maxVolume增大</span>            <span class="hljs-keyword">while</span> (height[leftPtr] &lt;= h &amp;&amp; (leftPtr &lt; rightPtr)) leftPtr++;            <span class="hljs-keyword">while</span> (height[rightPtr] &lt;= h &amp;&amp; (leftPtr &lt; rightPtr)) rightPtr--;        &#125;        <span class="hljs-keyword">return</span> maxVolume;    &#125;&#125;</code></pre><h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297-二叉树的序列化与反序列化"></a>297-二叉树的序列化与反序列化</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330091251174.png" class=""><p><code>层序遍历</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;    <span class="hljs-comment">// Encodes a tree to a single string.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;        <span class="hljs-comment">//层次遍历</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.offer(root);        <span class="hljs-keyword">while</span> (!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode node = q.poll();                <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;                    sb.append(node.val);                    q.offer(node.left);                    q.offer(node.right);                &#125; <span class="hljs-keyword">else</span> &#123;                    sb.append(<span class="hljs-string">&quot;null&quot;</span>);                &#125;                sb.append(<span class="hljs-string">&quot;,&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;]&quot;</span>).toString();    &#125;    <span class="hljs-comment">// Decodes your encoded data to tree.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;[]&quot;</span>.equals(data)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String[] splitData = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);        <span class="hljs-keyword">int</span> len = splitData.length;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(splitData[<span class="hljs-number">0</span>]));        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.offer(root);        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (!q.isEmpty() &amp;&amp; idx &lt; len)&#123;            TreeNode node = q.poll();            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;null&quot;</span>.equals(splitData[idx]))&#123;                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(splitData[idx]));                q.offer(node.left);            &#125;            idx++;            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;null&quot;</span>.equals(splitData[idx]))&#123;                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(splitData[idx]));                q.offer(node.right);            &#125;            idx++;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;<span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><span class="hljs-comment">// Codec codec = new Codec();</span><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span></code></pre><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72-编辑距离"></a>72-编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330101000806.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;        <span class="hljs-keyword">int</span> al = word1.length(), bl = word2.length();        <span class="hljs-keyword">int</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[al + <span class="hljs-number">1</span>][bl + <span class="hljs-number">1</span>];        <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= al; i++)             dp[i][<span class="hljs-number">0</span>] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= bl; j++)             dp[<span class="hljs-number">0</span>][j] = j;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= al; i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= bl; j++) &#123;                <span class="hljs-comment">// state update</span>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                &#125; <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = minHelper(dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;                <span class="hljs-keyword">return</span> dp[al][bl];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>&#123;        <span class="hljs-keyword">return</span> Math.min(a, Math.min(b, c));    &#125;&#125;</code></pre><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14-最长公共前缀"></a>14-最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p> <pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;        <span class="hljs-comment">//从字符串数组中找出最小长度的字符串</span>        <span class="hljs-keyword">for</span> (String str : strs)&#123;            minLen = Math.min(str.length(), minLen);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; minLen; i++)&#123;            <span class="hljs-keyword">for</span> (String str : strs)&#123;                <span class="hljs-comment">//和第一个比较即可</span>                <span class="hljs-keyword">if</span> (str.charAt(i) != strs[<span class="hljs-number">0</span>].charAt(i))&#123;                    <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">0</span>, i);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, minLen);    &#125;&#125;</code></pre><h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402-移掉K位数字"></a>402-移掉K位数字</h2><p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330110742505.png" class=""><p><code>单调栈</code>——两个<strong>相同位数</strong>的数字大小关系取决于第一个不同的数的大小</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num.length() == k) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        <span class="hljs-keyword">char</span>[] chars = num.toCharArray();        Deque&lt;Character&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">//遍历字符串</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars)&#123;            <span class="hljs-comment">//需要(栈顶元素比当前元素大，贪心)且能够抛弃(栈stk不空，k &gt; 0)前面的元素</span>            <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; !stk.isEmpty() &amp;&amp; c &lt; stk.peek())&#123;                stk.pop();                k--;            &#125;            stk.push(c);        &#125;        <span class="hljs-comment">//如果num中的字符本来就是递增序列，那么就不会pop元素，则从后面开始删除k位数字</span>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>)&#123;            stk.pop();            k--;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-comment">//boolean flag，首零标志</span>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//已经删除了k位数字，则此时让栈pollLast()</span>        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            <span class="hljs-comment">//拿出栈底元素</span>            <span class="hljs-keyword">char</span> digit = stk.pollLast();            <span class="hljs-comment">//跳过首零数字</span>            <span class="hljs-keyword">if</span> (flag &amp;&amp; digit == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;                <span class="hljs-keyword">continue</span>;            &#125;            flag = <span class="hljs-keyword">false</span>;            sb.append(digit);        &#125;        <span class="hljs-comment">//考虑字符串&quot;0&quot;</span>        <span class="hljs-keyword">return</span> sb.length() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span> : sb.toString();    &#125;&#125;</code></pre><p><code>如果题目改成求删除 k 个字符之后的最大数，我们只需要将 c &lt; stk.peek() 中的小于号改成大于号即可</code></p><h2 id="321-拼接最大数"><a href="#321-拼接最大数" class="headerlink" title="321-拼接最大数"></a>321-拼接最大数</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中<code>取出的数字保持其在原数组中的相对顺序</code>。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p><p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330111855102.png" class=""><p><code>单调栈 + 分治</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxNumber(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k) &#123;        <span class="hljs-keyword">int</span> len1 = nums1.length, len2 = nums2.length;        <span class="hljs-comment">//两个数组中有一个为空，则转化为一个数组的情况，此时结果不需要融合</span>        <span class="hljs-keyword">if</span>(nums1 == <span class="hljs-keyword">null</span> || (len1 == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> removeDigits(nums2, k);        <span class="hljs-keyword">if</span>(nums2 == <span class="hljs-keyword">null</span> || (len2 == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> removeDigits(nums1, k);                <span class="hljs-comment">//len2 &gt; k,</span>        <span class="hljs-keyword">int</span> i = Math.max(<span class="hljs-number">0</span>, k - len2);        <span class="hljs-keyword">int</span> maxNum = Integer.MIN_VALUE;        <span class="hljs-comment">//存储最后的结果数组</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//得到取数的组合</span>        <span class="hljs-keyword">for</span> (; i &lt;= Math.min(len1, k); i++)&#123;            <span class="hljs-comment">//分别获取两个数组的&quot;最大数&quot;子数组</span>            <span class="hljs-keyword">int</span>[] res1 = removeDigits(nums1, i);            <span class="hljs-keyword">int</span>[] res2 = removeDigits(nums2, k - i);            <span class="hljs-keyword">int</span>[] total = merge(res1, res2);                    res = res == <span class="hljs-keyword">null</span> || compare(res, <span class="hljs-number">0</span>, total, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span> ? total : res;                    &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] removeDigits(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        <span class="hljs-comment">//要从数组中移除的元素个数</span>        k = n - k;        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> nums.clone();        <span class="hljs-keyword">if</span>(k == n)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-comment">//定义单调栈(递减)</span>        Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">//遍历数组，使用单调栈(减少)从数组中移除n-k个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; stk.peek())&#123;                stk.pop();                k--;            &#125;            stk.push(nums[i]);        &#125;        <span class="hljs-comment">//如果nums中的字符本来就是递减序列，那么就不会pop元素，则从后面开始删除k位数字</span>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>)&#123;            stk.pop();            k--;        &#125;                <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            arr[cnt++] = stk.pollLast();        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">//将两个最大数组融合成一个最大数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)&#123;        <span class="hljs-keyword">int</span> m = arr1.length, n = arr2.length;        <span class="hljs-keyword">int</span>[] mergeArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + n];        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (p &lt; m &amp;&amp; q &lt; n)&#123;            mergeArr[cnt++] = compare(arr1, p, arr2, q) &gt;= <span class="hljs-number">0</span> ? arr1[p++] : arr2[q++];        &#125;        <span class="hljs-keyword">while</span> (p &lt; m)&#123;            mergeArr[cnt++] = arr1[p++];        &#125;        <span class="hljs-keyword">while</span> (q &lt; n)&#123;            mergeArr[cnt++] = arr2[q++];        &#125;        <span class="hljs-keyword">return</span> mergeArr;    &#125;        <span class="hljs-comment">// 比较 nums1[i,m)  和 nums2[j, n)</span>    <span class="hljs-comment">// nums1 != null &amp;&amp; nums2 != null</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> m = nums1.length;        <span class="hljs-keyword">int</span> n = nums2.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>, limit = Math.min(m-i, n-j); k &lt; limit; k++)&#123;            <span class="hljs-keyword">if</span>(nums1[i + k] != nums2[j + k])    <span class="hljs-keyword">return</span> Integer.compare(nums1[i + k], nums2[j + k]);        &#125;        <span class="hljs-keyword">return</span> Integer.compare(m - i, n - j);     &#125;&#125;</code></pre><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316-去除重复字母"></a>316-去除重复字母</h2><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <code>返回结果的字典序最小</code>（要求不能打乱其他字符的相对位置）。</p><p><code>单调栈 + HashSet + 计数数组</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330163459887.png" class=""><p><code>图解</code></p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210330163446598.png" class=""><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">//子序列不重复</span>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-comment">//使字典序最小</span>        Deque&lt;Character&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-comment">//需要对字符串中各个字符计数</span>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            count[s.charAt(i)]++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;            <span class="hljs-comment">//当前set中不包含c</span>            <span class="hljs-keyword">if</span> (!set.contains(c))&#123;                <span class="hljs-comment">//维护一个单调栈，贪心准则</span>                <span class="hljs-comment">//pop前需要检查后面还有没有stk.peek()，还有，就pop()，没有，就不能pop。因为需要保证每个字母出现一次</span>                <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; c &lt; stk.peek() &amp;&amp; count[stk.peek()] &gt; <span class="hljs-number">0</span>)&#123;                    set.remove(stk.pop());                &#125;                stk.push(c);                set.add(c);            &#125;            <span class="hljs-comment">//栈中包含c，把相应的计数-1即可</span>            count[c] -= <span class="hljs-number">1</span>;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            sb.insert(<span class="hljs-number">0</span>, stk.pop());        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><h2 id="1081-不同字符的最小子序列"><a href="#1081-不同字符的最小子序列" class="headerlink" title="1081-不同字符的最小子序列"></a>1081-不同字符的最小子序列</h2><p>返回 <code>s</code> 字典序最小的子序列，该子序列包含 <code>s</code> 的所有不同字符，且只包含一次。</p><p><code>同上题</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">smallestSubsequence</span><span class="hljs-params">(String s)</span> </span>&#123;        Deque&lt;Character&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;            count[c]++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;            <span class="hljs-keyword">if</span> (!set.contains(c))&#123;                <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; c &lt; stk.peek() &amp;&amp; count[stk.peek()] &gt; <span class="hljs-number">0</span>)&#123;                    set.remove(stk.pop());                &#125;                set.add(c);                stk.push(c);            &#125;            count[c] -= <span class="hljs-number">1</span>;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            sb.append(stk.pop());        &#125;                <span class="hljs-keyword">return</span> sb.reverse().toString();    &#125;&#125;</code></pre><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543-二叉树的直径"></a>543-二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是<code>任意两个结点路径长度中的最大值</code>。这条路径可能穿过也可能不穿过根结点。</p><p><code>二叉树的直径==树中任意两个节点之间的最大边数==最大的左右子树高度和</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        getHeight(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> lHeight = getHeight(node.left);        <span class="hljs-keyword">int</span> rHeight = getHeight(node.right);        res = Math.max(res, lHeight + rHeight);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(lHeight, rHeight);    &#125;&#125;</code></pre><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78-子集"></a>78-子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的<code>元素互不相同</code>。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210401101102627.png" class=""><p><code>回溯法</code>—— 按子集的不同大小（0 ~ n）分别进行回溯</p> <pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> n, k;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        n = nums.length;        <span class="hljs-comment">//子集中元素个数在0 ~ n之间</span>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n + <span class="hljs-number">1</span>; k++)&#123;            backTrack(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(ArrayList&lt;Integer&gt; cur, <span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> size)</span></span>&#123;        <span class="hljs-keyword">if</span> (cur.size() == k)&#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; n; i++)&#123;            <span class="hljs-comment">//选择当前元素</span>            cur.add(arr[i]);            <span class="hljs-comment">//继续回溯</span>            backTrack(cur, arr, i + <span class="hljs-number">1</span>);            <span class="hljs-comment">//撤销选择</span>            cur.remove(cur.size() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h2 id="90-子集Ⅱ"><a href="#90-子集Ⅱ" class="headerlink" title="90-子集Ⅱ"></a>90-子集Ⅱ</h2><p>给你一个整数数组 nums ，其中<code>可能包含重复元素</code>，请你返回该数组所有可能的子集（幂集）。</p><p><code>解集不能包含重复</code>的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><code>回溯 + 排序(剪枝)</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> n, k;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) &#123;        n = nums.length;        <span class="hljs-comment">//先排序，方便剪枝</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n + <span class="hljs-number">1</span>; k++)&#123;            backTrack(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(ArrayList&lt;Integer&gt; cur, <span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> size)</span></span>&#123;        <span class="hljs-keyword">if</span> (cur.size() == k)&#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; n; i++)&#123;            <span class="hljs-comment">//剪枝, i大于size且当前待选的元素和前一个已选的一样，此时才需要剪枝</span>            <span class="hljs-keyword">if</span> (i &gt; size &amp;&amp; arr[i] == arr[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">//做选择</span>            cur.add(arr[i]);            <span class="hljs-comment">//继续回溯</span>            backTrack(cur, arr, i + <span class="hljs-number">1</span>);            <span class="hljs-comment">//撤销选择</span>            cur.remove(cur.size() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7-整数反转"></a>7-整数反转</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p><code>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</code></p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>)&#123;            sum = sum * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//越界判断</span>        <span class="hljs-keyword">return</span> sum &gt; Integer.MAX_VALUE || sum &lt; Integer.MIN_VALUE ? <span class="hljs-number">0</span> : (<span class="hljs-keyword">int</span>)sum;    &#125;&#125;</code></pre><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322-零钱兑换"></a>322-零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p><code>动态规划</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = coins.length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        <span class="hljs-comment">//初始化</span>        Arrays.fill(dp, amount + <span class="hljs-number">1</span>);        <span class="hljs-comment">//dp[amount]代表为了凑齐总金额amount需要的硬币组合的最少个数</span>        <span class="hljs-comment">//base case</span>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins)&#123;                <span class="hljs-comment">//子问题无解，跳过</span>                <span class="hljs-keyword">if</span> (i - coin &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">//状态更新：dp[amount] = 1 + Math.min(dp[amount - coins[0]], dp[amount - coins[1],...)</span>                dp[i] = Math.min(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);            &#125;                    &#125;        <span class="hljs-comment">//判断有无解再返回，dp[amount] == amount</span>        <span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[amount];    &#125;&#125;</code></pre><p><code>dp</code>数组初始化为<code>amount + 1</code>呢，因为凑成<code>amount</code>金额的硬币数最多只可能等于<code>amount</code>（全用 1 元面值的硬币），所以初始化为<code>amount + 1</code>就<code>相当于初始化为正无穷</code>，便于后续取最小值。</p><h2 id="518-零钱兑换Ⅱ"><a href="#518-零钱兑换Ⅱ" class="headerlink" title="518-零钱兑换Ⅱ"></a>518-零钱兑换Ⅱ</h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><img src="/2021/05/03/TX%E7%AC%94%E8%AF%95/image-20210401144034823.png" class=""><p><code>完全背包</code> —— <code>dp[i][j]</code>代表若只使用前<code>i</code>个物品，当背包容量为<code>j</code>时，有<code>dp[i][j]</code>种方法可以装满背包</p><p><code>状态转移</code>—— <code>dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]</code></p><p><code>目标</code> —— <code>dp[coins.length][amount]</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = coins.length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];        <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)             dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= amount; j++)                <span class="hljs-keyword">if</span> (j - coins[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)                    <span class="hljs-comment">//将第i个物品coins[i - 1]不装背包和装背包</span>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - coins[i-<span class="hljs-number">1</span>]];                <span class="hljs-keyword">else</span>                     dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];        &#125;        <span class="hljs-keyword">return</span> dp[n][amount];    &#125;&#125;</code></pre><p><code>状态压缩</code>——<code>dp</code>数组的转移只和<code>dp[i][..]</code>和<code>dp[i-1][..]</code>有关，所以可以压缩状态</p><p><code>状态转移</code> —— <code>dp[j] = dp[j] + dp[j - coin]</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;        <span class="hljs-comment">//dp[amount]代表用coins中的硬币凑成总金额为amount的方法数</span>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        <span class="hljs-comment">//base case，装满容量为0的背包的方法，什么都不装，就是1</span>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-comment">//对于硬币数组中得硬币，我们必须使用第k个硬币的时候，当前金额的组合数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coin; j &lt;= amount; j++)&#123;                <span class="hljs-comment">//dp[amount] += dp[amount - coin]</span>                dp[j] += dp[j - coin];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手撕排序算法</title>
    <link href="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="手撕排序算法"><a href="#手撕排序算法" class="headerlink" title="手撕排序算法"></a>手撕排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度O(n*n)，空间复杂度O(n)，稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104032665.gif" class=""><pre><code class="hljs java"><span class="hljs-comment">//冒泡排序——每次把数组无序部分的最大值交换到数组最末尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-comment">//记录上一次最后完成交换的位置，因为后面的已经有序了，这样可以避免无意义的比较判断</span>    <span class="hljs-keyword">int</span> lastSwap = len;    <span class="hljs-comment">//外循环——冒泡交换的趟数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;        <span class="hljs-comment">//用于判断该趟有无元素交换，没有就说明数组已经有序了，可以break跳出循环</span>        <span class="hljs-keyword">boolean</span> hasSwap = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//暂存需要比较到的位置</span>        <span class="hljs-keyword">int</span> sortBorder = lastSwap;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; sortBorder; j++)&#123;            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[j - <span class="hljs-number">1</span>])&#123;                <span class="hljs-comment">//进行元素交换</span>                <span class="hljs-keyword">int</span> temp = nums[j];                nums[j] = nums[j - <span class="hljs-number">1</span>];                nums[j - <span class="hljs-number">1</span>] = temp;                <span class="hljs-comment">//发生交换</span>                hasSwap = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">//更新最后交换元素的位置</span>                lastSwap = j;            &#125;        &#125;        <span class="hljs-comment">//如果该趟没有发生元素交换，直接跳出循环</span>        <span class="hljs-keyword">if</span> (!hasSwap) <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>时间复杂度O(n*n)，空间复杂度O(n)，不稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104104133.gif" class=""><pre><code class="hljs java"><span class="hljs-comment">//选择排序——找出无序部分中的最小值，放到有序部分的末尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;            <span class="hljs-comment">//找当前数组无序部分的最小值的下标，将对应的数放到有序部分末尾</span>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[min])&#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">//做交换</span>        <span class="hljs-keyword">int</span> temp = nums[min];        nums[min] = nums[i];        nums[i] = temp;    &#125;&#125;</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>时间复杂度O(n*n)，空间复杂度O(1)，稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104128360.gif" class=""><pre><code class="hljs java"><span class="hljs-comment">//插入排序，将数组无序部分的元素向前插入到数组有序部分的对应位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-comment">//第一个元素无法向前插入</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        <span class="hljs-comment">//待插入元素</span>        <span class="hljs-keyword">int</span> val = nums[i];        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;            <span class="hljs-comment">//待插入元素比前一个元素小，则让前一个元素覆盖它，继续向前查找插入位置，找到就break</span>            <span class="hljs-keyword">if</span> (val &lt; nums[j])&#123;                nums[j + <span class="hljs-number">1</span>] = nums[j];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">//插入元素</span>        nums[j + <span class="hljs-number">1</span>] = val;    &#125;&#125;</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度O(n*log(n))，空间复杂度O(log(n))，不稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104243572.gif" class=""><pre><code class="hljs java"><span class="hljs-comment">//递归快排</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> border = partion(start, end, nums);    quickSort(start, border - <span class="hljs-number">1</span>, nums);    quickSort(border + <span class="hljs-number">1</span>, end, nums);&#125;<span class="hljs-comment">//快排——双边扫描，把比基准元素放到正确的位置，基准元素左边全是比它小的，右边全是比它大的</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> left = start, right = end;    <span class="hljs-comment">//选取当前分区第一个元素作为基准元素(可以有别的选取基准元素的方法)</span>    <span class="hljs-keyword">int</span> pivot = nums[start];    <span class="hljs-keyword">while</span> (left != right)&#123;        <span class="hljs-comment">//右哨兵right向左搜索第一个比pivot小的元素</span>        <span class="hljs-keyword">while</span>(nums[right] &gt;= pivot &amp;&amp; left &lt; right) right--;        <span class="hljs-comment">//左哨兵left向右搜索第一个比pivot大的元素</span>        <span class="hljs-keyword">while</span>(nums[left] &lt;= pivot &amp;&amp; left &lt; right) left++;        <span class="hljs-comment">//如果一轮搜索完毕后，left &lt; right，将nums[left]与nums[right]互换，使得小的元素在前，大的元素在后</span>        <span class="hljs-keyword">if</span> (left &lt; right)&#123;            swap(nums, left, right);        &#125;    &#125;    <span class="hljs-comment">//将基准元素放到对的位置，即此时将nums[start]和nums[left]互换</span>    nums[start] = nums[left];    nums[left] = pivot;    <span class="hljs-comment">//返回基准元素的位置，作为分区的界限</span>    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-comment">//用于数组的元素交换</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;    <span class="hljs-keyword">int</span> temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>时间复杂度O(n*log(n))，空间复杂度O(n)，稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104213505.gif" class=""><pre><code class="hljs java"><span class="hljs-comment">//分治</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">divideMerge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right)&#123;        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-comment">//递归</span>        divideMerge(nums, left, mid, temp);        divideMerge(nums, mid + <span class="hljs-number">1</span>, right, temp);        <span class="hljs-comment">//合并结果</span>        merge(nums, left, mid, right, temp);    &#125;&#125;    <span class="hljs-comment">//merge</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;    <span class="hljs-comment">//左半部分的数组指针</span>    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-comment">//右半部分的数组指针</span>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">//合并的临时数组指针</span>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;        <span class="hljs-comment">//合并过程</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)&#123;        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j])&#123;            temp[t++] = nums[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            temp[t++] = nums[j++];        &#125;    &#125;        <span class="hljs-comment">//比较合并完如果还有剩余，则将剩余的元素直接进行填充</span>    <span class="hljs-keyword">while</span> (i &lt;= mid)&#123;        temp[t++] = nums[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right)&#123;        temp[t++] = nums[j++];    &#125;        <span class="hljs-comment">//将临时数组拷贝到原始数组中，先将临时数组的指针置零</span>    t = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (left &lt;= right)&#123;        nums[left++] = temp[t++];    &#125;&#125;</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>时间复杂度O(n*log(n))，空间复杂度O(1)，不稳定排序</p><img src="/2021/05/03/%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190803104341817.gif" class=""><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-comment">//从第一个非叶子节点(0 ~ nums.length - 1编号)开始，自下而上，自右向左调整结构，使之成为最大堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;        adjustHeap(nums, i, nums.length);    &#125;    <span class="hljs-comment">//将堆顶元素和数组末尾元素进行交换，然后针对剩下的n-1个元素再次进行堆调整</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;        swap(nums, <span class="hljs-number">0</span>, j);        adjustHeap(nums, <span class="hljs-number">0</span>, j);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span></span>&#123;    <span class="hljs-comment">//暂存当前元素</span>    <span class="hljs-keyword">int</span> temp = nums[i];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; k &lt; len; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">//当前节点的左子节点的值小于右子节点</span>        <span class="hljs-keyword">if</span> (k &lt; len - <span class="hljs-number">1</span> &amp;&amp; nums[k] &lt; nums[k + <span class="hljs-number">1</span>])&#123;            k++;        &#125;        <span class="hljs-comment">//子节点比父节点大，把子节点的值赋值给父节点就行，因为已经对当前父节点进行了暂存</span>        <span class="hljs-keyword">if</span> (nums[k] &gt; temp)&#123;            nums[i] = nums[k];            i = k;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;            &#125;    <span class="hljs-comment">//把之前的父节点放到调整后的位置上</span>    nums[i] = temp;&#125;<span class="hljs-comment">//数组元素交换</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> temp = arr[a];    arr[a] = arr[b];    arr[b] = temp;&#125;</code></pre><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解堆排序</a></p><p><a href="https://blog.csdn.net/as02446418/article/details/47699547">深入浅出堆排序</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JD笔试</title>
    <link href="/2021/05/03/JD%E7%AC%94%E8%AF%95/"/>
    <url>/2021/05/03/JD%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="京东笔试"><a href="#京东笔试" class="headerlink" title="京东笔试"></a>京东笔试</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206-反转链表</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        pre.next = head;        ListNode p = head;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.next != <span class="hljs-keyword">null</span>)&#123;            ListNode temp = pre.next;            pre.next = p.next;            p.next = p.next.next;            pre.next.next = temp;        &#125;        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92-反转链表Ⅱ</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        res.next = head;        ListNode p = head, pre = res;        <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (index &lt; left)&#123;                <span class="hljs-comment">//pre和p同步移动,位置index加1</span>                pre = pre.next;                p = p.next;                index++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt;= right)&#123;                <span class="hljs-comment">//pre不用移动了，位置index也不用加了</span>                p = p.next;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//需要翻转的部分</span>                ListNode temp = pre.next;                pre.next = p.next;                p.next = p.next.next;                pre.next.next = temp;                index++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25-K个一组翻转链表</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        res.next = head;        ListNode pre = res, p = head;        <span class="hljs-comment">//统计总结点数</span>        <span class="hljs-keyword">int</span> nodeNum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>)&#123;            p = p.next;            nodeNum++;        &#125;        <span class="hljs-comment">//计算分组数</span>        <span class="hljs-keyword">int</span> groupNum = nodeNum / k;                p = head;        <span class="hljs-comment">//K个一组翻转链表</span>        <span class="hljs-keyword">while</span> (groupNum-- &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//统计翻转次数，两个一组(k == 2)进行翻转，只需要翻转一次</span>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.next != <span class="hljs-keyword">null</span> &amp;&amp; ++cnt &lt; k)&#123;                ListNode temp = pre.next;                pre.next = p.next;                p.next = p.next.next;                pre.next.next = temp;            &#125;            <span class="hljs-comment">//准备下一组翻转/剩余部分不翻转</span>            pre = p;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141-环形链表</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode fastPtr = head, slowPtr = head;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            fastPtr = fastPtr.next.next;            slowPtr = slowPtr.next;            <span class="hljs-keyword">if</span> (fastPtr == slowPtr)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142-环形链表Ⅱ</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">//快慢指针</span>        ListNode slowPtr = head, fastPtr = head;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            slowPtr = slowPtr.next;            fastPtr = fastPtr.next.next;            <span class="hljs-comment">//第一次相遇，这时候，快指针比慢指针已经多走了链表环的长度</span>            <span class="hljs-keyword">if</span> (fastPtr == slowPtr) <span class="hljs-keyword">break</span>;        &#125;<span class="hljs-comment">//无环情况</span>        <span class="hljs-keyword">if</span> (fastPtr == <span class="hljs-keyword">null</span> || fastPtr.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//慢指针从头开始，快指针模仿慢指针继续每次走一步，两方相遇点即为环的入口节点</span>        slowPtr = head;        <span class="hljs-comment">//第二次相遇即环的入口节点</span>        <span class="hljs-keyword">while</span> (slowPtr != fastPtr)&#123;            slowPtr = slowPtr.next;            fastPtr = fastPtr.next;        &#125;        <span class="hljs-keyword">return</span> slowPtr;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102-二叉树的层序遍历</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.offer(root);        <span class="hljs-keyword">while</span> (!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.poll();                temp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.offer(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.offer(cur.right);            &#125;            res.add(temp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94-二叉树的中序遍历</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        helper(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        helper(node.left);        res.add(node.val);        helper(node.right);    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指Offer 10-Ⅱ.青蛙跳台阶问题</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-comment">// int[] dp = new int[n + 1];</span>        <span class="hljs-comment">// dp[0] = 1;</span>        <span class="hljs-comment">// dp[1] = 1;</span>        <span class="hljs-comment">// for (int i = 2; i &lt;= n; i++)&#123;</span>        <span class="hljs-comment">//     dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return dp[n] % 1000000007;</span>        <span class="hljs-keyword">int</span> dp_1 = <span class="hljs-number">1</span>, dp_2 = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">int</span> temp = (dp_1 + dp_2) % <span class="hljs-number">1000000007</span>;            dp_1 = dp_2;            dp_2 = temp;        &#125;        <span class="hljs-keyword">return</span> dp_2 % <span class="hljs-number">1000000007</span>;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/combination-sum/">39-组合总和</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-keyword">null</span> || candidates.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        backTrack(candidates, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="hljs-number">0</span>, target);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, List&lt;Integer&gt; temp, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-comment">//终止条件</span>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)&#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(temp));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//从nums[index]开始进行组合，把含数nums[0 ~ index - 1]的组合全部排除，防止重复组合</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; nums.length; i++)&#123;            <span class="hljs-comment">//累积和还没达到target,才需要继续组合</span>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">//做选择</span>                temp.add(nums[i]);                <span class="hljs-comment">//回溯</span>                backTrack(nums, temp, i, k - nums[i]);                <span class="hljs-comment">//撤销选择</span>                temp.remove(temp.size() - <span class="hljs-number">1</span>);            &#125;                    &#125;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/two-sum/">1-两数之和</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (map.containsKey(nums[i]))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, map.get(nums[i])&#125;;            &#125; <span class="hljs-keyword">else</span> &#123;                map.put(target - nums[i], i);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/binary-search/">704-二分查找</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> leftPtr = <span class="hljs-number">0</span>, rightPtr = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (leftPtr &lt;= rightPtr)&#123;            <span class="hljs-keyword">int</span> mid = (leftPtr + rightPtr) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] &gt; target)&#123;                rightPtr = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;                leftPtr = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> mid;             &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指Offer 25.合并两个排序的链表</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode pre = res;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val)&#123;                pre.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.next = l2;                l2 = l2.next;            &#125;            pre = pre.next;        &#125;        pre.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23-合并K个升序链表</a></p><p><code>两两合并</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = lists.length;        ListNode res = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-comment">//两个两个合并</span>            res = mergeTwoLists(res, lists[i]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span></span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode pre = res;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val)&#123;                pre.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.next = l2;                l2 = l2.next;            &#125;            pre = pre.next;        &#125;        pre.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><p><code>分治</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span> (lists == <span class="hljs-keyword">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//分治</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> mid = (right + left) / <span class="hljs-number">2</span>;        ListNode l1 = merge(lists, left, mid);        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);    &#125;    <span class="hljs-comment">//两个两个合并</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span></span>&#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span> || l2 == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        &#125;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode pre = res;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val)&#123;                pre.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.next = l2;                l2 = l2.next;            &#125;            pre = pre.next;        &#125;        pre.next = l1 != <span class="hljs-keyword">null</span> ? l1 : l2;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指Offer 53-Ⅱ. 0 ~ n - 1中缺失的数字</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// int n = nums.length;</span>        <span class="hljs-comment">// int sum = 0;</span>        <span class="hljs-comment">// for (int num : nums)&#123;</span>        <span class="hljs-comment">//     sum += num;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return n * (n + 1) / 2 - sum;</span>         <span class="hljs-comment">//二分</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span> (nums[mid] == mid)&#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                right = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/lru-cache/">146-LRU缓存机制</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;        <span class="hljs-comment">//get操作会访问key，先删除再添加，使其在链表末尾，保持最新访问</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key))&#123;            <span class="hljs-keyword">int</span> val = map.get(key);            map.remove(key);            map.put(key, val);            <span class="hljs-keyword">return</span> val;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;        <span class="hljs-comment">//put操作也会访问key，也是先删除再添加</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (map.containsKey(key))&#123;            map.remove(key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.size() == capacity)&#123;            <span class="hljs-comment">//移除表头结点，即最近最久未使用的结点</span>            <span class="hljs-keyword">int</span> oldestKey = map.keySet().iterator().next();            map.remove(oldestKey);        &#125;        map.put(key, value);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><span class="hljs-comment"> * int param_1 = obj.get(key);</span><span class="hljs-comment"> * obj.put(key,value);</span><span class="hljs-comment"> */</span></code></pre><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指Offer 11.旋转数组的最小数字</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = numbers.length;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;                left = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[left])&#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> numbers[left];    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/multiply-strings/">43-字符串相乘</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        &#125;        <span class="hljs-keyword">int</span> n1 = num1.length(), n2 = num2.length();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1 + n2];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">int</span> a = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;                <span class="hljs-keyword">int</span> b = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;                <span class="hljs-comment">//该位累加和</span>                <span class="hljs-keyword">int</span> sum = res[i + j + <span class="hljs-number">1</span>] + (a * b);                <span class="hljs-comment">//该位的数</span>                res[i + j + <span class="hljs-number">1</span>] = sum % <span class="hljs-number">10</span>;                <span class="hljs-comment">//进位加到前一位</span>                res[i + j] += sum / <span class="hljs-number">10</span>;            &#125;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++)&#123;            <span class="hljs-comment">//如果首位是0，跳过它</span>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; res[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            sb.append(res[i]);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/jump-game/">55-跳跃游戏</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> farthest = <span class="hljs-number">0</span>;        <span class="hljs-comment">//根据上一步能到达的最远位置，更新下一步能到达的最远位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= farthest; i++)&#123;            farthest = Math.max(farthest, i + nums[i]);            <span class="hljs-comment">//能到达的最远位置比n-1大，说明能到达最后一个下标</span>            <span class="hljs-keyword">if</span> (farthest &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指Offer 09.用两个栈实现队列</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> </span>&#123;    Deque&lt;Integer&gt; stk1;    Deque&lt;Integer&gt; stk2;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span><span class="hljs-params">()</span> </span>&#123;        stk1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        stk2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        stk1.push(value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (stk2.isEmpty())&#123;            <span class="hljs-keyword">while</span> (!stk1.isEmpty())&#123;                stk2.push(stk1.pop());            &#125;        &#125;        <span class="hljs-comment">//队列为空</span>        <span class="hljs-keyword">if</span> (stk2.isEmpty())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> stk2.pop();        &#125;            &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><span class="hljs-comment"> * CQueue obj = new CQueue();</span><span class="hljs-comment"> * obj.appendTail(value);</span><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><span class="hljs-comment"> */</span></code></pre><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指Offer 22.链表中倒数第K个节点</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode fastPtr = head, slowPtr = head;        <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span>)&#123;            fastPtr = fastPtr.next;        &#125;        <span class="hljs-keyword">while</span> (fastPtr != <span class="hljs-keyword">null</span>)&#123;            fastPtr = fastPtr.next;            slowPtr = slowPtr.next;        &#125;        <span class="hljs-keyword">return</span> slowPtr;    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指Offer 58-Ⅰ.翻转单词顺序</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        String[] strs = s.trim().split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-comment">//跳过空单词</span>            <span class="hljs-keyword">if</span>(strs[i].equals(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">//最后一个不需要+空格</span>            sb.append(strs[i] + <span class="hljs-string">&quot; &quot;</span>);        &#125;        <span class="hljs-comment">//去除首尾的空格</span>        <span class="hljs-keyword">return</span> sb.toString().trim();    &#125;&#125;</code></pre><p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047-删除字符串中的所有相邻重复项</a></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(String S)</span> </span>&#123;        Deque&lt;Character&gt; stk = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : S.toCharArray())&#123;            <span class="hljs-keyword">if</span> (!stk.isEmpty() &amp;&amp; stk.peek().equals(c))&#123;                stk.pop();            &#125; <span class="hljs-keyword">else</span> &#123;                stk.push(c);            &#125;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">while</span> (!stk.isEmpty())&#123;            sb.insert(<span class="hljs-number">0</span>, stk.pop());        &#125;         <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty基础学习</title>
    <link href="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty是什么？"><a href="#Netty是什么？" class="headerlink" title="Netty是什么？"></a>Netty是什么？</h2><p><code>概述</code>——JBOSS提供的一个开源的Java网络应用框架</p><p><code>特点</code>——异步，基于事件驱动。提供了TCP/IP、HTTP协议栈，方便定制开发私有协议栈</p><p><code>本质</code>——NIO框架</p><p><code>应用</code>——开发高性能高可靠的网络IO程序，例如在分布式系统中作为RPC的基础通信组件。另外在大数据领域也被广泛应用，Akka，Flink，Spark等项目都用到了Netty</p><p><code>数据传输的基础</code>——TCP协议</p><p>下图可以帮助了解Netty在Java网络编程所处的位置</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210315141613432.png" class=""><h2 id="三种经典的I-O模型"><a href="#三种经典的I-O模型" class="headerlink" title="三种经典的I/O模型"></a>三种经典的I/O模型</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>同步并阻塞</code>，客户端每来一个连接请求，服务器就要启动一个对应的线程进行处理，高并发(同一时间出现大量请求)场景下，服务器资源消耗严重，压力很大。同时，如果连接什么也不做，服务器仍然会让线程维持，造成<code>不必要的线程开销</code>。最重要的是，这种模式下，数据的读取写入必须<code>阻塞</code>在一个线程内<code>等待</code>其完成。</p><p><code>工作机制</code>：</p><p>1）服务器启动一个ServerSocket监听连接请求</p><p>2）客户端启动Socket对服务器发起连接请求，服务端默认情况下为每个客户建立一个线程与之进行通讯</p><p>3）客户端发出请求后，咨询服务端是否有线程响应。有响应，客户端线程在请求结束后继续执行；无响应，进入等待，等待超时后连接请求被拒绝。</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210315144516566.png" class=""><p><code>改进措施</code>：使用线程池，实现并发，但并不能减少线程的使用个数。</p><p><code>应用场景</code>：连接数目比较小且固定，对服务器资源要求比较高。</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>服务端借助线程池实现，客户端用Telnet模拟</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.bio;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BioServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//利用线程池实现BIO的server端</span>        <span class="hljs-comment">//创建一个线程池，通过七大参数</span>        ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">5</span>,                <span class="hljs-number">10</span>,                <span class="hljs-number">3</span>,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">5</span>),                Executors.defaultThreadFactory(),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()        );        <span class="hljs-comment">//1.创建ServerSocket</span>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">//监听，等待客户端连接</span>            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);            <span class="hljs-comment">//2.创建一个线程与之通讯</span>            threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    <span class="hljs-comment">//线程和客户端通信的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;线程id : &quot;</span> + Thread.currentThread().getId());        InputStream is = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//接收数据的缓冲区</span>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-comment">//通过socket获取输入流</span>            is = socket.getInputStream();            <span class="hljs-comment">//3.循环读取客户端发送的数据</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                System.out.println(<span class="hljs-string">&quot;线程id : &quot;</span> + Thread.currentThread().getId());                <span class="hljs-keyword">int</span> read = is.read(bytes);                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>)&#123;                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//读完break</span>                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放资源</span>            <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    is.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (socket != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    socket.close();                    System.out.println(<span class="hljs-string">&quot;关闭与客户端的连接&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>同步非阻塞</code>，客户端发送的请求会注册到多路复用器(选择器)上，<code>多路复用器轮询</code>到连接有I/O请求才进行处理。对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p><p><code>特点</code>：支持面向缓冲的，基于通道的 I/O 操作方法。</p><p><code>应用场景</code>：连接数目多且连接时间比较短，适用于聊天服务器，弹幕系统，服务器通信等场景。</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210315165226877.png" class=""><h4 id="三大核心"><a href="#三大核心" class="headerlink" title="三大核心"></a>三大核心</h4><h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><code>Channel</code></h5><ul><li><p>每个Channel都会对应一个Buffer</p></li><li><p>Channel是<code>双向</code>的，可以返回底层操作系统的情况</p></li><li>Channel的切换是基于事件驱动的</li></ul><p><code>FileChannel + ByteBuffer</code>——将字符串写入文本文件案例</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210315195058080.png" class=""><p>NioFileChannelDemo01.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioFileChannelDemo01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String str = <span class="hljs-string">&quot;hello, caoyusang&quot;</span>;        FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file1.txt&quot;</span>);        <span class="hljs-comment">//通过输出流获取对应的Channel，输出流把Channel包裹起来了</span>        FileChannel channel = os.getChannel();        <span class="hljs-comment">//为Channel创建一个对应的缓冲区</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-comment">//str放入缓冲区</span>        byteBuffer.put(str.getBytes());        <span class="hljs-comment">//对缓冲区进行flip，即position置0</span>        byteBuffer.flip();        <span class="hljs-comment">//将缓冲区数据写入到Channel</span>        channel.write(byteBuffer);        <span class="hljs-comment">//输出流关闭</span>        os.close();    &#125;&#125;</code></pre><p><code>FileChannel + ByteBuffer</code>——从文本文件读取文本，打印到控制台</p><p>NioFileChannelDemo02.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioFileChannelDemo02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//创建文件的输入流</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file1.txt&quot;</span>);        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);        <span class="hljs-comment">//通过输入流获取通道</span>        FileChannel channel = is.getChannel();        <span class="hljs-comment">//创建合适大小的缓冲区——根据文件大小</span>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>) file.length());        <span class="hljs-comment">//将Channel中的数据读到bytebuffer</span>        channel.read(byteBuffer);        <span class="hljs-comment">//将字节转成字符串，array方法return hb;</span>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));    &#125;&#125;</code></pre><p><code>FileChannel+一个ByteBuffer</code>实现文件的拷贝（需要读写）</p><p>NioFileChannelDemo03.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioFileChannelDemo03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//获取被拷贝的文件的输入流</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file1.txt&quot;</span>);        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);        <span class="hljs-comment">//获取输入流对应的channel</span>        FileChannel isChannel = is.getChannel();        <span class="hljs-comment">//获取输出流</span>        FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file2.txt&quot;</span>);        <span class="hljs-comment">//获取输出流对应的channel</span>        FileChannel osChannel = os.getChannel();        <span class="hljs-comment">//构建512大小的缓冲区</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);        <span class="hljs-comment">//循环读取，防止读不完</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">//清空buffer，复位操作，防止position==limit出现read一直为0的情况</span>            <span class="hljs-comment">/*</span><span class="hljs-comment">            public Buffer clear() &#123;</span><span class="hljs-comment">                position = 0;</span><span class="hljs-comment">                limit = capacity;</span><span class="hljs-comment">                mark = -1;</span><span class="hljs-comment">                return this;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">            */</span>            byteBuffer.clear();            <span class="hljs-keyword">int</span> read = isChannel.read(byteBuffer);            <span class="hljs-comment">//读到末尾</span>            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//读的同时，写，注意要先读写反转</span>            byteBuffer.flip();            osChannel.write(byteBuffer);        &#125;        <span class="hljs-comment">//关闭输入流和输出流</span>        is.close();        os.close();    &#125;&#125;</code></pre><p><code>FileChannel.transferFrom()</code>实现文件的拷贝</p><p>NioFileChannelDemo04.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioFileChannelDemo04</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//获取被拷贝的文件的输入流</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file1.txt&quot;</span>);        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);        <span class="hljs-comment">//获取输入流对应的channel</span>        FileChannel isChannel = is.getChannel();        <span class="hljs-comment">//获取输出流</span>        FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file3.txt&quot;</span>);        <span class="hljs-comment">//获取输出流对应的channel</span>        FileChannel osChannel = os.getChannel();        <span class="hljs-comment">//使用transferFrom(src, begin, end)实现通道内数据的拷贝</span>        osChannel.transferFrom(isChannel, <span class="hljs-number">0</span> , isChannel.size());        <span class="hljs-comment">//流的关闭</span>        is.close();        os.close();    &#125;&#125;</code></pre><h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><code>Buffer</code></h5><ul><li><code>内存块</code>，可读可写，底层是一个<code>数组</code></li><li>普通buffer可以转换成<code>只读buffer</code></li></ul><p>顶层父类Buffer抽象类的参数</p><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>; <span class="hljs-comment">//下一个要被读或者写的数组元素的索引，每次读写完后都会更新</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-comment">//缓存区的当前终点，不能对缓冲区超过极限的位置进行读写操作，可修改</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">//缓冲区的容量，不可改变</span></code></pre><p>Buffer的一个子类<code>ByteBuffer</code></p><p>真正存放数据的是hb数组</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210315172258183.png" class=""><p>基本的buffer使用</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.nio.IntBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建buffer</span>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);        <span class="hljs-comment">//put向buffer中放数据</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;            intBuffer.put(i * <span class="hljs-number">2</span>);        &#125;        <span class="hljs-comment">//从buffer中取数据</span>        <span class="hljs-comment">//先将buffer转换，进行读写切换</span>        intBuffer.flip();        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining())&#123;            System.out.println(intBuffer.get());        &#125;    &#125;&#125;</code></pre><p><code>MappedByteBuffer</code>类——允许文件直接在内存中修改，操作系统不需要再拷贝一次</p><p>MappedByteBufferTest.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.nio;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.RandomAccessFile;<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//创建一个随机访问的文件流，读写模式</span>        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;d:\\file1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);        <span class="hljs-comment">//获取通道</span>        FileChannel channel = randomAccessFile.getChannel();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 参数1： 读写模式</span><span class="hljs-comment">         * 参数2：可以直接修改的起始位置</span><span class="hljs-comment">         * 参数3： 映射到内存的大小，即可以修改的字节数</span><span class="hljs-comment">         */</span>        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);        randomAccessFile.close();    &#125;&#125;</code></pre><h6 id="Buffer分散与聚集"><a href="#Buffer分散与聚集" class="headerlink" title="Buffer分散与聚集"></a>Buffer分散与聚集</h6><p><code>分散</code>：将数据写入buffer时，可以采用buffer数组，依次写入</p><p><code>聚集</code>：从buffer读取数据时，可以采用buffer，依次读</p><h5 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a><code>Selector</code></h5><ul><li>一个Selector对应一个线程，同时可以对应多个不同的Channel</li><li>能够检测多个注册的通道上是否有事件发生，有则获取事件并针对其进行处理</li><li>Selector可以在各个通道上进行切换，即<code>单线程多路复用</code></li></ul><h4 id="NIO-vs-BIO"><a href="#NIO-vs-BIO" class="headerlink" title="NIO vs BIO"></a><code>NIO vs BIO</code></h4><p>1）BIO以流的方式处理数据，NIO以块的方式处理数据，块IO的效率要高很多。</p><p>2）BIO是阻塞的即数据的读写必须阻塞在一个线程内完成，NIO是非阻塞的，面向缓冲区。</p><p>3）BIO基于字节流和字符流进行操作，NIP基于管道和缓冲区进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入通道，单个Selector线程负责轮询监听多个管道中的事件。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p><code>异步非阻塞</code>，基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO尚未得到广泛应用。</p><p><code>应用场景</code>：连接数目多且连接时间较长。</p><h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><h3 id="NIO存在的一些问题"><a href="#NIO存在的一些问题" class="headerlink" title="NIO存在的一些问题"></a>NIO存在的一些问题</h3><ul><li>NIO的类库和API繁杂，使用麻烦，需要熟练掌握Select、ServerSocketChannel、SocketChannel、ByteBuffer等</li><li>NIO编程涉及Reactor模式，必须对多线程和网络编程相当熟悉</li><li>开发工作量和难度比较大，客户端面临断连重连、网络闪断、半包读写、失败缓存和网络拥塞等问题</li><li>JDK NIO的Epoll bug，会导致Selector空轮询，最终导致CPU100%直到JDK1.7还未解决</li></ul><h3 id="Netty的优点"><a href="#Netty的优点" class="headerlink" title="Netty的优点"></a>Netty的优点</h3><ul><li>对JDK自带的NIO的API进行了封装，解决了上述传统原生NIO网络编程出现的问题</li><li>设计优雅、使用方便、安全、社区活跃、高性能、吞吐更高、延迟更低，减少了资源消耗和不必要的内存复制</li></ul><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a><code>Reactor模式</code></h4><h5 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a><code>单Reactor单线程</code></h5><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210502101356806.png" class=""><p><code>说明</code></p><p>（1）select是I/O复用的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求</p><p>（2）Reactor通过select监控客户端的请求事件，收到事件后通过dispatch进行请求的分发处理</p><p>（3）如果是建立连接事件，则由Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</p><p>（4）如果不是建立连接事件，则Reactor会分发调用连接对应的Handler响应不同类型的请求</p><p>（5）最后由Handler完成read  —&gt; 业务处理 —&gt; send的完整流程</p><p><code>模式的优缺点</code></p><p>（1）优点：模型简单，没有多线程、进程通信、竞争的问题</p><p>（2）缺点：只有一个线程，无法完全发挥多核CPU的性能。因为Reactor和Handler在同一个线程中，即请求监听和请求处理在同一个线程中完成，并发高的情况下，Handler在处理某个业务时，整个线程无法处理其他请求事件。</p><h5 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a><code>单Reactor多线程</code></h5><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210502104022933.png" class=""><p><code>说明</code></p><p>（1）Reactor通过select监控客户端的请求事件，收到事件后通过dispatch进行请求的分发处理</p><p>（2）如果是建立连接事件，则由Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</p><p>（3）如果不是建立连接事件，则Reactor会分发调用连接对应的Handler响应不同类型的请求，该模式下handler只负责事件响应，而不做任何的业务处理，只做read和send，而具体的业务处理交付给worker线程池的某个线程</p><p>（4）worker线程池会分配独立线程完成真正的业务，并把结果返回给handler</p><p><code>模式的优缺点</code></p><p>（1）优点：可以充分利用多核CPU的处理能力</p><p>（2）缺点：多线程数据共享和访问较为复杂；reactor还是负责所有事件的监听和响应，即连接的监听和响应仍然是在单线程中运行，高并发场景下容易出现性能瓶颈。</p><h5 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a><code>主从Reactor多线程</code></h5><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210502110433664.png" class=""><p><code>说明</code></p><p>（1）Reactor主线程MainReactor通过select监控客户端的请求事件，收到事件后通过Acceptor处理连接事件</p><p>（2）当Acceptor处理连接事件后，MainReactor将连接分配给下一级的SubReactor</p><p>（3）SubReactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</p><p>（4）当有新的事件发生时，SubReactor就会调用对应的handler进行处理</p><p>（5）handler通过read读取数据，将业务处理移交worker线程池</p><p>（6）worker线程池分配独立的一个线程进行业务处理，返回结果给对应的handler</p><p>（7）handler收到响应结果后，通过send将结果返回给client</p><p><code>模式优缺点</code></p><p>（1）优点：父线程和子线程数据交互简单职责明确，父线程只需要接受连接请求，子线程完成后续的I/O及业务处理</p><p>（2）编程复杂度较高</p><h5 id="Netty线程模式"><a href="#Netty线程模式" class="headerlink" title="Netty线程模式"></a><code>Netty线程模式</code></h5><p><code>网络图</code></p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/5249993-a67abc1374958c5d.png" class=""><p><code>我自己画的</code></p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210503094734623.png" class=""><p><code>说明</code></p><p>（1）Netty抽象出两组线程池，Boss Group专门负责接收客户端的连接请求，Worker Group专门负责网络的读写</p><p>（2）Boss Group和worker Group的类型都是NioEventLoopGroup，相当于一个事件循环组，组中有多个事件循环，每个事件循环都是一个NioEventLoop</p><p>（3）NioEventLoop表示一个不断循环执行的处理任务的线程，NioEventLoop通过Selector监听绑定在其上的socket的网络通讯</p><p>（4）每个Boss Group中的NioEventLoop循环执行的过程分为三步：</p><p>​        1）轮询accept事件，及连接请求事件</p><p>​        2）处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NioEventLoop中的Selector上</p><p>​        3）处理任务队列中的任务，即runAllTasks</p><p>（5）每个Woker Group中的NioEventLoop的执行逻辑是：</p><p>​        1）轮询处理读写(R/W)事件</p><p>​        2）处理I/O事件，在对应的NioSocketChannel中处理</p><p>​        3）处理任务队列的任务</p><p>（6）每个Worker Group的NioEventLoop处理具体的业务时，会使用管道Pipeline，可以通过Pipeline获取对应的Channel的处理器ChannelHandler，从而进行真正的业务处理</p><h2 id="Netty实战"><a href="#Netty实战" class="headerlink" title="Netty实战"></a>Netty实战</h2><h3 id="Netty实现简单的TCP通信"><a href="#Netty实现简单的TCP通信" class="headerlink" title="Netty实现简单的TCP通信"></a>Netty实现简单的TCP通信</h3><p><code>NettyTcpServer.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyTcpServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建BossGroup(只处理连接请求)和WorkerGroup(处理真正的业务)</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建服务端的启动对象</span>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            <span class="hljs-comment">//进行参数设置</span>            bootstrap.group(bossGroup, workerGroup)     <span class="hljs-comment">//设置两个线程组</span>                    .channel(NioServerSocketChannel.class)      <span class="hljs-comment">//使用NioServerSocketChannel作为服务器的通道实现</span>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)      <span class="hljs-comment">//标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度</span>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)      <span class="hljs-comment">//启用心跳保活机制</span>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyTcpServerHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;服务器准备好了&quot;</span>);            <span class="hljs-comment">//绑定端口并同步</span>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">7777</span>).sync();            <span class="hljs-comment">//对关闭通道进行监听</span>            cf.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p><code>NettyTcpServerHandler.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.netty;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-comment">//HandlerAdapter是Netty提供的适配器，规范</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyTcpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx : 上下文对象，含有pipeline， Channel等</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg : 客户端传来的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;server ctx: &quot;</span> + ctx);        <span class="hljs-comment">//打印msg看看，先将msg转化成netty提供的ByteBuf</span>        ByteBuf buf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;客户端发送消息是：&quot;</span> + buf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;客户端的地址：&quot;</span> + ctx.channel().remoteAddress());    &#125;    <span class="hljs-comment">//数据读取完毕</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">//异常处理</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p><code>NettyTcpClient.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyTcpClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//创建group</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建启动类</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-comment">//参数设置</span>            bootstrap.group(group)                    .channel(NioSocketChannel.class)                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyTcpClientHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;客户端就绪&quot;</span>);            <span class="hljs-comment">//连接服务器并同步</span>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7777</span>).sync();            <span class="hljs-comment">//关闭通道监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p><code>NettyTcpClientHandler.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.netty;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyTcpClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//客户端就绪就会触发</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;client ctx: &quot;</span> + ctx);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 服务器&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;服务其消息: &quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;服务器地址: &quot;</span> + ctx.channel().remoteAddress());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p><code>服务端</code></p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210318102229436.png" class=""><p><code>客户端</code></p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210318102238524.png" class=""><h3 id="Netty实现基本的RPC框架"><a href="#Netty实现基本的RPC框架" class="headerlink" title="Netty实现基本的RPC框架"></a>Netty实现基本的RPC框架</h3><h4 id="RPC概述"><a href="#RPC概述" class="headerlink" title="RPC概述"></a>RPC概述</h4><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/37345851.jpg" class=""><p>RPC（Remote Procedure Call）—<code>远程过程调用</code>，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了<code>让计算机调用远程服务就像调用本地服务</code>一样快。</p><p><code>RPC的执行流程</code>：</p><ol><li>服务消费方（client）调用<code>以本地调用方式</code>调用服务；</li><li>client stub接收到调用后负责将<code>方法、参数</code>等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将<code>消息发送</code>到服务端；</li><li>server stub收到消息后进行<code>解码</code>；</li><li>server stub根据解码结果<code>调用本地的服务</code>；</li><li>本地服务执行并将<code>结果返回</code>给server stub；</li><li>server stub将返回<code>结果打包成消息并发送</code>至消费方；</li><li>client stub接收到消息，并进行<code>解码</code>；</li><li>服务消费方得到<code>最终结果</code>。</li></ol><h4 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h4><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210318104129844.png" class=""><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210503112605108.png" class=""><h5 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h5><p><code>服务接口HelloService.java</code> —— 定义了服务提供者提供服务的规范</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String msg)</span></span>;&#125;</code></pre><p><code>服务实现类HelloServiceImpl.java</code> —— 服务的具体实现（业务，返回服务调用结果）</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.provider;<span class="hljs-keyword">import</span> com.youzikeji.rpc.service.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;收到客户端消息：&quot;</span> + msg);        <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;客户端您好，已收到您的消息[&quot;</span> + msg + <span class="hljs-string">&quot;]&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;客户端您好，已收到您的消息&quot;</span>;        &#125;    &#125;&#125;</code></pre><p><code>服务端</code></p><ul><li><p>ServerBootstrap.java —— 服务端启动类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.provider;<span class="hljs-keyword">import</span> com.youzikeji.rpc.server.NettyServer;<span class="hljs-comment">//ServerBootStrap会启动一个服务提供者，即NettyServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);    &#125;&#125;</code></pre></li><li><p>NettyServerHandler.java —— 具体的业务处理器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.server;<span class="hljs-keyword">import</span> com.youzikeji.rpc.provider.HelloServiceImpl;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取客户端发送的消息，并根据约定好的的协议调用服务，这里简单地规定消息必须以某个字符串作为开头</span>        <span class="hljs-keyword">if</span> (msg.toString().startsWith(<span class="hljs-string">&quot;HelloService#hello#&quot;</span>))&#123;            String result = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));            ctx.writeAndFlush(result);        &#125;    &#125;&#125;</code></pre></li><li><p>NettyServer.java —— Netty构建服务端</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.server;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;    <span class="hljs-comment">//对外暴露方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span></span>&#123;        startServer0(hostname, port);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动服务</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hostname 主机名</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port 端口号</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-comment">//Boss线程池和Worker线程池</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建启动类</span>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ChannelPipeline pipeline = socketChannel.pipeline();                            pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                            pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                            pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler());     <span class="hljs-comment">//业务处理器</span>                        &#125;                    &#125;);            <span class="hljs-comment">//绑定并同步监听主机端口，然后做异步处理</span>            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务...&quot;</span>);            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></li></ul><p><code>客户端</code></p><ul><li><p>ClientBootstrap.java —— 客户端启动类，通过构建远程服务代理对象实现服务调用</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.customer;<span class="hljs-keyword">import</span> com.youzikeji.rpc.client.NettyClient;<span class="hljs-keyword">import</span> com.youzikeji.rpc.service.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>&#123;    <span class="hljs-comment">//定义协议头</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String head = <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建消费者</span>        NettyClient cus = <span class="hljs-keyword">new</span> NettyClient();        <span class="hljs-comment">//创建代理对象</span>        HelloService service = (HelloService) cus.getBean(HelloService.class, head);        <span class="hljs-comment">//通过代理对象调用服务提供者的方法</span>        String res = service.hello(<span class="hljs-string">&quot;您好, RPC&quot;</span>);        System.out.println(<span class="hljs-string">&quot;调用的结果：&quot;</span> + res);    &#125;&#125;</code></pre></li><li><p>NettyClientHandler.java —— 将调用服务的参数等信息发送给服务器，等待服务代理对象返回调用结果</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.client;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext context;    <span class="hljs-keyword">private</span> String result;  <span class="hljs-comment">//返回的结果</span>    <span class="hljs-keyword">private</span> String param;   <span class="hljs-comment">//客户端调用方法时传入的参数</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 被代理对象调用，发送数据给服务器，等待被唤醒，然后返回结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        context.writeAndFlush(param);        <span class="hljs-comment">//等待channelRead获取服务器返回的结果后，唤醒</span>        wait();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 与服务器连接创建后就被调用</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        context = ctx;  <span class="hljs-comment">//其他方法中会使用到ctx</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 收到服务器的数据后，调用方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        result = msg.toString();        <span class="hljs-comment">//唤醒等待的线程</span>        notify();    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParam</span><span class="hljs-params">(String param)</span></span>&#123;        <span class="hljs-keyword">this</span>.param = param;    &#125;&#125;</code></pre></li><li><p>NettyClient.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rpc.client;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;    <span class="hljs-comment">//创建线程池</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(            <span class="hljs-number">3</span>,            Runtime.getRuntime().availableProcessors(),            <span class="hljs-number">3</span>,            TimeUnit.SECONDS,            <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">5</span>),            Executors.defaultThreadFactory(),            <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()    );    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;    <span class="hljs-comment">//代理模式，获取代理对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serviceClass, <span class="hljs-keyword">final</span> String head)</span> </span>&#123;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;, ((proxy, method, args) -&gt; &#123;                    <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) &#123;                        initClient();                    &#125;                    <span class="hljs-comment">//设置要发给服务端的信息</span>                    client.setParam(head + args[<span class="hljs-number">0</span>]);                    <span class="hljs-keyword">return</span> executor.submit(client).get();                &#125;));    &#125;    <span class="hljs-comment">//初始化客户端</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span> </span>&#123;        client = <span class="hljs-keyword">new</span> NettyClientHandler();        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioSocketChannel.class)                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)                .handler(                        <span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ChannelPipeline pipeline = socketChannel.pipeline();                                pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                                pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                                pipeline.addLast(client);                            &#125;                        &#125;                );        <span class="hljs-keyword">try</span> &#123;            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></li></ul><p><code>结果</code></p><p>先后运行ServerBootstrap.java和ClientBootstrap.java</p><p>服务端结果如下图：</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210503150355519.png" class=""><p>客户端结果如下：</p><img src="/2021/05/03/Netty%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210503150404678.png" class="">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发锁</title>
    <link href="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/"/>
    <url>/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Java并发锁整理"><a href="#Java并发锁整理" class="headerlink" title="Java并发锁整理"></a>Java并发锁整理</h2><h3 id="各种锁的概念"><a href="#各种锁的概念" class="headerlink" title="各种锁的概念"></a>各种锁的概念</h3><h4 id="显示锁-vs-内置锁-隐式锁"><a href="#显示锁-vs-内置锁-隐式锁" class="headerlink" title="显示锁 vs 内置锁(隐式锁)"></a><code>显示锁 vs 内置锁(隐式锁)</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">显示锁(JDK1.5之后才有)</th><th style="text-align:center">内置锁(隐式锁)</th></tr></thead><tbody><tr><td style="text-align:center">锁的控制对象</td><td style="text-align:center">锁的申请和释放都可以由程序所控制</td><td style="text-align:center">锁的申请和释放都是由 JVM 所控制</td></tr><tr><td style="text-align:center">实现</td><td style="text-align:center">ReentrantLock、ReentrantReadWriteLock</td><td style="text-align:center">synchronized</td></tr><tr><td style="text-align:center">优化趋势</td><td style="text-align:center">无</td><td style="text-align:center">JDK1.6之后对synchronized做了大量优化，性能已经与显示锁基本持平</td></tr><tr><td style="text-align:center">优缺点</td><td style="text-align:center">使用不当可能造成死锁</td><td style="text-align:center">synchronized是 JVM 内置属性，能执行一些优化</td></tr><tr><td style="text-align:center">能否响应中断</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">超时机制</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">支持公平锁</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">支持共享</td><td style="text-align:center">√(ReentrantReadWriteLock读锁)</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">支持读写分离</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr></tbody></table></div><h4 id="悲观锁-vs-乐观锁"><a href="#悲观锁-vs-乐观锁" class="headerlink" title="悲观锁 vs 乐观锁"></a><code>悲观锁 vs 乐观锁</code></h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">悲观锁</th><th style="text-align:center">乐观锁</th></tr></thead><tbody><tr><td style="text-align:center">思想</td><td style="text-align:center">总是假设并发操作一定会发生冲突，所以每次进行并发操作都加上锁</td><td style="text-align:center">乐观地认为不会发生冲突，只在需要操作值的时候检查值有没有发生变化，没变化才去更新</td></tr><tr><td style="text-align:center">实现</td><td style="text-align:center">synchronized、Lock</td><td style="text-align:center">CAS + (使用版本号解决ABA问题)</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:center">适合写操作频繁而读操作少的场景</td><td style="text-align:center">适合读操作频繁而写操作少的场景</td></tr></tbody></table></div><h4 id="公平锁-vs-非公平锁"><a href="#公平锁-vs-非公平锁" class="headerlink" title="公平锁 vs 非公平锁"></a>公平锁 vs 非公平锁</h4><p>ReentrantLock中的内部NoFairSync对应非公平锁</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/image-20210424102546193.png" class=""><p>ReentrantLock中的内部类FairSync对应公平锁</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/image-20210424102614020.png" class=""><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">公平锁</th><th style="text-align:center">非公平锁</th></tr></thead><tbody><tr><td style="text-align:center">思想</td><td style="text-align:center">多线程按照申请锁的顺序来获取锁</td><td style="text-align:center">多线程不按照申请锁的顺序来获取锁</td></tr><tr><td style="text-align:center">实现</td><td style="text-align:center">ReentrantLock、ReentrantReadWriteLock(也支持公平锁)</td><td style="text-align:center">synchronized、ReentrantLock、ReentrantReadWriteLock(默认非公平锁)</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁</td><td style="text-align:center">饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）</td></tr></tbody></table></div><h4 id="独占锁-vs-共享锁"><a href="#独占锁-vs-共享锁" class="headerlink" title="独占锁 vs 共享锁"></a>独占锁 vs 共享锁</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">独享锁</th><th style="text-align:center">共享锁</th></tr></thead><tbody><tr><td style="text-align:center">思想</td><td style="text-align:center">锁一次只能被一个线程持有</td><td style="text-align:center">锁可被多个线程所持有</td></tr><tr><td style="text-align:center">实现</td><td style="text-align:center">synchronized、ReentrantLock、ReentrantReadWriteLock写锁</td><td style="text-align:center">ReentrantReadWriteLock读锁</td></tr><tr><td style="text-align:center">实际用途</td><td style="text-align:center">互斥</td><td style="text-align:center">读读共享</td></tr></tbody></table></div><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a><code>可重入锁</code></h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>可重入锁又名递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。</p><h5 id="典型的可重入锁"><a href="#典型的可重入锁" class="headerlink" title="典型的可重入锁"></a>典型的可重入锁</h5><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>synchronized</li></ul><h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><p>在一定程度上避免死锁的发生。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    Thread.sleep(<span class="hljs-number">1000</span>);    setB();&#125;<span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    Thread.sleep(<span class="hljs-number">1000</span>);&#125;</code></pre><p>如果使用的锁不是可重入锁的话，<code>setB</code> 可能不会被当前线程执行，从而造成死锁。</p><h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。</p><p>JDK1.7之前的ConcurrentHashMap就是分段锁的典型案例。</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/image-20210319152048905.png" class=""><p><code>ConcurrentHashMap</code> 维护了一个 <code>Segment</code> 数组，一般称为分段桶。</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</code></pre><p>当有线程访问 <code>ConcurrentHashMap</code> 的数据时，<code>ConcurrentHashMap</code> 会先根据 hashCode 计算出数据在哪个桶（即哪个 Segment），然后锁住这个 <code>Segment</code>。</p><p><code>JDK1.8之后</code>，取消了 Segment 分段锁，采⽤ CAS 和 synchronized 来保证并发安全，数据结构跟 HashMap1.8 的结构类似。</p><h4 id="轻量级锁-重量级锁-偏向锁"><a href="#轻量级锁-重量级锁-偏向锁" class="headerlink" title="轻量级锁/重量级锁/偏向锁"></a><code>轻量级锁/重量级锁/偏向锁</code></h4><h5 id="轻量级锁-vs-重量级锁"><a href="#轻量级锁-vs-重量级锁" class="headerlink" title="轻量级锁 vs 重量级锁"></a>轻量级锁 vs 重量级锁</h5><p>这里锁的量级指的是锁控制粒度的粗细，控制粒度越细，锁越轻量，并发时阻塞造成的开销就越小，并发度也就越高。</p><div class="table-container"><table><thead><tr><th style="text-align:center">JDK 1.6之前</th><th style="text-align:center">轻量级锁</th><th style="text-align:center">重量级锁</th></tr></thead><tbody><tr><td style="text-align:center">实现</td><td style="text-align:center">volatile</td><td style="text-align:center">synchronized</td></tr></tbody></table></div><p>JDK1.6之后，针对synchronized做了大量的优化，引入了4种锁的状态：</p><ul><li>无锁状态</li><li>偏向锁 —— 指一段同步代码<code>一直被一个线程所访问</code>，那么该线程会自动获取锁。降低获取锁的代价。</li><li>轻量级锁 —— 当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过<code>自旋</code>的形式尝试获取锁，<code>不会阻塞</code>，提高性能。</li><li>重量级锁 —— 当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，<code>当自旋一定次数的时候，还没有获取到锁，就会进入阻塞</code>，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><p><code>锁可以单向地从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁。</code></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围"></a>锁的范围</h4><ul><li>在修饰静态方法时，锁的是类对象，如 Object.class。</li><li>修饰非静态方法时，锁的是对象，即 this。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>synchronized <code>锁住的是对象而非代码</code>，只要访问的是同一个对象的synchronized 方法，即使是不同的代码，也会被同步顺序访问。</li><li>多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的。</li><li>在保护变量时，需要在所有访问该变量的方法上加上synchronized。</li></ul><h4 id="字节码实现"><a href="#字节码实现" class="headerlink" title="字节码实现"></a>字节码实现</h4><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        &#125;    &#125;&#125;</code></pre><p><code>synchronized</code>关键字基于monitorenter指令和monitorexit指令实现了锁的获取和释放过程：</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/170bcd25d18f76ec.png" class=""><p>当执行monitorenter指令时，当前线程将试图获取objectref(即对象锁) 所对应的monitor 的持有权，当objectref 的 monitor 的进入计数器为0，那线程可以成功取得monitor，并将计数器值设置为1，取锁成功。如果当前线程已经拥有 objectref 的monitor 的持有权，那它可以重入这个monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放monitor(锁)并设置计数器值为0，其他线程将有机会持有monitor 。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>在 JVM 字节码层面并没有任何特别的指令来实现被synchronized 修饰的方法，而是在 Class 文件的方法表中将该方法的access_flags 字段中的synchronized 标志位置设置为1， 表示该方法是同步方法，并使用调用该方法的对象或该方法所属的Class。</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>锁消除 —— Java虚拟机在JIT即时编译时， 通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁， 通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。</li><li>锁粗化 —— 将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>自旋锁 —— 线程的阻塞和唤醒，需要 CPU 从用户态转为核心态。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。 同时，我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间。为了这一段很短的时间，频繁地阻塞和唤醒线程是非常不值得的。自旋锁的核心思想就是：当后面请求锁的线程没拿到锁的时候，不挂起线程，而是继续占用处理器的执行时间，让当前线程执行一个<code>忙循环</code>（自旋操作（默认10次）），也就是不断在盯着持有锁的线程是否已经释放锁。</li><li>自适应自旋锁 —— 所谓的“自适应”意味着对于同一个锁对象，线程的自旋时间是根据上一个持有该锁的线程的自旋时间以及状态来确定的。</li><li>锁升级 —— 锁可以单向地从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>CAS(compare and swap)，即比较并交换。CAS是一种操作机制，不是某个具体的类或方法。在 Java 平台上对这种操作进行了包装。操作方法在Unsafe 类中：</p><pre><code class="hljs java"><span class="hljs-meta">@ForceInline</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">int</span> expected,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">return</span> theInternalUnsafe.compareAndSetInt(o, offset, expected, x);&#125;</code></pre><p>它需要三个参数，分别是内存位置offset，旧的预期值x和新的值expected。操作时，先从内存位置读取到值，然后和预期值x比较。如果相等，则将此内存位置的值改为新值expected，返回 true。如果不相等，说明和其他线程冲突了，则不做任何改变，返回 false。</p><p>这种机制在不阻塞其他线程的情况下避免了并发冲突，比独占锁的性能高很多。 CAS 在 Java 的原子类和并发包中有大量使用。</p><h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>CAS 本身并未实现失败后的处理机制，它只负责返回成功或失败的布尔值，后续由调用者自行处理。</p><p>在CAS操作失败后，我们最常用的方法就是使用一个<code>死循环进行 CAS 操作</code>，成功了就结束循环返回，<code>失败了就重新从内存读取值和计算新值</code>，再调用 CAS。</p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>CAS主要分为三步：</p><ul><li><code>读取</code> —— 从内存位置读到值。</li><li><code>比较</code> —— 检测值是否与期待值一致，不一致，则CAS失败；一致，则可以去修改，但仍然无法保证修改后结果正确，因为在多线程环境下，可能其他的线程在此时也在修改。</li><li><code>修改</code> —— 更新变量的值。</li></ul><p>要保证CAS的正确性，则需要保证<code>比较-修改</code>这两步操作的<code>原子性</code>。</p><p>CAS 底层是靠调用 CPU 指令集的 cmpxchg 完成的，它是 x86 和 Intel 架构中的 compare and exchange 指令。在多核的情况下，这个指令也不能保证原子性，需要在前面加上lock 指令。lock 指令可以保证一个 CPU 核心在操作期间<code>独占一片内存区域</code>。在处理器中，一般使用<code>缓存锁</code>实现CAS比较和交换的原子性的。</p><p><strong>值得注意的是， CAS 只是保证了操作的原子性，并不保证变量的可见性，因此变量需要加上 volatile 关键字。</strong></p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>多线程情况下，读和写发生在不同的线程中，而读线程未能及时的读到写线程写入的最新的值。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>被volatile修饰的共享变量，就具有了以下两点特性：</p><ul><li>保证了多线程环境下不同线程对该共享变量操作的内存可见性</li><li>禁止指令重排序</li></ul><h5 id="线程之间为何不可见？"><a href="#线程之间为何不可见？" class="headerlink" title="线程之间为何不可见？"></a>线程之间为何不可见？</h5><h6 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h6><p><code>从硬件角度来看</code></p><p>计算机内存模型如下图所示</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/20210222213448988.JPG" class=""><p>其中，CPU 拥有最顶层的 4 层缓存结构（内置 3 层），高速缓存（Cache）来作为内存与处理器之间的缓冲，而主内存和硬盘是外部的存储介质。</p><p>由于CPU、内存和IO设备三者在处理速度上差异很大，最终整体的计算效率还是取决于最慢的那个设备。为了平衡三者之间的速度差异，最大化的利用CPU提升性能。无论是硬件方面，操作系统还是编译器方面都做了很多的优化：</p><ul><li>CPU增加了高速缓存（高速缓存作为内存和处理器之间的缓冲，通过将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存中同步到内存之中，这样就能平衡内存和处理器之间的处理速度差异）</li><li>操作系统灵活高效的调度策略最大化提升CPU性能</li><li>编译器进行指令优化，更加合理地去利用好CPU的高速缓存</li></ul><p><code>缓存一致性的问题</code></p><p>CPU高速缓存的引入虽然很好的解决了处理器与内存之间的速度矛盾，但同时也引入了一个新的问题，缓存一致性。</p><p>有了高速缓存后，每个CPU处理过程变成这样：</p><ul><li>将计算机需要用到的数据缓存在CPU高速缓存中</li><li>在CPU进行计算时，直接从高速缓存中读取数据并且计算完成之后写到缓存中</li><li>在整个运算完成后，再把缓存中的数据同步到内存</li></ul><p>在<code>多CPU中</code>，每个线程可能会运行在不同的CPU中，并且每个线程都有自己的高速缓存，<code>同一份数据可能会被缓存到多个CPU中</code>，如果在不同CPU中运行的不同线程看到同一份内存的缓存值不一样，就会存在缓存不一致的问题。</p><p><code>怎么解决缓存一致性问题？</code></p><p>使用总线锁和缓存锁。</p><p><code>总线锁</code></p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/16dab7e22afe4348.png" class=""><p><code>缓存锁</code></p><p>总线锁开销较大，所以需要优化，最好的方法就是控制锁的粒度，我们只需要保证，对于被多个CPU缓存的同一份数据是一致的就行，所以引入了缓存锁，它的<code>核心机制就是缓存一致性协议</code>。</p><p><code>缓存一致性协议</code></p><p>为了达成数据访问的一致性，需要各个处理器在访问内存时，遵循一些协议，在读写时根据协议来操作，常见的协议有，MSI，MESI，MOSI等等，最常见的就是MESI协议；</p><p>具体的缓存一致性怎么实现的，请参考<a href="https://juejin.cn/post/6844903959107207175">一文吃透Volatile，征服面试官</a></p><p>使用总线锁和缓存锁后，CPU对于内存的操作大概可以抽象成下面这样的结构，从而达成缓存一致性效果。</p><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/image-20210424141325923.png" class=""><p>如上图模型所示，计算机将需要的数据从主内存拷贝至高速缓存，之后将运算后的结果回写到主内存。<code>这个执行计算的过程中，各个非公有变量的变化，各线程间都是不可见的</code>，这就会导致线程不安全。</p><h6 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h6><img src="/2021/05/03/JUC%E5%B9%B6%E5%8F%91%E9%94%81/image-20210424141917606.png" class=""><p>JMM(Java内存模型)是一个抽象的概念，并不是真实的存在，它涵盖了缓冲区，寄存器以及其他硬件和编译器优化。在JMM中，</p><ul><li><p>所有的<code>实例变量和类变量都存储于主内存</code>。（其不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。）</p></li><li><p>线程对变量的所有的<code>读写操作都在工作内存中完成</code>，而不能直接读写主内存中的变量。</p></li></ul><p>实际上JMM存在和计算机内存模型一样的问题，即实际上线程可见性还是没有得到解决。</p><h6 id="如何解决可见性的问题"><a href="#如何解决可见性的问题" class="headerlink" title="如何解决可见性的问题"></a>如何解决可见性的问题</h6><p>两种方式：</p><ul><li>加悲观锁synchronized —— 保证了线程间变量的原子性和可见性，但是并发性差</li><li>用volatile修饰变量使得共享变量在线程之间可见 —— 不能保证原子性，即是线程不安全的</li></ul><h6 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h6><p>即对用volatile关键字修饰的变量进行计算操作时，内存中要实现的功能或遵循的规则：</p><ul><li><strong>写</strong>一个volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存</li><li><strong>读</strong>一个volatile 变量时，JMM 会把该线程对应的本地内存置为无效，并从主内存中读取共享变量</li></ul><h6 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h6><p>为了优化性能，编译器会根据一些特定的规则，在as-if-serial（不管怎么重排序，单线程下的执行结果不能被改变）规则的前提下，进行重新排序。</p><p>要实现volatile的内存语义，要第一时间写 volatile 变量时，将更新的变量更新到主存；在线程读 volatile 变量时，要第一时间读到主存的变量。因此必须要禁止指令重排。</p><h5 id="为什么volatile不能保证原子性"><a href="#为什么volatile不能保证原子性" class="headerlink" title="为什么volatile不能保证原子性"></a>为什么volatile不能保证原子性</h5><p>以++操作为例，当有了变量++操作时，会有以下三个步骤在一个线程中产生：</p><ul><li>从主存中取值到工作内存</li><li>计算工作内存的值</li><li>将计算得到的新值更新到主内存</li></ul><p>对应的CPU指令如下：</p><pre><code class="hljs text">mov    0xc(%r10),%r8d ; Loadinc    %r8d           ; Incrementmov    %r8d,0xc(%r10) ; Storelock addl $0x0,(%rsp) ; StoreLoad Barrier</code></pre><p>如果现在有两个线程执行同一个 volatile 变量的 ++ 操作，可能出现的情况：</p><ul><li>线程1读取变量到工作内存后，由于没有锁，所以线程2在线程1拷贝后，抢到了CPU，立刻也将主存的变量拷贝至工作内存。</li><li>之后，线程1与线程2先后在工作内存进行了自增。</li><li>最后，线程1、2分别将自增后的值刷回主存。线程2回写时，会覆盖掉线程1回写的值，导致线程不安全，所以 <code>volatile 计算不能保证原子性。</code></li></ul><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS 保证了比较和交换的原子性。但是从读取到开始比较这段期间，其他核心仍然是可以修改这个值的。如果核心将 A 修改为 B，CAS 可以判断出来。但是如果核心将 A 修改为 B 再修改回 A。那么 CAS 会认为这个值并没有被改变，从而继续操作。这是和实际情况不符的。解决方案是加一个<code>版本号version</code>，相当于增加一个时间戳，来区分不同时间线上的同值变量。</p><h4 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a>volatile应用</h4><h5 id="单例模式的双重检查"><a href="#单例模式的双重检查" class="headerlink" title="单例模式的双重检查"></a>单例模式的双重检查</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton =<span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-keyword">null</span>)&#123;                    singleton =<span class="hljs-keyword">new</span> Singleton();                    &#125;            &#125;        &#125;    <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ReentrantLock 使用代码实现了和synchronized 一样的语义，包括可重入，保证内存可见性和解决竞态条件问题等。相比 synchronized，它还有如下好处：</p><ul><li>支持以非阻塞方式获取锁</li><li>可以响应中断</li><li>可以限时</li><li>支持了公平锁和非公平锁</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><p><strong><code>ReentrantLock</code></strong> <strong>提供了与</strong> <strong><code>synchronized</code></strong> <strong>相同的互斥性、内存可见性和可重入性</strong>。</p></li><li><p><code>ReentrantLock</code> 支持公平锁和非公平锁（默认）两种模式。</p></li><li><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的<strong>灵活性</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//无条件获取锁</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//尝试获取锁</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//释放锁</span>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//返回一个绑定到Lock对象上的Condition实例</span>&#125;</code></pre><ul><li><code>synchronized</code> 无法中断一个正在等待获取锁的线程</li><li><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</li></ul></li></ul><h4 id="lock-and-unLock"><a href="#lock-and-unLock" class="headerlink" title="lock() and unLock()"></a>lock() and unLock()</h4><ul><li><code>lock()</code>—— <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。</li><li><code>unlock()</code> —— 用于<strong>释放锁</strong>。</li></ul><p><code>使用注意</code>：获取锁操作 <strong><code>lock()</code></strong> <strong>必须在</strong> <strong><code>try catch</code></strong> <strong>块中进行，并且将释放锁操作</strong> <strong><code>unlock()</code></strong> <strong>放在</strong> <strong><code>finally</code></strong> <strong>块中进行，以保证锁一定被被释放，防止死锁的发生</strong>。</p><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h4><p>与无条件获取锁相比，tryLock 有更完善的容错机制。</p><ul><li><code>tryLock()</code> —— <strong>可轮询获取锁</strong>。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法<strong>无论成败都会立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</li><li><code>tryLock(long, TimeUnit)</code> —— <strong>可定时获取锁</strong>。和 <code>tryLock()</code> 类似，区别仅在于这个方法在<strong>获取不到锁时会等待一定的时间</strong>，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。</li></ul><h4 id="案例-——-单Lock对象采用多Condition实现精确唤醒"><a href="#案例-——-单Lock对象采用多Condition实现精确唤醒" class="headerlink" title="案例 —— 单Lock对象采用多Condition实现精确唤醒"></a>案例 —— 单Lock对象采用多Condition实现精确唤醒</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.juc;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-comment">//单Lock对象采用多Condition精确通知唤醒</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCDemo03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Data3 data3 = <span class="hljs-keyword">new</span> Data3();        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) data3.printA();&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) data3.printB();&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) data3.printC();&#125;, <span class="hljs-string">&quot;C&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data3</span></span>&#123;    <span class="hljs-comment">//资源，先给到printA</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;    <span class="hljs-comment">//Lock</span>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Condition condition3 = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//业务</span>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>)&#123;                condition1.await();            &#125;            <span class="hljs-comment">//执行</span>            System.out.println(<span class="hljs-string">&quot;AAAAAA&quot;</span>);            <span class="hljs-comment">//通知唤醒B</span>            number = <span class="hljs-number">2</span>;            condition2.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//解锁</span>            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">2</span>)&#123;                condition2.await();            &#125;            System.out.println(<span class="hljs-string">&quot;BBBBBB&quot;</span>);            <span class="hljs-comment">//唤醒C</span>            number = <span class="hljs-number">3</span>;            condition3.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printC</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">3</span>)&#123;                condition3.await();            &#125;            System.out.println(<span class="hljs-string">&quot;CCCCCC&quot;</span>);            <span class="hljs-comment">//唤醒A</span>            number = <span class="hljs-number">1</span>;            condition1.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引详解</title>
    <link href="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><p>一种帮助MySQL提高查询效率的数据结构。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>大大加快数据的查询速度</p><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><p>创建索引是为产生索引文件的，<code>占用磁盘空间</code>。索引文件是一个二叉树类型的文件，可想而知我们的DML操作，对表记录的<code>增、删、改</code>操作同样也会对索引文件进行修改，所以<code>性能会相应的有所下降</code>。</p><h2 id="索引的分类-INNODB"><a href="#索引的分类-INNODB" class="headerlink" title="索引的分类(INNODB)"></a>索引的分类(INNODB)</h2><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/image-20210406104516865.png" class=""><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>将表属性设定为<code>主键</code>后，数据库会自动为主键创建<code>聚簇索引</code>。</p><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><p>一个索引<code>只包含单个列</code>，一个表中可以有多个单值索引，这种索引又称单列索引或者<code>普通索引</code>。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列的值必须唯一，但<code>允许有空值null(和主键不同，主键不允许为空)</code>，但只能有一个（因为唯一）。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>一个索引包含多个列。</p><p>ps：MySQL5.7之前，MyISAM引擎可以提供<code>全文索引</code>，即在定义索引的列上支持值得全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型列上创建。全文索引只有MyISAM存储引擎支持。</p><h2 id="索引的基本操作"><a href="#索引的基本操作" class="headerlink" title="索引的基本操作"></a>索引的基本操作</h2><p>创建一个用于测试索引的数据库<code>test_index</code></p><h3 id="主键索引——自动创建"><a href="#主键索引——自动创建" class="headerlink" title="主键索引——自动创建"></a>主键索引——自动创建</h3><pre><code class="hljs sql"><span class="hljs-comment">-- 切换数据库</span><span class="hljs-keyword">use</span> test_index;<span class="hljs-comment">-- 创建表t_user</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_user(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) primary <span class="hljs-keyword">key</span> , <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>));<span class="hljs-comment">-- 展示表索引</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> t_user;</code></pre><p><code>表索引展示</code></p><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/image-20210406092618871.png" class=""><h3 id="单值索引——手动创建"><a href="#单值索引——手动创建" class="headerlink" title="单值索引——手动创建"></a>单值索引——手动创建</h3><h4 id="建表时创建"><a href="#建表时创建" class="headerlink" title="建表时创建"></a>建表时创建</h4><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表t_user时同时创建索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_user_common(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) primary <span class="hljs-keyword">key</span> , <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>), <span class="hljs-keyword">key</span>(<span class="hljs-keyword">name</span>));</code></pre><p><code>索引展示</code></p><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/image-20210406093634715.png" class=""><h4 id="建表后创建"><a href="#建表后创建" class="headerlink" title="建表后创建"></a>建表后创建</h4><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> name_index <span class="hljs-keyword">on</span> t_user(<span class="hljs-keyword">name</span>);</code></pre><h3 id="唯一索引——手动创建"><a href="#唯一索引——手动创建" class="headerlink" title="唯一索引——手动创建"></a>唯一索引——手动创建</h3><h4 id="建表时创建-1"><a href="#建表时创建-1" class="headerlink" title="建表时创建"></a>建表时创建</h4><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表t_user时使用unique创建唯一索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_user(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) primary <span class="hljs-keyword">key</span> , <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>), <span class="hljs-keyword">unique</span>(<span class="hljs-keyword">name</span>));</code></pre><h4 id="建表后创建-1"><a href="#建表后创建-1" class="headerlink" title="建表后创建"></a>建表后创建</h4><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> name_index <span class="hljs-keyword">on</span> t_user(<span class="hljs-keyword">name</span>);</code></pre><h3 id="复合索引——手动创建"><a href="#复合索引——手动创建" class="headerlink" title="复合索引——手动创建"></a>复合索引——手动创建</h3><h4 id="建表时创建-2"><a href="#建表时创建-2" class="headerlink" title="建表时创建"></a>建表时创建</h4><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表t_user时使用key()创建复合索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_user(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) primary <span class="hljs-keyword">key</span> , <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>), age <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>), <span class="hljs-keyword">key</span>(<span class="hljs-keyword">name</span>, age));</code></pre><h4 id="建表后创建-2"><a href="#建表后创建-2" class="headerlink" title="建表后创建"></a>建表后创建</h4><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> name_age_index <span class="hljs-keyword">on</span> t_user(<span class="hljs-keyword">name</span>, age);</code></pre><p>查询时原则上需要遵从<code>最左匹配原则</code>，才能利用复合索引，另外MySQL的引擎为了更好地利用复合索引，再查询过程中会动态调整查询字段的顺序以便利用索引。</p><pre><code class="hljs markdown">name age √age name √age ×name √</code></pre><h2 id="索引的底层原理"><a href="#索引的底层原理" class="headerlink" title="索引的底层原理"></a>索引的底层原理</h2><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p>B树是一种多叉平衡查找树，其主要特点：</p><p>（1）B树的节点中<code>存储着多个元素</code>，每个内节点有多个分叉。</p><p>（2）节点中的元素包含键值和数据，节点中的<code>键值从小到大排列</code>。也就是说，在<code>所有的节点都储存数据</code>。</p><p>（3）父节点当中的元素不会出现在子节点中。</p><p>（4）所有的<code>叶子结点都位于同一层</code>，叶节点具有相同的深度，<code>叶节点之间没有指针连接</code>。</p><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/BTree.png" class=""><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+树是B树的升级版，它们最主要的区别在于非叶子节点是否存储数据的问题。</p><p>B+树在结构上和B树的<code>区别</code>在于：</p><ul><li><code>只有叶子节点才会存储数据</code>，非叶子节点至存储键值</li><li>叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个<code>双向有序链表</code>。</li></ul><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/B+Tree.png" class=""><p><code>INNODB中的B+Tree的特点</code>:</p><p>（1）它是BTree 的变种，BTree能解决的问题，它都能解决。</p><p>（2）扫库、扫表能力更强(进行全表扫描时，只需要遍历叶子节点就可以了)</p><p>（3）B+Tree的磁盘读写能力相对于BTree来说更强(根节点和分支节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多)</p><p>（4）排序能力更强(因为叶子节点上有下一个数据区的指针，数据形成了链表)</p><p>（5）效率更加稳定(B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的)</p><h3 id="建立索引过程"><a href="#建立索引过程" class="headerlink" title="建立索引过程"></a>建立索引过程</h3><ul><li>往数据表中插入数据时，数据库引擎会对插入的元素进行<code>排序</code>，以链表的形式把节点(索引，数据，指针)串起来。</li><li><code>分页处理</code>，INNODB引擎默认分页大小为<code>16KB</code>，在最底层的页中存放所有的数据，在其他层则存放的是分页索引和链接指针。</li><li>索引有两种实现的数据结构，<code>B树和B+树</code><ul><li>B+树的非叶节点只存储键值信息</li><li>B+树所有叶子节点之间都有一个链接指针</li><li>B+树把所有数据记录方法叶子节点中</li></ul></li><li>数据库中，B+树的高度一般都在2~4层。由于MySQL的INNODB引擎在设计时是将B+树的<code>根节点常驻内存</code>的，因此在查找某一键值的行记录时，<code>最多只需要1~3次磁盘IO</code>。</li></ul><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>MySQL中最常见的两种存储引擎分别是<code>MyISAM和INNODB</code>，分别实现了非聚簇索引和聚簇索引。</p><p>在索引的分类中，我们可以按照索引的键是否为主键来分为“主键索引”和“辅助索引”，使用主键键值建立的索引称为“主键索引”，其它的称为“辅助索引”。因此<code>主键索引只能有一个，辅助索引可以有很多个</code>。</p><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/image-20210406140901401.png" class=""><h3 id="INNODB-——-聚簇索引"><a href="#INNODB-——-聚簇索引" class="headerlink" title="INNODB —— 聚簇索引"></a>INNODB —— 聚簇索引</h3><p>聚簇索引——索引和数据放在一起，找到了索引就找到了数据。</p><h4 id="聚簇索引的使用过程"><a href="#聚簇索引的使用过程" class="headerlink" title="聚簇索引的使用过程"></a>聚簇索引的使用过程</h4><p>INNODB使用的是聚簇索引，将主键组织到一棵B+树中 ，而行数据就存储在叶子节点上，通过”where id = 14”这样的条件查找主键时，则按照B+树的检索算法即可找到对应的叶子节点，并获取其行数据。</p><p>特别地，若对其中的任意一列例如Name列进行条件搜索，则需要进行两个步骤：</p><ul><li>第一步，在辅助索引B+树中检索Name，到达叶子节点后获取其主键</li><li>第二步，根据第一步获取到的主键在主索引B+树中再执行一次B+树检索操作，最终到达对应的叶子节点即可获取整行数据</li></ul><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/innodb-index.png" class=""><p><code>聚簇索引默认为主键</code>，特别地，若表中没有定义主键，则INNODB会<code>选择一个唯一且非空的索引代替</code>，若没有这样的索引，则会<code>隐式地定义一个主键</code>（类似oracle中的RowId）来作为聚簇索引。</p><h4 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h4><ul><li>由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样<code>主键和行数据是一起被载入内存</code>的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</li><li>辅助索引使用主键作为”指针”而不是使用地址值作为指针，这样做的好处是，<code>减少了当出现行移动或者数据页分裂时辅助索引的维护工作</code>，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</li><li>聚簇索引<code>适合用在排序</code>的场合，非聚簇索引不适合</li><li>取出一定<code>范围数据</code>的时候，使用聚簇索引</li><li>二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据</li><li>可以把<code>相关数据保存在一起</code>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li></ul><h4 id="聚簇索引的劣势"><a href="#聚簇索引的劣势" class="headerlink" title="聚簇索引的劣势"></a>聚簇索引的劣势</h4><ul><li><code>维护索引代价高</code>，特别是插入新行或者主键被更新导至要分页的时候</li><li>表因为使用UUId（随机ID）作为主键，使<code>数据存储稀疏</code>，这就会出现聚簇索引有可能有比全表扫描更慢</li><li>如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；<code>过长的主键值，会导致非叶子节点占用占用更多的物理空间</code></li></ul><h3 id="MyISAM——非聚簇索引"><a href="#MyISAM——非聚簇索引" class="headerlink" title="MyISAM——非聚簇索引"></a>MyISAM——非聚簇索引</h3><p>非聚簇索引的数据表和索引表是分开存储的。</p><p>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</p><img src="/2021/04/06/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/myisam-index.png" class=""><h2 id="参考资料及部分图源"><a href="#参考资料及部分图源" class="headerlink" title="参考资料及部分图源"></a>参考资料及部分图源</h2><p><a href="https://juejin.cn/post/6936032090546765837">全面分析由浅入深解析Mysql索引底层原理</a></p><p><a href="https://www.jianshu.com/p/fa8192853184">聚簇索引与非聚簇索引（也叫二级索引）</a></p><p><a href="https://www.bilibili.com/video/BV19y4y127h4">这一次彻底搞定MySQL索引、从此不再恐惧面试</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="/2021/04/06/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/04/06/ThreadLocal%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 主要用来提供线程局部变量，将参数储存在线程中，然后在该线程运行的任何阶段都能从线程中获取。多线程环境下，每个线程都可以通过<code>set()</code>和<code>get()</code>来对本线程局部变量进行操作，不会和其他线程的局部变量发生冲突，<strong>实现了线程间的数据隔离</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><img src="/2021/04/06/ThreadLocal%E8%AF%A6%E8%A7%A3/image-20210324150915632.png" class=""><ul><li><p>每一个Thread对象都包含一个ThreadLocalMap类型的<code>成员变量threadLocals</code>，它存储了本线程中所有的ThreadLocal对象及其对应的值，即一个ThreadLocalMap对象。</p><pre><code class="hljs java"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><span class="hljs-comment">* by the ThreadLocal class. */</span>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span></code></pre></li><li><p>ThreadLocalMap由一个个的Entry对象构成，Entry继承自weakReference<ThreadLocal<?>&gt;，一个Entry由ThreadLocal对象以及线程局部变量Object组成，其中ThreadLocal作为key，对应的线程变量Object作为value。</p><img src="/2021/04/06/ThreadLocal%E8%AF%A6%E8%A7%A3/20180920212201150.png" class=""><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><span class="hljs-comment">         * its main ref field as the key (which is always a</span><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;                <span class="hljs-keyword">super</span>(k);                value = v;            &#125;        &#125;        <span class="hljs-comment">//....很长</span>&#125;</code></pre></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>ThreadLocal提供<code>set()</code>方法和<code>get()</code>方法操作线程局部变量。</p><p>每一个线程的ThreadLocalMap容器各自私有，这些容器相互独立互不影响，不会存在线程安全性的问题。</p><ul><li><p>set()</p><ul><li>ThreadLocal获取当前线程对象</li><li>获取当前线程的ThreadLocalMap对象</li><li>以当前的ThreadLocal为key，将线程局部变量值存进ThreadLocalMap对象中</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-comment">// 得到当前线程对象</span>    Thread t = Thread.currentThread();    <span class="hljs-comment">// 这里获取ThreadLocalMap</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 如果map存在，则将当前的ThreadLocal对象作为key，要存储的对象作为value存到map里面去</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)&#123;        map.set(<span class="hljs-keyword">this</span>, value);    &#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//map不存在，调用createMap()方法为当前的线程创建一个ThreadLocalMap</span>        createMap(t, value);    &#125;&#125;</code></pre></li><li><p>createMap() —— 创建并初始化线程的ThreadLocalMap</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre></li><li><p>get()</p><ul><li>ThreadLocal获取当前线程对象</li><li>获取当前线程的ThreadLocalMap对象</li><li>以当前的ThreadLocal为key，获取对应的value</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            T result = (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>进行对象跨层传递时，使用ThreadLocal避免参数/对象的多次传递，打破层次间的约束</li><li>线程间数据隔离</li><li>解决Spring中单例Bean的线程安全问题</li><li>进行事务操作，用于存储线程的事务信息<ul><li>spring声明式事务的重要实现基础就是ThreadLocal</li></ul></li><li><code>数据库连接管理</code>、Session会话管理</li></ul><p><code>数据库连接管理</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBUtil</span> </span>&#123;    <span class="hljs-comment">//数据库连接池</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BasicDataSource source;    <span class="hljs-comment">//为不同的线程管理连接</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; local;    <span class="hljs-keyword">static</span> &#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;        <span class="hljs-comment">//获取Connection对象</span>        Connection connection = source.getConnection();        <span class="hljs-comment">//把Connection放进ThreadLocal里面</span>        local.set(connection);        <span class="hljs-comment">//返回Connection对象</span>        <span class="hljs-keyword">return</span> connection;    &#125;    <span class="hljs-comment">//关闭数据库连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//从线程中拿到Connection对象</span>        Connection connection = local.get();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//恢复连接为自动提交</span>                connection.setAutoCommit(<span class="hljs-keyword">true</span>);                <span class="hljs-comment">//这里不是真的把连接关了,只是将该连接归还给连接池</span>                connection.close();                <span class="hljs-comment">//既然连接已经归还给连接池了,ThreadLocal保存的Connction对象也已经没用了</span>                local.remove();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>不会再被使用的对象或者变量占用的内存不能被回收，就说明发生了内存泄漏。随着内存泄漏次数的累积，无论计算机有多少内存，迟早被耗光，会出抛出OOM(OutOfMemoryError)异常，程序异常终止。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">回收时间</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">强引用</td><td style="text-align:center">一直存活，除非GC Roots不可达</td><td style="text-align:center">所有程序的场景，基本对象，自定义对象等</td></tr><tr><td style="text-align:center">软引用</td><td style="text-align:center">内存不足时会被回收</td><td style="text-align:center">一般用在对内存非常敏感的资源上，用作缓存的场景比较多</td></tr><tr><td style="text-align:center">弱引用</td><td style="text-align:center">只能存活到下一次GC前</td><td style="text-align:center">生命周期很短的对象，例如ThreadLocal中的Key。</td></tr><tr><td style="text-align:center">虚引用</td><td style="text-align:center">随时会被回收</td><td style="text-align:center">可能被JVM团队内部用来跟踪JVM的垃圾回收活动</td></tr></tbody></table></div><p>ThreadLocalMap使用ThreadLocal的弱引用作为key时，如果一个ThreadLocal不存在外部强引用了，那么这个作为key的ThreadLocal必然在下一次GC中被回收。<code>当key成为null后</code>，下一次ThreadLocalMap调用set()、get()、remove()方法时，会清除value的值。</p><p><code>ThreadLocal内存泄漏的根源</code>：</p><p>ThreadLocalMap的<code>生命周期</code>跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p><code>ThreadLocal的正确使用方法</code>：</p><ul><li>每次使用完ThreadLocal后，手动remove()。</li><li>将ThreadLocal变量设置为private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</li></ul><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484118&amp;idx=1&amp;sn=da3e4c4cfd0642687c5d7bcef543fe5b&amp;chksm=ebd743d7dca0cac19a82c7b29b5b22c4b902e9e53bd785d066b625b4272af2a6598a0cc0f38e&amp;scene=21#wechat_redirect">ThreadLocal就是这么简单 by Java3y</a></p><p><a href="https://blog.csdn.net/zzg1229059735/article/details/82715741">ThreadLocal理解及应用 by pony-zi</a></p><h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h3><p><a href="https://www.bilibili.com/video/BV1Eb4y1R7zd?p=25">ThreadLocal的原理以及使用场景</a></p><p><a href="https://www.bilibili.com/video/BV1Eb4y1R7zd?p=26">ThreadLocal内存泄漏问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper入门学习</title>
    <link href="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Apache-ZooKeeper"><a href="#Apache-ZooKeeper" class="headerlink" title="Apache ZooKeeper"></a>Apache ZooKeeper</h1><h2 id="ZK简介"><a href="#ZK简介" class="headerlink" title="ZK简介"></a>ZK简介</h2><p>一个分布式的，开源的分布式应用程序协调服务，是Google的分布式锁服务Chubby的一个开源实现，是Hadoop和Hbase的重要组件。ZK由Java编写，但是支持Java和C两种编程语言。</p><ul><li>在Dubbo、SpringCloud中，担任<code>服务注册中心</code>的角色</li><li>在Hadoop、Hbase等大数据的组件中，担任<code>集群管理</code>者的角色</li><li>在Redis分布式开发中，担任<code>实现分布式锁</code>的角色。</li></ul><h2 id="ZK数据模型"><a href="#ZK数据模型" class="headerlink" title="ZK数据模型"></a>ZK数据模型</h2><h3 id="ZK模型结构"><a href="#ZK模型结构" class="headerlink" title="ZK模型结构"></a>ZK模型结构</h3><p>模型结构为树状结构，类似Linux文件目录结构</p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405093910510.png" class=""><ul><li>每个子目录如/app1都被成为一个<code>znode节点</code>，每个znode节点<code>被其所在的路径唯一标识</code></li><li>znode节点可以有子节点目录，并且每个znode<code>可以存储数据</code></li><li>znode中存储的<code>数据是有版本</code>的，每次对节点数据的修改都会导致版本号的增加；同时每个znode节点可以存储数据的多个版本，即一个访问路径中可以存储多份数据</li><li>znode节点<code>可以被监控</code>，包括这个目录节点中存储数据的修改、子节点目录的变化等，一旦变化可以通知设置监控的客户端</li></ul><h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><p>根据ZK模型结构中的znode节点的<code>生命周期</code>和<code>额外的节点特性</code>(父节点为其第一级子节点维护一份时序)，可以将节点划分成四类：持久节点、持久顺序节点、临时节点、临时顺序节点。</p><h4 id="持久节点-P"><a href="#持久节点-P" class="headerlink" title="持久节点(P)"></a>持久节点(P)</h4><p>在节点创建后，就会存盘并一直存在，直到被要求删除，值得注意的是，它不会因为创建该节点的客户端会话的失效而被删除。</p><h4 id="持久顺序节点-PS"><a href="#持久顺序节点-PS" class="headerlink" title="持久顺序节点(PS)"></a>持久顺序节点(PS)</h4><p>在生命周期等基本特性上和持久节点相同。额外的特性是，在ZK中，每个父节点会为其第一级子节点维护一份时序，即记录每个子节点创建的先后顺序。基于这一特性，在创建子节点时，可以设置该属性，这样在创建节点的过程中，ZK会自动地为给定地节点名增加一个数字后缀(范围是1~整型的最大值)作为新的节点名，例如节点/app1/p_1这样的节点就是持久顺序节点。</p><h4 id="临时节点-E"><a href="#临时节点-E" class="headerlink" title="临时节点(E)"></a>临时节点(E)</h4><p>与持久节点截然相反，临时节点的生命周期和客户端会话绑定，即如果客户端会话失效(会话失效!=会话连接断开)，那么绑定的临时节点将自动被清除。除此之外，临时节点下不能创建子节点。</p><h4 id="临时顺序节点-ES"><a href="#临时顺序节点-ES" class="headerlink" title="临时顺序节点(ES)"></a>临时顺序节点(ES)</h4><p>具有临时节点的特点，额外特性和持久顺序节点的额外特性相同。</p><h2 id="ZK安装"><a href="#ZK安装" class="headerlink" title="ZK安装"></a>ZK安装</h2><h3 id="Linux系统中安装ZK"><a href="#Linux系统中安装ZK" class="headerlink" title="Linux系统中安装ZK"></a>Linux系统中安装ZK</h3><p><a href="https://www.cnblogs.com/expiator/p/9853378.html">linux安装zookeeper及使用</a></p><h3 id="Docker安装ZK"><a href="#Docker安装ZK" class="headerlink" title="Docker安装ZK"></a>Docker安装ZK</h3><h4 id="拉取ZK镜像"><a href="#拉取ZK镜像" class="headerlink" title="拉取ZK镜像"></a>拉取ZK镜像</h4><pre><code class="hljs powershell">docker pull zookeeper:<span class="hljs-number">3.4</span>.<span class="hljs-number">14</span></code></pre><h4 id="启动ZK容器"><a href="#启动ZK容器" class="headerlink" title="启动ZK容器"></a>启动ZK容器</h4><pre><code class="hljs powershell">docker run -<span class="hljs-literal">-name</span> zk <span class="hljs-literal">-p</span> <span class="hljs-number">2181</span>:<span class="hljs-number">2181</span> <span class="hljs-literal">-d</span> zookeeper:<span class="hljs-number">3.4</span>.<span class="hljs-number">14</span></code></pre><h4 id="查看容器zk的启动日志"><a href="#查看容器zk的启动日志" class="headerlink" title="查看容器zk的启动日志"></a>查看容器zk的启动日志</h4><pre><code class="hljs po">docker logs zk</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405102306772.png" class=""><p>成功绑定宿主机的2181端口。</p><h4 id="进入zk容器-交互式方式"><a href="#进入zk容器-交互式方式" class="headerlink" title="进入zk容器(交互式方式)"></a>进入zk容器(交互式方式)</h4><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> zk bash</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405102559629.png" class=""><h4 id="连接容器内的ZK服务"><a href="#连接容器内的ZK服务" class="headerlink" title="连接容器内的ZK服务"></a>连接容器内的ZK服务</h4><pre><code class="hljs powershell">./bin/zkCli.sh</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405102934185.png" class=""><h2 id="ZK配置文件详解"><a href="#ZK配置文件详解" class="headerlink" title="ZK配置文件详解"></a>ZK配置文件详解</h2><pre><code class="hljs cfg">#tickTime：Client-Server通信维持心跳的时间间隔,以毫秒为单位tickTime&#x3D;2000#initLimit：初始化集群时，集群节点同步超时时间（tickTime的数量）initLimit&#x3D;10#syncLimit：Leader-Follower节点之间请求和应答即同步数据的超时时间（tickTime的数量）syncLimit&#x3D;5#dataDir：数据文件目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper#clientPort：zk服务的监听端口号clientPort&#x3D;2181#maxClientCnxns：服务器能处理的最大客户端并发数，也即服务线程池的最大线程数，默认为60maxClientCnxns&#x3D;60#维护配置：客户端在与zookeeper交互过程中会产生非常多的日志，而且zookeeper也会将内存中的数据作为snapshot保存下来，这些数据是不会被自动删除的，这样磁盘中这样的数据就会越来越多。autopurge.snapRetainCount是设置保留snapshot的个数，而autopurge.purgeInterval则代表了合并快照的时间间隔(防止快照越来越多)#autopurge.snapRetainCount&#x3D;3#autopurge.purgeInterval&#x3D;1</code></pre><h2 id="ZK客户端基本指令"><a href="#ZK客户端基本指令" class="headerlink" title="ZK客户端基本指令"></a>ZK客户端基本指令</h2><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405105626880.png" class=""><h3 id="单体命令"><a href="#单体命令" class="headerlink" title="单体命令"></a>单体命令</h3><h4 id="ls-path"><a href="#ls-path" class="headerlink" title="ls path"></a>ls path</h4><p>查看当前节点路径下的下一级子节点</p><pre><code class="hljs powershell"><span class="hljs-built_in">ls</span> /<span class="hljs-built_in">ls</span> /zookeeper<span class="hljs-built_in">ls</span> /zookeeper/quota</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405112738805.png" class=""><h4 id="create-s-e-path-data-acl"><a href="#create-s-e-path-data-acl" class="headerlink" title="create [-s] [-e] path data acl"></a>create [-s] [-e] path data acl</h4><p>创建节点(四大类)，默认创建持久化节点，加上<code>-s</code>代表创建顺序节点，加上<code>-e</code>代表创建临时节点。</p><pre><code class="hljs powershell"><span class="hljs-comment">#创建p节点</span>create /testCreate person<span class="hljs-comment">#创建ps节点</span>create <span class="hljs-literal">-s</span> /testCreate/person zhangsan1create <span class="hljs-literal">-s</span> /testCreate/person zhangsan2create <span class="hljs-literal">-s</span> /testCreate/person zhangsan3<span class="hljs-comment">#创建e节点</span>create <span class="hljs-literal">-e</span> /testCreate/session session1<span class="hljs-comment">#创建es节点</span>create <span class="hljs-literal">-s</span> <span class="hljs-literal">-e</span> /testCreate/session session1</code></pre><p><code>查看创建的持久化节点</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405112654307.png" class=""><p><code>查看创建的临时节点</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405112804150.png" class=""><p>quit退出客户端，自动关闭会话，此时查看之前创建的节点的状态。</p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405112520961.png" class=""><p>临时节点在会话失效后会自动删除，同时，临时节点下不能创建任何子节点。</p><h4 id="stat-path"><a href="#stat-path" class="headerlink" title="stat path"></a>stat path</h4><p>查看节点的信息</p><pre><code class="hljs powershell">stat /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405121454718.png" class=""><h4 id="get-path"><a href="#get-path" class="headerlink" title="get path"></a>get path</h4><p>获取节点存储的数据及节点信息</p><pre><code class="hljs powershell">get /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405121703253.png" class=""><h4 id="set-path-data"><a href="#set-path-data" class="headerlink" title="set path data"></a>set path data</h4><p>修改节点的数据并查看</p><pre><code class="hljs powershell"><span class="hljs-built_in">set</span> /testcreate peopleget /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405122048136.png" class=""><h4 id="delete-path"><a href="#delete-path" class="headerlink" title="delete path"></a>delete path</h4><p>删除节点（该节点必须没有子节点）</p><pre><code class="hljs powershell"><span class="hljs-built_in">ls</span> /testCreatedelete /testCreatedelete /testCreate/person0000000002<span class="hljs-built_in">ls</span> /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405123113775.png" class=""><h4 id="rmr-path"><a href="#rmr-path" class="headerlink" title="rmr path"></a>rmr path</h4><p>递归删除节点，可以删除含子节点的节点</p><pre><code class="hljs powershell">create /testDelete personcreate <span class="hljs-literal">-s</span> /testDelete xiaomingcreate <span class="hljs-literal">-s</span> /testDelete xiaohongcreate <span class="hljs-literal">-s</span> /testDelete xiaomarmr /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405123637490.png" class=""><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>查看操作历史</p><pre><code class="hljs powershell"><span class="hljs-built_in">history</span></code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405122527807.png" class=""><h4 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h4><p>退出当前会话（会话失效）</p><pre><code class="hljs powershell">quit</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405123837578.png" class=""><h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><h4 id="ls2-path"><a href="#ls2-path" class="headerlink" title="ls2 path"></a>ls2 path</h4><p><code>ls path</code> 和 <code>stat path</code> 的组合</p><pre><code class="hljs powershell">ls2 /testCreate</code></pre><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405122316016.png" class=""><h2 id="节点监听机制-Watch"><a href="#节点监听机制-Watch" class="headerlink" title="节点监听机制(Watch)"></a>节点监听机制(Watch)</h2><p>客户端可以监听znode节点的变化，主要包括<code>节点路径</code>和<code>节点数据</code>两种变化。znode节点的变化会触发响应的时间，然后清除对该节点的监测，当监测一个znode节点时，zk会发送通知给监测节点。<code>一个Watch时间是一个一次性的触发器</code>，当被设置了Watch的数据和节点路径发生了变化时，则服务器将会把这个改变发送给设置Watch的客户端进行通知。</p><h3 id="节点路径监听"><a href="#节点路径监听" class="headerlink" title="节点路径监听"></a>节点路径监听</h3><p><code>监听客户端设置节点路径监听</code>—— 该节点路径下的所有路径变化都会通知到设置该监听的客户端</p><pre><code class="hljs powershell"><span class="hljs-built_in">ls</span> path true</code></pre><h3 id="节点数据监听"><a href="#节点数据监听" class="headerlink" title="节点数据监听"></a>节点数据监听</h3><p><code>监听客户端设置节点数据监听</code> —— 该节点路径下的所有数据变化都会通知到设置该监听的客户端</p><pre><code class="hljs powershell">get path true</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>微服务框架下作为服务的注册中心</p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405125717905.png" class=""><h2 id="Java操作ZK"><a href="#Java操作ZK" class="headerlink" title="Java操作ZK"></a>Java操作ZK</h2><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><p>导入zkclient依赖包</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入zookeeper依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>导入测试时要用到的两个依赖：junit 和 lombok</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--junit--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--lombok依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.client;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> org.I0Itec.zkclient.IZkChildListener;<span class="hljs-keyword">import</span> org.I0Itec.zkclient.IZkDataListener;<span class="hljs-keyword">import</span> org.I0Itec.zkclient.ZkClient;<span class="hljs-keyword">import</span> org.I0Itec.zkclient.serialize.SerializableSerializer;<span class="hljs-keyword">import</span> org.I0Itec.zkclient.serialize.ZkSerializer;<span class="hljs-keyword">import</span> org.apache.zookeeper.CreateMode;<span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<span class="hljs-keyword">import</span> org.junit.After;<span class="hljs-keyword">import</span> org.junit.Before;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestZKClient</span> </span>&#123;    <span class="hljs-keyword">private</span> ZkClient zkClient;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 创建节点测试</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 13:27</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateNode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//参数1: 节点路径</span>        <span class="hljs-comment">//参数2: 节点数据</span>        <span class="hljs-comment">//参数3: 指定创建节点的类型</span>        <span class="hljs-comment">//1.创建P节点</span>        zkClient.create(<span class="hljs-string">&quot;/testCreateNode&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>, CreateMode.PERSISTENT);        zkClient.create(<span class="hljs-string">&quot;/testCreateNode/pNode&quot;</span>, <span class="hljs-string">&quot;p-node&quot;</span>, CreateMode.PERSISTENT);        <span class="hljs-comment">//2.创建PS节点</span>        zkClient.create(<span class="hljs-string">&quot;/testCreateNode/PSNode&quot;</span>, <span class="hljs-string">&quot;ps-node&quot;</span>, CreateMode.PERSISTENT_SEQUENTIAL);        <span class="hljs-comment">//3.创建E节点</span>        zkClient.create(<span class="hljs-string">&quot;/testCreateNode/ENode&quot;</span>, <span class="hljs-string">&quot;e-node&quot;</span>, CreateMode.EPHEMERAL);        <span class="hljs-comment">//4.创建ES节点</span>        zkClient.create(<span class="hljs-string">&quot;/testCreateNode/ESNode&quot;</span>, <span class="hljs-string">&quot;es-node&quot;</span>, CreateMode.EPHEMERAL_SEQUENTIAL);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 删除节点测试</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 13:56</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteNode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">/*//1.只能删除不含子节点的节点</span><span class="hljs-comment">        boolean deleteStatus = zkClient.delete(&quot;/testCreateNode&quot;);</span><span class="hljs-comment">        System.out.println(&quot;节点删除状态: &quot; + deleteStatus);*/</span>        <span class="hljs-comment">//2.递归删除节点</span>        <span class="hljs-keyword">boolean</span> deleteRecursiveStatus = zkClient.deleteRecursive(<span class="hljs-string">&quot;/testCreateNode&quot;</span>);        System.out.println(<span class="hljs-string">&quot;节点删除状态: &quot;</span> + deleteRecursiveStatus);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 测试查询当前节点路径下的所有子节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 13:59</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetChidrenNodes</span><span class="hljs-params">()</span></span>&#123;        List&lt;String&gt; children = zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>);        <span class="hljs-keyword">for</span> (String child : children)&#123;            System.out.println(child);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 查看某个节点路径存储的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 14:00</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetNodeData</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//注意读数据时要保证节点创建时的数据序列化方式和获取时的序列化方式一致</span>        Object data = zkClient.readData(<span class="hljs-string">&quot;/testCreateNode&quot;</span>);        System.out.println(data);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 获取节点的状态信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 14:08</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetNodeStatus</span><span class="hljs-params">()</span></span>&#123;        Stat stat = <span class="hljs-keyword">new</span> Stat();        Object readData = zkClient.readData(<span class="hljs-string">&quot;/testCreateNode&quot;</span>, stat);        System.out.println(readData);        System.out.println(<span class="hljs-string">&quot;创建版本：&quot;</span> + stat.getCversion());        System.out.println(<span class="hljs-string">&quot;创建时间：&quot;</span> + stat.getCtime());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 更新节点数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 14:17</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyNodeData</span><span class="hljs-params">()</span></span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">&quot;wandehua&quot;</span>).setAge(<span class="hljs-number">23</span>).setBirth(<span class="hljs-keyword">new</span> Date());        zkClient.writeData(<span class="hljs-string">&quot;/testCreateNode&quot;</span>, user);        User userInfo = zkClient.readData(<span class="hljs-string">&quot;/testCreateNode&quot;</span>);        System.out.println(<span class="hljs-string">&quot;更新后的数据：&quot;</span> + userInfo);        System.out.println(<span class="hljs-string">&quot;ID：&quot;</span> + userInfo.getId());        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + userInfo.getName());        System.out.println(<span class="hljs-string">&quot;年龄：&quot;</span> + userInfo.getAge());        System.out.println(<span class="hljs-string">&quot;生日：&quot;</span> + userInfo.getBirth());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 监听节点的数据变化</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 15:13</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWatchDataChange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        zkClient.subscribeDataChanges(<span class="hljs-string">&quot;/testCreateNode&quot;</span>, <span class="hljs-keyword">new</span> IZkDataListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String s, Object o)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;当前路径: &quot;</span> + s);                System.out.println(<span class="hljs-string">&quot;当前节点变化后的数据: &quot;</span> + o);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;当前路径: &quot;</span> + s);            &#125;        &#125;);        <span class="hljs-comment">//阻塞客户端</span>        System.in.read();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 监听当前节点路径下的下一级子节点的变化</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 15:20</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWatchNodesChange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        zkClient.subscribeChildChanges(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">new</span> IZkChildListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleChildChange</span><span class="hljs-params">(String s, List&lt;String&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;父节点名称&quot;</span> + s);                System.out.println(<span class="hljs-string">&quot;发生改变的子节点名称：&quot;</span>);                <span class="hljs-keyword">for</span> (String name : list)&#123;                    System.out.println(name);                &#125;            &#125;        &#125;);        <span class="hljs-comment">//阻塞客户端</span>        System.in.read();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 测试之前初始化客户端对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 13:27</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//参数1: 服务器ip:port</span>        <span class="hljs-comment">//参数2: 会话超时时间</span>        <span class="hljs-comment">//参数3: 连接超时时间</span>        <span class="hljs-comment">//参数4: 序列化方式</span>        zkClient = <span class="hljs-keyword">new</span> ZkClient(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">60000</span> * <span class="hljs-number">3</span>, <span class="hljs-number">60000</span>, <span class="hljs-keyword">new</span> SerializableSerializer());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 测试结束，释放资源</span><span class="hljs-comment">     * <span class="hljs-doctag">@params</span>: []</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: void</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>: caoyusang</span><span class="hljs-comment">     * <span class="hljs-doctag">@dateTime</span>: 2021/4/5 13:27</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@After</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">/*//延迟资源释放，不然临时节点的创建看不到</span><span class="hljs-comment">        Thread.sleep(25000);*/</span>        zkClient.close();    &#125;&#125;</code></pre><p><code>创建节点的结果</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405134809157.png" class=""><p><code>不能删除含子节点的节点的情况</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405135456738.png" class=""><p><code>递归删除成功返回的状态</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405135544329.png" class=""><p><code>获取当前节点的所有子节点(上面已经把testCreateNodes递归删除了)</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405135937670.png" class=""><p><code>获取节点信息</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405141203293.png" class=""><p><code>更新节点</code></p><p>使用User对象更新节点的数据</p><p>先创建一个实体类User——要实现<code>序列化</code>，这里用到了lombok提供构造器和get/set方法以及允许链式编程@Accessors(chain = true)</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-keyword">import</span> lombok.experimental.Accessors;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Accessors(chain = true)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Date birth;&#125;</code></pre><p><code>更新结果</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405142216629.png" class=""><p><code>监听节点数据变化事件 —— 更新节点数据</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405150959604.png" class=""><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405151014276.png" class=""><p><code>监听节点数据变化事件 —— 删除节点</code></p><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405151153673.png" class=""><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405151219002.png" class=""><h2 id="ZK的集群"><a href="#ZK的集群" class="headerlink" title="ZK的集群"></a>ZK的集群</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集合同一种软件服务的多个节点同时为客户端提供服务，集群的出现就是为了解决以下几个问题：</p><ul><li>单节点的并发访问压力问题</li><li>单节点故障问题（由于硬件老化、自然灾害等原因）</li></ul><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><img src="/2021/04/05/Zookeeper%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/image-20210405153128249.png" class=""><ul><li>两类节点：leader 和 follower，一个ZK集群中一般只有一个leader节点，follower节点又称仲裁节点，它们的配置完全一样。leader节点由<code>投票选举</code>从所有follower节点中产生。</li><li>搭建集群时，至少需要三台服务器，且强烈建议使用奇数个服务器，如果只有两台服务器，在其中一个节点宕机时，没办法形成多数仲裁。同时，由于存在两个单点故障，所以两台服务器甚至不如一台服务器稳定。</li><li>分布式<code>写数据不一致问题</code>的解决 —— <code>zab原子广播协议</code>，当客户端像任意一个服务节点进行了写操作，此时服务节点并不直接更新，而是先向主节点leader询问是否可以更新，如果得到肯定的回复，那么所有follwer节点之间就会进行广播通信，同步更新写入的数据。如果写入失败，则将失败信息返回给客户端。</li><li>如果某一时刻leader节点宕机，那么就从所有剩下的follower节点中进行多数仲裁，选举出新的leader节点。</li></ul><h3 id="ZK集群的搭建"><a href="#ZK集群的搭建" class="headerlink" title="ZK集群的搭建"></a>ZK集群的搭建</h3><p><a href="https://www.cnblogs.com/ysocean/p/9860529.html">zookeeper 集群搭建</a></p><h3 id="通过Java客户端操作ZK集群"><a href="#通过Java客户端操作ZK集群" class="headerlink" title="通过Java客户端操作ZK集群"></a>通过Java客户端操作ZK集群</h3><p>在初始化客户端对象时，把服务端的ip:port换成对应集群中所有节点的ip:port即可。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/expiator/p/9853378.html">linux安装zookeeper及使用</a></p><p><a href="https://www.cnblogs.com/ysocean/p/9860529.html">zookeeper 集群搭建</a></p><p><a href="https://www.bilibili.com/video/BV1Uy4y1b7ED">2021最新ZooKeeper教程</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解之数组</title>
    <link href="/2021/01/25/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2021/01/25/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h5 id="1480-一维数组的运行和"><a href="#1480-一维数组的运行和" class="headerlink" title="1480.一维数组的运行和"></a>1480.一维数组的运行和</h5><h6 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] runningSum(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            sum += nums[i];            nums[i] = sum;        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre><h5 id="1431-糖果数目最多的孩子"><a href="#1431-糖果数目最多的孩子" class="headerlink" title="1431.糖果数目最多的孩子"></a>1431.糖果数目最多的孩子</h5><h6 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">kidsWithCandies</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candies, <span class="hljs-keyword">int</span> extraCandies)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = candies.length;        <span class="hljs-keyword">int</span> maxCandies = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            maxCandies = Math.max(maxCandies, candies[i]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : candies)&#123;            res.add(num + extraCandies &gt;= maxCandies);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="1470-改变数组排列方式"><a href="#1470-改变数组排列方式" class="headerlink" title="1470.改变数组排列方式"></a>1470.改变数组排列方式</h5><h6 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] shuffle(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span> * n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++)&#123;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;                res[i] = nums[n - <span class="hljs-number">1</span> + (i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                res[i] = nums[i / <span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="1672-最富有的银行客户的总资产"><a href="#1672-最富有的银行客户的总资产" class="headerlink" title="1672.最富有的银行客户的总资产"></a>1672.最富有的银行客户的总资产</h5><h6 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumWealth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] accounts)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = accounts.length, n = accounts[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m; i++)&#123;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;                sum += accounts[i][j];            &#125;            res = Math.max(res, sum);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="1512-“好对儿”的数目"><a href="#1512-“好对儿”的数目" class="headerlink" title="1512.“好对儿”的数目"></a>1512.“好对儿”的数目</h5><h6 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : map.keySet())&#123;            <span class="hljs-keyword">if</span> (map.containsKey(num))&#123;                <span class="hljs-keyword">int</span> val = map.get(num);                <span class="hljs-comment">//该数有&quot;好对儿&quot;</span>                <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">1</span>)&#123;                    cnt += (val - <span class="hljs-number">1</span>) * val / <span class="hljs-number">2</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;            &#125;&#125;</code></pre><h5 id="1365-有多少个数比当前数小"><a href="#1365-有多少个数比当前数小" class="headerlink" title="1365.有多少个数比当前数小"></a>1365.有多少个数比当前数小</h5><h6 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallerNumbersThanCurrent(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-comment">// int n = nums.length;</span>        <span class="hljs-comment">// int[] res = new int[n];</span>        <span class="hljs-comment">// for (int i = 0; i &lt; n; i++)&#123;</span>        <span class="hljs-comment">//     int cnt = 0;</span>        <span class="hljs-comment">//     for (int j = 0; j &lt; n; j++)&#123;</span>        <span class="hljs-comment">//         if (i == j) continue;</span>        <span class="hljs-comment">//         if (nums[j] &lt; nums[i])&#123;</span>        <span class="hljs-comment">//             cnt++;</span>        <span class="hljs-comment">//         &#125;</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">//     res[i] = cnt;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return res;</span>        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] t = nums.clone();        Map&lt;Integer,Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Arrays.sort(t);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            m.putIfAbsent(t[i], i);        &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            t[i] = m.get(nums[i]);        &#125;        <span class="hljs-keyword">return</span> t;    &#125;&#125;</code></pre><h5 id="1486-数组中的异或操作"><a href="#1486-数组中的异或操作" class="headerlink" title="1486.数组中的异或操作"></a>1486.数组中的异或操作</h5><h6 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xorOperation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">int</span> n1 = start;        <span class="hljs-keyword">int</span> n2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            n2 = start + <span class="hljs-number">2</span> * i;            n1 ^= n2;        &#125;        <span class="hljs-keyword">return</span> n1;    &#125;&#125;</code></pre><h5 id="1588-所有奇数长度连续子数组的和"><a href="#1588-所有奇数长度连续子数组的和" class="headerlink" title="1588.所有奇数长度连续子数组的和"></a>1588.所有奇数长度连续子数组的和</h5><h6 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOddLengthSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-comment">//k表示子数组的长度，为奇数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k += <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + k  &lt;= n; i++)&#123;                <span class="hljs-keyword">int</span> tmp = arr[i];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++)&#123;                     tmp += arr[i + j];                &#125;                sum += tmp;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h5 id="1732-找到最高海拔"><a href="#1732-找到最高海拔" class="headerlink" title="1732.找到最高海拔"></a>1732.找到最高海拔</h5><h6 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestAltitude</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gain)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxH = Integer.MIN_VALUE;        <span class="hljs-keyword">int</span> curH = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gain.length; i++)&#123;            maxH = Math.max(maxH, curH);            curH += gain[i];        &#125;        <span class="hljs-comment">//记得最后再求一次最大，因为curH最后一次赋值后未被比较</span>        maxH = Math.max(maxH, curH);        <span class="hljs-keyword">return</span> maxH;    &#125;&#125;</code></pre><h5 id="1295-统计数组中具有偶数位数的数字个数"><a href="#1295-统计数组中具有偶数位数的数字个数" class="headerlink" title="1295.统计数组中具有偶数位数的数字个数"></a>1295.统计数组中具有偶数位数的数字个数</h5><h6 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span> (getDigits(num) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                cnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;    <span class="hljs-comment">//获取数字的位数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;        <span class="hljs-keyword">int</span> digits = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;            num /= <span class="hljs-number">10</span>;            digits++;        &#125;        <span class="hljs-keyword">return</span> digits;    &#125;&#125;</code></pre><h5 id="832-垂直翻转图像"><a href="#832-垂直翻转图像" class="headerlink" title="832.垂直翻转图像"></a>832.垂直翻转图像</h5><h6 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] flipAndInvertImage(<span class="hljs-keyword">int</span>[][] A) &#123;        <span class="hljs-keyword">int</span> m = A.length, n = A[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] arr : A)&#123;            <span class="hljs-comment">//翻转的同时进行异或(0 ^ 1 = 1)</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++)&#123;                <span class="hljs-keyword">int</span> tmp = arr[n - i - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;                arr[n - i - <span class="hljs-number">1</span>] = arr[i] ^ <span class="hljs-number">1</span>;                arr[i] = tmp;            &#125;        &#125;                <span class="hljs-keyword">return</span> A;    &#125;&#125;</code></pre><h5 id="1572-矩阵的对角线之和"><a href="#1572-矩阵的对角线之和" class="headerlink" title="1572.矩阵的对角线之和"></a>1572.矩阵的对角线之和</h5><h6 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diagonalSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = mat.length;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            sum += mat[i][i];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            sum += mat[i][n - i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-comment">//偶阶方阵不会有主副对角线元素重复，奇阶方阵需要减去重复的</span>        <span class="hljs-keyword">return</span> sum = n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? sum : sum - mat[n / <span class="hljs-number">2</span>][n / <span class="hljs-number">2</span>];    &#125;&#125;</code></pre><h5 id="1450-正在做作业的学生数目"><a href="#1450-正在做作业的学生数目" class="headerlink" title="1450.正在做作业的学生数目"></a>1450.正在做作业的学生数目</h5><h6 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">busyStudent</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] startTime, <span class="hljs-keyword">int</span>[] endTime, <span class="hljs-keyword">int</span> queryTime)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = endTime.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (queryTime &gt;= startTime[i] &amp;&amp; queryTime &lt;= endTime[i])&#123;                cnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;        &#125;</code></pre><h5 id="1464-数组中两个元素的最大乘积"><a href="#1464-数组中两个元素的最大乘积" class="headerlink" title="1464.数组中两个元素的最大乘积"></a>1464.数组中两个元素的最大乘积</h5><h6 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">//库函数排序即可</span>    <span class="hljs-comment">// public int maxProduct(int[] nums) &#123;</span>    <span class="hljs-comment">//     Arrays.sort(nums);</span>    <span class="hljs-comment">//     int n = nums.length;</span>    <span class="hljs-comment">//     return (nums[n - 1] - 1) * (nums[n - 2] - 1);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">//堆排序</span>    <span class="hljs-comment">// public int maxProduct(int[] nums) &#123;</span>    <span class="hljs-comment">//     PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span>    <span class="hljs-comment">//     for(int i = 0; i&lt;nums.length; i++)&#123;</span>    <span class="hljs-comment">//         pq.add(nums[i]);</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     int num1 = pq.poll();</span>    <span class="hljs-comment">//     int num2 = pq.poll();</span>    <span class="hljs-comment">//     return (num1-1)*(num2-1);</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">//遍历找出最大的两个数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max1 = nums[<span class="hljs-number">0</span>], max2 = nums[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(max1 &lt; max2)&#123;            <span class="hljs-keyword">int</span> t = max1;            max1 = max2;            max2 = t;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; max1)&#123;                max2 = max1;                max1 = nums[i];            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &gt; max2)&#123;                max2 = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> (max1-<span class="hljs-number">1</span>)*(max2-<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h5 id="1748-所有不重复元素的和"><a href="#1748-所有不重复元素的和" class="headerlink" title="1748.所有不重复元素的和"></a>1748.所有不重复元素的和</h5><h6 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOfUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">//HashMap</span>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key : map.keySet())&#123;            <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">1</span>)&#123;                sum += key;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h5 id="1351-在有序矩阵中统计负数的总个数"><a href="#1351-在有序矩阵中统计负数的总个数" class="headerlink" title="1351.在有序矩阵中统计负数的总个数"></a>1351.在有序矩阵中统计负数的总个数</h5><p>矩阵的行列都为降序</p><h6 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNegatives</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> firstNegativeIdx = n;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;            firstNegativeIdx = findFirstNegativeIdx(grid[i], firstNegativeIdx);            count += grid[i].length - firstNegativeIdx;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findFirstNegativeIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = limit;        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> hi = limit;        <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;            <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (arr[mid] &lt; <span class="hljs-number">0</span>) &#123;                res = mid;                hi = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                lo = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="905-按奇偶校验对数组排序"><a href="#905-按奇偶校验对数组排序" class="headerlink" title="905.按奇偶校验对数组排序"></a>905.按奇偶校验对数组排序</h5><h6 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArrayByParity(<span class="hljs-keyword">int</span>[] A) &#123;<span class="hljs-comment">//         //空间复杂度太大</span><span class="hljs-comment">//         int n = A.length;</span><span class="hljs-comment">//         int[] res = new int[n];</span><span class="hljs-comment">//         int evenIdx = 0, oddIdx = n - 1;</span><span class="hljs-comment">//         for (int i = 0; i &lt; n; i++)&#123;</span><span class="hljs-comment">//             res[A[i] % 2 == 0 ? evenIdx++ : oddIdx--] = A[i];</span><span class="hljs-comment">//         &#125;</span>        <span class="hljs-comment">//         return res;</span>                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = A.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left != right)&#123;            <span class="hljs-keyword">if</span> (A[left] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                left++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (A[right] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                    <span class="hljs-keyword">int</span> tmp = A[left];                    A[left] = A[right];                    A[right] = tmp;                    left++;                &#125; <span class="hljs-keyword">else</span> &#123;                    right--;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> A;    &#125;&#125;</code></pre><h5 id="48-顺时针90°旋转矩阵"><a href="#48-顺时针90°旋转矩阵" class="headerlink" title="48.顺时针90°旋转矩阵"></a>48.顺时针90°旋转矩阵</h5><p>要求就地修改，即<code>O(1)</code></p><h6 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = matrix.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++) &#123;                <span class="hljs-comment">//顺时针交换值</span>                <span class="hljs-keyword">int</span> temp = matrix[n - <span class="hljs-number">1</span> - j][i];                matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - j - <span class="hljs-number">1</span>];                matrix[n - <span class="hljs-number">1</span> - i][n - j - <span class="hljs-number">1</span>] = matrix[j][n - <span class="hljs-number">1</span> - i];                matrix[j][n - <span class="hljs-number">1</span> - i] = matrix[i][j];                matrix[i][j] = temp;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="169-众数"><a href="#169-众数" class="headerlink" title="169.众数"></a>169.众数</h5><h6 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// //HashMap</span>        <span class="hljs-comment">// HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span>        <span class="hljs-comment">// for (int num : nums)&#123;</span>        <span class="hljs-comment">//     map.put(num, map.getOrDefault(num, 0) + 1);</span>        <span class="hljs-comment">//     if (map.get(num) &gt;= nums.length / 2 + 1)&#123;</span>        <span class="hljs-comment">//         return num;</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return 0;</span>                <span class="hljs-comment">//候选人方法</span>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        Integer candidate = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;                candidate = num;            &#125;            cnt += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> candidate;                    &#125;&#125;</code></pre><h5 id="283-将数组中的0元素移至末尾"><a href="#283-将数组中的0元素移至末尾" class="headerlink" title="283.将数组中的0元素移至末尾"></a>283.将数组中的0元素移至末尾</h5><h6 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-comment">//用两个计数器分别计数非零元素和赋值下标</span>        <span class="hljs-keyword">int</span> zeroCnt = <span class="hljs-number">0</span>, nonZeroCnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)&#123;            <span class="hljs-keyword">if</span> (nums[k] == <span class="hljs-number">0</span>)&#123;                zeroCnt++;            &#125; <span class="hljs-keyword">else</span> &#123;                nums[nonZeroCnt++] = nums[k];             &#125;        &#125;        Arrays.fill(nums, nonZeroCnt, n, <span class="hljs-number">0</span>);    &#125;&#125;</code></pre><h5 id="78-数组的子集"><a href="#78-数组的子集" class="headerlink" title="78.数组的子集"></a>78.数组的子集</h5><h6 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> n, k;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        n = nums.length;        <span class="hljs-comment">//k为子数组长度，每次都从0开始，增长到k就停止</span>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n + <span class="hljs-number">1</span>; k++)&#123;            backTrack(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(ArrayList&lt;Integer&gt; cur, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> size)</span></span>&#123;        <span class="hljs-comment">//子数组长度增长到k，结束</span>        <span class="hljs-keyword">if</span> (cur.size() == k)&#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; n; i++)&#123;            cur.add(nums[i]);            <span class="hljs-comment">//继续组合</span>            backTrack(cur, nums, i + <span class="hljs-number">1</span>);            <span class="hljs-comment">//回溯</span>            cur.remove(cur.size() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h5 id="238-构建乘积数组"><a href="#238-构建乘积数组" class="headerlink" title="238.构建乘积数组"></a>238.构建乘积数组</h5><h6 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(res, <span class="hljs-number">1</span>);        <span class="hljs-comment">//左半部分元素累乘(第一个元素没有左半部分)</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            res[i] = res[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-comment">//右半部分元素(最后一个元素没有右半部分)</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;            tmp *= nums[j + <span class="hljs-number">1</span>];            <span class="hljs-comment">//乘上右半部分的累乘</span>            res[j] *= tmp;        &#125;        <span class="hljs-keyword">return</span> res;                    &#125;&#125;</code></pre><h5 id="287-找出数组中唯一重复的数字"><a href="#287-找出数组中唯一重复的数字" class="headerlink" title="287.找出数组中唯一重复的数字"></a>287.找出数组中唯一重复的数字</h5><h6 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span> (set.contains(num))&#123;                <span class="hljs-keyword">return</span> num;            &#125; <span class="hljs-keyword">else</span> &#123;                set.add(num);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h5 id="64-矩阵中的最小路径和"><a href="#64-矩阵中的最小路径和" class="headerlink" title="64.矩阵中的最小路径和"></a>64.矩阵中的最小路径和</h5><h6 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">//dp[i][j]代表(0,0)到(i,j)的最短路径</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h5 id="75-颜色排序"><a href="#75-颜色排序" class="headerlink" title="75.颜色排序"></a>75.颜色排序</h5><h6 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt0 = <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;                cnt0++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)&#123;                cnt1++;            &#125; <span class="hljs-keyword">else</span> &#123;                cnt2++;            &#125;        &#125;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (cnt0-- != <span class="hljs-number">0</span>)&#123;            nums[i++] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">while</span> (cnt1-- != <span class="hljs-number">0</span>)&#123;            nums[i++] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">while</span> (cnt2-- != <span class="hljs-number">0</span>)&#123;            nums[i++] = <span class="hljs-number">2</span>;        &#125;            &#125;&#125;</code></pre><h5 id="200-岛屿数目"><a href="#200-岛屿数目" class="headerlink" title="200.岛屿数目"></a>200.岛屿数目</h5><h6 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> islands = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;                <span class="hljs-comment">//遍历到&#x27;1&#x27;，说明是岛屿</span>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                    islands++;                    <span class="hljs-comment">//深度优先，将与这个岛相连的陆地都变成&#x27;0&#x27;，那么下次再碰到一个&#x27;1&#x27;时就是找到一个新的岛</span>                    dfs(grid, i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> islands;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-comment">//已经到岛屿的边缘，则停止搜索</span>        <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;        arr[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dfs(arr, i - <span class="hljs-number">1</span>, j);        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt;= arr.length - <span class="hljs-number">1</span>) dfs(arr, i + <span class="hljs-number">1</span>, j);        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dfs(arr, i, j - <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= arr[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>) dfs(arr, i, j + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h5 id="118-帕斯卡三角形"><a href="#118-帕斯卡三角形" class="headerlink" title="118.帕斯卡三角形"></a>118.帕斯卡三角形</h5><h6 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-comment">//第一行</span>        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        res.get(<span class="hljs-number">0</span>).add(<span class="hljs-number">1</span>);        <span class="hljs-comment">//第二行往后</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numRows; i++)&#123;            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-comment">//前一行</span>            List&lt;Integer&gt; pre = res.get(i - <span class="hljs-number">1</span>);            <span class="hljs-comment">//List第一个元素</span>            tmp.add(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;                tmp.add(pre.get(j - <span class="hljs-number">1</span>) + pre.get(j));            &#125;            <span class="hljs-comment">//List最后一个元素</span>            tmp.add(<span class="hljs-number">1</span>);            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="350-两个数组的交集Ⅱ"><a href="#350-两个数组的交集Ⅱ" class="headerlink" title="350.两个数组的交集Ⅱ"></a>350.两个数组的交集Ⅱ</h5><h6 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(nums1);        Arrays.sort(nums2);        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (p &lt; nums1.length &amp;&amp; q &lt; nums2.length)&#123;            <span class="hljs-keyword">if</span> (nums1[p] == nums2[q])&#123;                res.add(nums1[p]);                p++;                q++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p] &lt; nums2[q])&#123;                p++;            &#125; <span class="hljs-keyword">else</span> &#123;                q++;            &#125;        &#125;                <span class="hljs-keyword">int</span> n = res.size();        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            arr[i] = res.get(i);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;&#125;</code></pre><h5 id="39-组合和"><a href="#39-组合和" class="headerlink" title="39.组合和"></a>39.组合和</h5><h6 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(candidates==<span class="hljs-keyword">null</span> || candidates.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-comment">// Arrays.sort(candidates);</span>        backTrack(candidates, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target);        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, ArrayList&lt;Integer&gt; lst, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-comment">//组合和大于等于target时，终止</span>        <span class="hljs-keyword">if</span> (cur &gt;= k)&#123;            <span class="hljs-comment">//等于时相当于找到一个组合和</span>            <span class="hljs-keyword">if</span> (cur == k)&#123;                res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(lst));            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//index防止出现重复情况</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span> (cur &lt;= k - nums[i])&#123;                lst.add(nums[i]);                backTrack(nums, lst, i, cur, k - nums[i]);                lst.remove(lst.size() - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="560-和为K的连续子数组的个数"><a href="#560-和为K的连续子数组的个数" class="headerlink" title="560.和为K的连续子数组的个数"></a>560.和为K的连续子数组的个数</h5><h6 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// int res = 0;</span>        <span class="hljs-comment">// for (int i = 0; i &lt; nums.length; i++)&#123;</span>        <span class="hljs-comment">//     int sum = 0;</span>        <span class="hljs-comment">//     for (int j = i; j &lt; nums.length; j++)&#123;</span>        <span class="hljs-comment">//         sum += nums[j];</span>        <span class="hljs-comment">//         if (sum == k)&#123;</span>        <span class="hljs-comment">//             res++;</span>        <span class="hljs-comment">//         &#125;</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// return res;</span>        <span class="hljs-comment">//前缀和 + HashMap</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            sum += nums[i];            <span class="hljs-keyword">if</span> (map.containsKey(sum - k))&#123;                count += map.get(sum - k);            &#125;            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><h5 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h5><h6 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h6><p><code>贪心</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> farthest = <span class="hljs-number">0</span>;        <span class="hljs-comment">//当所遍历的位置还没超出可farthest范围时，根据跳力更新可reach范围</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= farthest; i++)&#123;            <span class="hljs-comment">//通过每一步能跳到的最远位置，更新全局能跳到的最远位置</span>            farthest = Math.max(farthest, i + nums[i]);            <span class="hljs-keyword">if</span> (farthest &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h5 id="45-跳跃游戏Ⅱ"><a href="#45-跳跃游戏Ⅱ" class="headerlink" title="45.跳跃游戏Ⅱ"></a>45.跳跃游戏Ⅱ</h5><p>保证能跳到最后一个位置，那么至少需要跳几次？</p><h6 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> reach = <span class="hljs-number">0</span>, nextReach = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> jumps = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;            nextReach = Math.max(nextReach, i + nums[i]);            <span class="hljs-keyword">if</span> (reach == i)&#123;                jumps++;                reach = nextReach;            &#125;        &#125;        <span class="hljs-keyword">return</span> jumps;    &#125;&#125;</code></pre><h5 id="581-最短的无序连续子序列的长度"><a href="#581-最短的无序连续子序列的长度" class="headerlink" title="581.最短的无序连续子序列的长度"></a>581.最短的无序连续子序列的长度</h5><p>给定一个整数数组nums，你需要找到一个连续的子数组，如果你只排序这个子数组升序，那么整个数组将升序排序。</p><p>返回最短的子数组并输出其长度。</p><h6 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//克隆一个nums</span>        <span class="hljs-keyword">int</span>[] cnums = nums.clone();        <span class="hljs-keyword">int</span> left = Integer.MAX_VALUE, right = Integer.MIN_VALUE;        <span class="hljs-comment">//对nums排序</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (cnums[i] != nums[i])&#123;                left = Math.min(left, i);                right = Math.max(right, i);            &#125;        &#125;                <span class="hljs-keyword">return</span> right &gt; left ? right - left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解之链表</title>
    <link href="/2021/01/21/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/01/21/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="1290-将链表中的二进制值转成整数"><a href="#1290-将链表中的二进制值转成整数" class="headerlink" title="1290.将链表中的二进制值转成整数"></a>1290.将链表中的二进制值转成整数</h5><h6 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDecimalValue</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cnt = -<span class="hljs-number">1</span>;        ListNode p = head;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>)&#123;            cnt += <span class="hljs-number">1</span>;            p = p.next;        &#125;        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;            sum += head.val * Math.pow(<span class="hljs-number">2</span>, cnt--);            head = head.next;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h5 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206.翻转链表"></a>206.翻转链表</h5><h6 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">// head insert</span>        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        res.next = <span class="hljs-keyword">null</span>;        ListNode p = res.next;        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;            res.next = <span class="hljs-keyword">new</span> ListNode(head.val);            res.next.next = p;            p = res.next;            head = head.next;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h5 id="92-翻转链表Ⅱ"><a href="#92-翻转链表Ⅱ" class="headerlink" title="92.翻转链表Ⅱ"></a>92.翻转链表Ⅱ</h5><h6 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs plain"></code></pre><h5 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h5><h6 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        pre.next = head;        ListNode p = head, q = pre;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (p.val == val)&#123;                q.next = p.next;                p = p.next;                <span class="hljs-keyword">continue</span>;            &#125;            q = q.next;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><h5 id="234-判断回文链表"><a href="#234-判断回文链表" class="headerlink" title="234.判断回文链表"></a>234.判断回文链表</h5><h6 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-comment">// base situation</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        ListNode revHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        revHead.next = <span class="hljs-keyword">null</span>;        ListNode p = revHead.next, q = head;         <span class="hljs-comment">// head insert(reverse linked list)</span>        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>)&#123;            revHead.next = <span class="hljs-keyword">new</span> ListNode(q.val);            revHead.next.next = p;            p = revHead.next;            q = q.next;        &#125;        <span class="hljs-comment">// compare one by one</span>        <span class="hljs-keyword">while</span> (revHead.next != <span class="hljs-keyword">null</span> &amp;&amp; head != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (revHead.next.val != head.val)&#123;                <span class="hljs-keyword">break</span>;            &#125;            revHead = revHead.next;            head = head.next;        &#125;        <span class="hljs-comment">// attention</span>        <span class="hljs-keyword">return</span> head == <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h5 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328.奇偶链表"></a>328.奇偶链表</h5><h6 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode p = head, q = head.next, pre = q;        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span> &amp;&amp; q.next != <span class="hljs-keyword">null</span>)&#123;            p.next = q.next;            p = p.next;            q.next = p.next;            q = q.next;        &#125;        p.next = pre;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h5 id="141-循环链表"><a href="#141-循环链表" class="headerlink" title="141.循环链表"></a>141.循环链表</h5><h6 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        ListNode fastPtr = head, slowPtr = head;        <span class="hljs-keyword">while</span>(fastPtr != <span class="hljs-keyword">null</span> &amp;&amp; fastPtr.next != <span class="hljs-keyword">null</span>)&#123;            fastPtr = fastPtr.next.next;            slowPtr = slowPtr.next;            <span class="hljs-keyword">if</span> (fastPtr == slowPtr)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;&#125;</code></pre><h5 id="142-循环链表Ⅱ"><a href="#142-循环链表Ⅱ" class="headerlink" title="142.循环链表Ⅱ"></a>142.循环链表Ⅱ</h5><h6 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        HashSet&lt;ListNode&gt; hashset = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        pre.next = head;        ListNode p = pre.next;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (hashset.contains(p))&#123;                <span class="hljs-keyword">return</span> p;            &#125;            hashset.add(p);            p = p.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;&#125;</code></pre><h5 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876.链表的中间节点"></a>876.链表的中间节点</h5><h6 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        HashMap&lt;Integer, ListNode&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> cnt = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;            cnt += <span class="hljs-number">1</span>;            map.put(cnt, head);            head = head.next;        &#125;        <span class="hljs-keyword">return</span> map.get((cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);    &#125;&#125;</code></pre><h5 id="21-有序链表的合并"><a href="#21-有序链表的合并" class="headerlink" title="21.有序链表的合并"></a>21.有序链表的合并</h5><h6 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode p = pre;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;                p.next = <span class="hljs-keyword">new</span> ListNode(l1.val);                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                p.next = <span class="hljs-keyword">new</span> ListNode(l2.val);                l2 = l2.next;            &#125;            p = p.next;        &#125;        p.next = (l1 != <span class="hljs-keyword">null</span>) ? l1 : l2;        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><h5 id="83-移除有序链表中的重复元素"><a href="#83-移除有序链表中的重复元素" class="headerlink" title="83.移除有序链表中的重复元素"></a>83.移除有序链表中的重复元素</h5><h6 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        pre.next = head;        ListNode p = head.next;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (p.val == head.val)&#123;                p = p.next;                head.next = p;                <span class="hljs-keyword">continue</span>;            &#125;            head = head.next;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> pre.next;    &#125;&#125;</code></pre><h5 id="160-两个链表的交点"><a href="#160-两个链表的交点" class="headerlink" title="160.两个链表的交点"></a>160.两个链表的交点</h5><h6 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">// Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();</span>    <span class="hljs-comment">// public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span>    <span class="hljs-comment">//     while (headB != null)&#123;</span>    <span class="hljs-comment">//         set.add(headB);</span>    <span class="hljs-comment">//         headB = headB.next;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     while (headA != null)&#123;</span>    <span class="hljs-comment">//         if (set.contains(headA))&#123;</span>    <span class="hljs-comment">//             return headA;</span>    <span class="hljs-comment">//         &#125;</span>    <span class="hljs-comment">//         headA = headA.next;</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     return null;</span>    <span class="hljs-comment">// &#125;</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;        ListNode p = headA;        ListNode q = headB;        <span class="hljs-keyword">while</span> (p != q)&#123;            p = p == <span class="hljs-keyword">null</span>? headB : p.next;            q = q == <span class="hljs-keyword">null</span>? headA : q.next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre><h5 id="1669-链表的部分替换"><a href="#1669-链表的部分替换" class="headerlink" title="1669.链表的部分替换"></a>1669.链表的部分替换</h5><h6 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, ListNode list2)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        res.next = list1;        ListNode pre = res;        ListNode p = list1;        ListNode q = list2;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; cnt &lt; b)&#123;            <span class="hljs-keyword">if</span> (cnt &lt; a)&#123;                pre = pre.next;            &#125;            p = p.next;            cnt++;        &#125;                pre.next = list2;        <span class="hljs-keyword">while</span> (q.next != <span class="hljs-keyword">null</span>) &#123;            q = q.next;        &#125;        q.next = p.next;                <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解之二叉树</title>
    <link href="/2021/01/18/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/01/18/leetcode%E9%A2%98%E8%A7%A3%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h5 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.二叉搜索树的范围和</h5><h6 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rangeSumBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high)&#123;            sum += root.val;        &#125;        <span class="hljs-keyword">if</span> (root.val &gt; low) rangeSumBST(root.left, low, high);        <span class="hljs-keyword">if</span> (root.val &lt; high) rangeSumBST(root.right, low, high);        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h5 id="617-融合两棵二叉树"><a href="#617-融合两棵二叉树" class="headerlink" title="617.融合两棵二叉树"></a>617.融合两棵二叉树</h5><h6 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-keyword">null</span> &amp;&amp; t2 == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode tmp = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (t1 != <span class="hljs-keyword">null</span> &amp;&amp; t2 != <span class="hljs-keyword">null</span>)&#123;            tmp.val = t1.val + t2.val;            tmp.left = mergeTrees(t1.left, t2.left);            tmp.right = mergeTrees(t1.right, t2.right);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1 == <span class="hljs-keyword">null</span>)&#123;            tmp.val = t2.val;            tmp.left = mergeTrees(<span class="hljs-keyword">null</span>, t2.left);            tmp.right = mergeTrees(<span class="hljs-keyword">null</span>, t2.right);                    &#125; <span class="hljs-keyword">else</span> &#123;            tmp.val = t1.val;            tmp.left = mergeTrees(t1.left, <span class="hljs-keyword">null</span>);            tmp.right = mergeTrees(t1.right, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-keyword">return</span> tmp;    &#125;&#125;</code></pre><h5 id="897-升序搜索树"><a href="#897-升序搜索树" class="headerlink" title="897.升序搜索树"></a>897.升序搜索树</h5><h6 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    TreeNode pre = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);    TreeNode p = pre;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>)&#123;            increasingBST(root.left);        &#125;        p.right = <span class="hljs-keyword">new</span> TreeNode(root.val);        p = p.right;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>)&#123;            increasingBST(root.right);        &#125;        <span class="hljs-keyword">return</span> pre.right;    &#125;&#125;</code></pre><h5 id="589-N叉树的先序遍历"><a href="#589-N叉树的先序遍历" class="headerlink" title="589.N叉树的先序遍历"></a>589.N叉树的先序遍历</h5><h6 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// recursive</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        res.add(root.val);        <span class="hljs-keyword">for</span> (Node child: root.children) &#123;            preorder(child);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590.N叉树的后序遍历"></a>590.N叉树的后序遍历</h5><h6 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// recursive</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        <span class="hljs-keyword">for</span> (Node child : root.children) &#123;            postorder(child);        &#125;        res.add(root.val);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="1022-根到叶二进制数的和"><a href="#1022-根到叶二进制数的和" class="headerlink" title="1022.根到叶二进制数的和"></a>1022.根到叶二进制数的和</h5><h6 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">// recursive</span>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        sum = (sum &lt;&lt; <span class="hljs-number">1</span>) + node.val;        <span class="hljs-keyword">return</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) ? sum : dfs(node.left, sum) + dfs(node.right, sum);    &#125;&#125;</code></pre><h5 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559.N叉树的最大深度"></a>559.N叉树的最大深度</h5><h6 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (root.children.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> max_d = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (Node node: root.children)&#123;            max_d = Math.max(max_d, maxDepth(node));        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max_d;    &#125;&#125;</code></pre><h5 id="965-单值树判断"><a href="#965-单值树判断" class="headerlink" title="965.单值树判断"></a>965.单值树判断</h5><h6 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(root, root.val);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> val)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> node.val == val &amp;&amp; helper(node.left, val) &amp;&amp; helper(node.right, val);    &#125;&#125;</code></pre><h5 id="872-叶子节点序列相同树判断"><a href="#872-叶子节点序列相同树判断" class="headerlink" title="872.叶子节点序列相同树判断"></a>872.叶子节点序列相同树判断</h5><h6 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;Integer&gt; res2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;        getLeafVal(root1, res1);        getLeafVal(root2, res2);        <span class="hljs-keyword">return</span> res1.equals(res2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLeafVal</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        getLeafVal(node.left, res);        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>)&#123;            res.add(node.val);                    &#125;        getLeafVal(node.right, res);    &#125;&#125;</code></pre><h5 id="637-二叉树每层节点的平均值"><a href="#637-二叉树每层节点的平均值" class="headerlink" title="637.二叉树每层节点的平均值"></a>637.二叉树每层节点的平均值</h5><h6 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Double&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.add(root);        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> size = q.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode outNode = q.poll();                sum += outNode.val;                <span class="hljs-keyword">if</span> (outNode.left != <span class="hljs-keyword">null</span>) q.add(outNode.left);                <span class="hljs-keyword">if</span> (outNode.right != <span class="hljs-keyword">null</span>) q.add(outNode.right);            &#125;            res.add(sum / size);        &#125;        <span class="hljs-keyword">return</span> res;            &#125;&#125;</code></pre><h5 id="100-相同树"><a href="#100-相同树" class="headerlink" title="100.相同树"></a>100.相同树</h5><h6 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (p.val == q.val)&#123;            <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;           &#125;&#125;</code></pre><h5 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h5><h6 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> dfs(root.left, root.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);    &#125;&#125;</code></pre><h5 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h5><h6 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.add(root);        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.poll();                tmp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.add(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.add(cur.right);            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="404-二叉树的左叶子节点总数"><a href="#404-二叉树的左叶子节点总数" class="headerlink" title="404.二叉树的左叶子节点总数"></a>404.二叉树的左叶子节点总数</h5><h6 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">//存储结果</span>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//左叶子节点</span>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span> &amp;&amp; root.left.left == <span class="hljs-keyword">null</span> &amp;&amp; root.left.right ==<span class="hljs-keyword">null</span>) res += root.left.val;        sumOfLeftLeaves(root.left);        sumOfLeftLeaves(root.right);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="257-二叉树路径"><a href="#257-二叉树路径" class="headerlink" title="257.二叉树路径"></a>257.二叉树路径</h5><h6 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; paths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> paths;        dfs(root, String.valueOf(root.val));        <span class="hljs-keyword">return</span> paths;                    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, String subPath)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) &#123;            paths.add(subPath);        &#125;        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;            dfs(node.left, subPath + <span class="hljs-string">&quot;-&gt;&quot;</span> + node.left.val);        &#125;        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;            dfs(node.right, subPath + <span class="hljs-string">&quot;-&gt;&quot;</span> + node.right.val);        &#125;    &#125; &#125;</code></pre><h5 id="108-将有序数组转化为平衡二叉搜索树"><a href="#108-将有序数组转化为平衡二叉搜索树" class="headerlink" title="108.将有序数组转化为平衡二叉搜索树"></a>108.将有序数组转化为平衡二叉搜索树</h5><h6 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lf, <span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">if</span> (lf &gt; rt) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> mid = (rt - lf) / <span class="hljs-number">2</span> + lf;        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        node.left = helper(lf, mid - <span class="hljs-number">1</span>, nums);        node.right = helper(mid + <span class="hljs-number">1</span>, rt, nums);        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre><h5 id="653-二叉搜索树版两数之和"><a href="#653-二叉搜索树版两数之和" class="headerlink" title="653.二叉搜索树版两数之和"></a>653.二叉搜索树版两数之和</h5><h6 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; tree)</span></span>&#123;        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;            inorder(root.left, tree);            tree.add(root.val);            inorder(root.right, tree);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        List&lt;Integer&gt; tree = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        inorder(root, tree);        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = tree.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(start &lt; end)&#123;            <span class="hljs-keyword">int</span> sum = tree.get(start) + tree.get(end);            <span class="hljs-keyword">if</span>(sum == k)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span>(sum &lt; k)&#123;                start++;            &#125; <span class="hljs-keyword">else</span> &#123;                end--;            &#125;        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h5 id="530-平衡二叉搜索树中的最小绝对误差"><a href="#530-平衡二叉搜索树中的最小绝对误差" class="headerlink" title="530.平衡二叉搜索树中的最小绝对误差"></a>530.平衡二叉搜索树中的最小绝对误差</h5><h6 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        inOrder(root);        <span class="hljs-keyword">int</span>[] minAbd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cnt - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; minAbd.length; i++)&#123;            minAbd[i] = res.get(i + <span class="hljs-number">1</span>) - res.get(i);        &#125;        <span class="hljs-keyword">return</span> minOfArray(minAbd);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;            inOrder(node.left);            res.add(node.val);            cnt++;            inOrder(node.right);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minOfArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;        <span class="hljs-keyword">int</span> minValue = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> tmp : arr)&#123;            minValue = Math.min(minValue, tmp);        &#125;        <span class="hljs-keyword">return</span> minValue;    &#125;&#125;</code></pre><h5 id="993-二叉树的表兄妹节点判定"><a href="#993-二叉树的表兄妹节点判定" class="headerlink" title="993.二叉树的表兄妹节点判定"></a>993.二叉树的表兄妹节点判定</h5><h6 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs plain"></code></pre><h5 id="235-二叉搜索树的最低公共祖先-自己可以是自己的祖先"><a href="#235-二叉搜索树的最低公共祖先-自己可以是自己的祖先" class="headerlink" title="235.二叉搜索树的最低公共祖先(自己可以是自己的祖先)"></a>235.二叉搜索树的最低公共祖先(自己可以是自己的祖先)</h5><h6 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-comment">// 不在同一边，则根节点为LCA</span>        <span class="hljs-keyword">if</span> ((root.val &lt;= p.val &amp;&amp; root.val &gt;= q.val) || (root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val)) &#123;            <span class="hljs-keyword">return</span> root;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt;= Math.min(p.val, q.val))&#123; <span class="hljs-comment">//同在右边，递归右子树</span>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);        &#125;                &#125;&#125;</code></pre><h5 id="236-二叉树的最低公共祖先-自己可以是自己的祖先"><a href="#236-二叉树的最低公共祖先-自己可以是自己的祖先" class="headerlink" title="236.二叉树的最低公共祖先(自己可以是自己的祖先)"></a><code>236.二叉树的最低公共祖先(自己可以是自己的祖先)</code></h5><h6 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-comment">//root为空，返回null;</span>        <span class="hljs-comment">//p或q为当前子树的根，则LCA为p或q</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || p == root || q == root) <span class="hljs-keyword">return</span> root;                TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);                <span class="hljs-comment">//p,q分别在左右子树，左右子树的根就是LCA</span>        <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">//p,q在同一子树，要么p为LCA，要么q为LCA</span>        <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : left;    &#125;&#125;</code></pre><h5 id="572-子树判断"><a href="#572-子树判断" class="headerlink" title="572.子树判断"></a>572.子树判断</h5><h6 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode s, TreeNode t)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || t == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (s.val == t.val &amp;&amp; isSameTree(s, t)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (p.val == q.val)&#123;            <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;           &#125;&#125;</code></pre><h5 id="501-找二叉搜索树中出现次数最多的结点值集合"><a href="#501-找二叉搜索树中出现次数最多的结点值集合" class="headerlink" title="501.找二叉搜索树中出现次数最多的结点值集合"></a>501.找二叉搜索树中出现次数最多的结点值集合</h5><h6 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; inList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findMode(TreeNode root) &#123;        <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">1</span>;        inOrder(root);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k : inList)&#123;            <span class="hljs-keyword">if</span> (map.containsKey(k))&#123;                <span class="hljs-keyword">int</span> cnt = map.get(k) + <span class="hljs-number">1</span>;                map.put(k, cnt);                maxCount = Math.max(maxCount, cnt);            &#125; <span class="hljs-keyword">else</span>&#123;                map.put(k, <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[map.size()];        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> key: map.keySet())&#123;            <span class="hljs-keyword">if</span>(map.get(key) == maxCount)&#123;                result[index++] = key;            &#125;        &#125;                <span class="hljs-keyword">return</span> Arrays.copyOf(result, index);                    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;            inOrder(node.left);            inList.add(node.val);            inOrder(node.right);        &#125;    &#125;&#125;</code></pre><h5 id="1315-祖先节点中有值为偶数的节点的值之和"><a href="#1315-祖先节点中有值为偶数的节点的值之和" class="headerlink" title="1315.祖先节点中有值为偶数的节点的值之和"></a>1315.祖先节点中有值为偶数的节点的值之和</h5><h6 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumEvenGrandparent</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (root.val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; root.left != <span class="hljs-keyword">null</span>)&#123;            sum += (root.left.left != <span class="hljs-keyword">null</span> ? root.left.left.val : <span class="hljs-number">0</span>);            sum += (root.left.right != <span class="hljs-keyword">null</span> ? root.left.right.val : <span class="hljs-number">0</span>);                    &#125;        <span class="hljs-keyword">if</span> (root.val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; root.right != <span class="hljs-keyword">null</span>)&#123;            sum += (root.right.left != <span class="hljs-keyword">null</span> ? root.right.left.val : <span class="hljs-number">0</span>);            sum += (root.right.right != <span class="hljs-keyword">null</span> ? root.right.right.val : <span class="hljs-number">0</span>);        &#125;        sumEvenGrandparent(root.left);        sumEvenGrandparent(root.right);        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h5 id="1302-最底层叶子节点值和"><a href="#1302-最底层叶子节点值和" class="headerlink" title="1302.最底层叶子节点值和"></a>1302.最底层叶子节点值和</h5><h6 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h6><p><strong><em>法一（层次遍历，复杂度太高）</em></strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> cnt = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> sumLeaves = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.addLast(root);        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.pollFirst();                tmp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.addLast(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.addLast(cur.right);            &#125;            res.add(tmp);            cnt++;        &#125;        <span class="hljs-keyword">for</span> (Integer val : res.get(cnt))&#123;            sumLeaves += val;        &#125;        <span class="hljs-keyword">return</span> sumLeaves;    &#125;&#125;</code></pre><p><strong><em>法二（深度优先）</em></strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> maxDepth = -<span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        dfs(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> dp)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (dp &gt; maxDepth)&#123;                sum = node.val;                maxDepth = dp;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp == maxDepth)&#123;                sum += node.val;            &#125;        &#125;        dfs(node.left, dp + <span class="hljs-number">1</span>);        dfs(node.right, dp + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h5 id="654-给定数组构造最大二叉树"><a href="#654-给定数组构造最大二叉树" class="headerlink" title="654.给定数组构造最大二叉树"></a>654.给定数组构造最大二叉树</h5><h6 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> build_tree(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);            &#125;    <span class="hljs-function">TreeNode <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-comment">// base case</span>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// find the maximum and index of array</span>        <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>, max_val = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++)&#123;            <span class="hljs-keyword">if</span> (max_val &lt; nums[i])&#123;                max_val = nums[i];                index = i;            &#125;        &#125;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(max_val);        root.left = build_tree(nums, left, index - <span class="hljs-number">1</span>);        root.right = build_tree(nums, index + <span class="hljs-number">1</span>, right);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h5 id="1008-由先序遍历序列构造二叉搜索树"><a href="#1008-由先序遍历序列构造二叉搜索树" class="headerlink" title="1008.由先序遍历序列构造二叉搜索树"></a>1008.由先序遍历序列构造二叉搜索树</h5><h6 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">bstFromPreorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder)</span> </span>&#123;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.length; i++)&#123;            insertBST(preorder[i], root);        &#125;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val,TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span>(val &lt; node.val)&#123;            <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span>)&#123;                TreeNode node1 = <span class="hljs-keyword">new</span> TreeNode(val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                node.left = node1;            &#125;            <span class="hljs-keyword">else</span>                insertBST(val, node.left);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(node.right == <span class="hljs-keyword">null</span>)&#123;                TreeNode node1 = <span class="hljs-keyword">new</span> TreeNode(val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                node.right = node1;            &#125;            <span class="hljs-keyword">else</span>                insertBST(val, node.right);        &#125;    &#125;&#125;</code></pre><h5 id="1305-二叉搜索树中的全部元素"><a href="#1305-二叉搜索树中的全部元素" class="headerlink" title="1305.二叉搜索树中的全部元素"></a>1305.二叉搜索树中的全部元素</h5><h6 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getAllElements</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;        inOrder(root1);        inOrder(root2);        Collections.sort(res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            inOrder(root.left);            res.add(root.val);            inOrder(root.right);        &#125;    &#125;&#125;</code></pre><h5 id="701-二叉搜索树的插入"><a href="#701-二叉搜索树的插入" class="headerlink" title="701.二叉搜索树的插入"></a>701.二叉搜索树的插入</h5><h6 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);        <span class="hljs-keyword">if</span> (val &gt; root.val)&#123;            root.right = insertIntoBST(root.right, val);        &#125;        <span class="hljs-keyword">if</span> (val &lt; root.val)&#123;            root.left = insertIntoBST(root.left, val);        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h5 id="1325-基于给定值删除叶子节点（如果父节点-也为给定值-在上一次删除后成为叶子节点，也应当删除）"><a href="#1325-基于给定值删除叶子节点（如果父节点-也为给定值-在上一次删除后成为叶子节点，也应当删除）" class="headerlink" title="1325.基于给定值删除叶子节点（如果父节点(也为给定值)在上一次删除后成为叶子节点，也应当删除）"></a>1325.基于给定值删除叶子节点（如果父节点(也为给定值)在上一次删除后成为叶子节点，也应当删除）</h5><h6 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-comment">//base case</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//recursive, delete nodes before getting left and right</span>        root.left = removeLeafNodes(root.left, target);        root.right = removeLeafNodes(root.right, target);        <span class="hljs-comment">//delete leaf nodes</span>        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; root.val == target &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;            root = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> root;     &#125;&#125;</code></pre><h5 id="814-二叉树剪枝"><a href="#814-二叉树剪枝" class="headerlink" title="814.二叉树剪枝"></a>814.二叉树剪枝</h5><h6 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">//this problem equals removing leaf 0 recursively</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        root.left = pruneTree(root.left);        root.right = pruneTree(root.right);        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; root.val == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;            root = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h5 id="1104-锯齿二叉树路径"><a href="#1104-锯齿二叉树路径" class="headerlink" title="1104.锯齿二叉树路径"></a>1104.锯齿二叉树路径</h5><h6 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> dp = -<span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">pathInZigZagTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> label)</span> </span>&#123;        <span class="hljs-keyword">if</span> (label == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>&#125;);        &#125;        <span class="hljs-comment">//get corresponding depth</span>        <span class="hljs-keyword">int</span> tmp = label;        <span class="hljs-keyword">while</span> (tmp != <span class="hljs-number">0</span>)&#123;            tmp /= <span class="hljs-number">2</span>;            dp++;        &#125;        <span class="hljs-comment">//这里定义结果数组时需要使用包装类Integer, 为了Arrays.asList()能转化</span>        Integer[] reverseRes = <span class="hljs-keyword">new</span> Integer[dp + <span class="hljs-number">1</span>];        reverseRes[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (dp &gt;= <span class="hljs-number">0</span>)&#123;            reverseRes[dp] = label;            <span class="hljs-comment">//the former node.val is 2^dp + 2^(dp+1) - 1</span>            label = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>, dp - <span class="hljs-number">1</span>) + (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>, dp) - (<span class="hljs-keyword">int</span>)(label / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;            dp--;        &#125;        <span class="hljs-comment">//Arrays.asList(arr) -&gt; ArrayList</span>        <span class="hljs-keyword">return</span> Arrays.asList(reverseRes);            &#125;&#125;</code></pre><h5 id="1448-计算二叉树”好节点”的数目-从根节点到叶节点的路径中，值最大的节点就是”好节点”"><a href="#1448-计算二叉树”好节点”的数目-从根节点到叶节点的路径中，值最大的节点就是”好节点”" class="headerlink" title="1448.计算二叉树”好节点”的数目(从根节点到叶节点的路径中，值最大的节点就是”好节点”)"></a>1448.计算二叉树”好节点”的数目(从根节点到叶节点的路径中，值最大的节点就是”好节点”)</h5><h6 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">goodNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        countNodes(root, root.val);        <span class="hljs-keyword">return</span> res;       &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> maxVal)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (node.val &gt;= maxVal)&#123;            res++;            maxVal = node.val;        &#125;        countNodes(node.left, maxVal);        countNodes(node.right, maxVal);    &#125;&#125;</code></pre><h5 id="1161-二叉树的最大层和所在的最低层数"><a href="#1161-二叉树的最大层和所在的最低层数" class="headerlink" title="1161.二叉树的最大层和所在的最低层数"></a>1161.二叉树的最大层和所在的最低层数</h5><h6 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLevelSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;        <span class="hljs-comment">//记录层数</span>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> maxLevel = <span class="hljs-number">0</span>;        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.add(root);        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            <span class="hljs-comment">//每层初始计数置零</span>            <span class="hljs-keyword">int</span> levelSum = <span class="hljs-number">0</span>;            <span class="hljs-comment">//更新层数</span>            level++;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.poll();                levelSum += cur.val;                <span class="hljs-comment">//每层遍历到最后一个节点时，进行层和的比较</span>                <span class="hljs-keyword">if</span> (i == size - <span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">if</span> (levelSum &gt; max)&#123;                        max = levelSum;                        maxLevel = level;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.add(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.add(cur.right);            &#125;        &#125;        <span class="hljs-keyword">return</span> maxLevel;    &#125;&#125;</code></pre><h5 id="979-二叉树中分发硬币"><a href="#979-二叉树中分发硬币" class="headerlink" title="979.二叉树中分发硬币"></a>979.二叉树中分发硬币</h5><h6 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//将所有移动的绝对值加起来</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        help(root);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">//后序遍历，将子节点多余的硬币(无论正负)全部分给父节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> l = help(root.left);        <span class="hljs-keyword">int</span> r = help(root.right);        <span class="hljs-comment">//当前结点硬币拥有数目</span>        <span class="hljs-keyword">int</span> total = l + r + root.val;        <span class="hljs-comment">//向上分发次数累加</span>        res += Math.abs(total - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> total - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h5 id="1026-二叉树中结点和祖先结点的最大差值"><a href="#1026-二叉树中结点和祖先结点的最大差值" class="headerlink" title="1026.二叉树中结点和祖先结点的最大差值"></a>1026.二叉树中结点和祖先结点的最大差值</h5><h6 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDiff = Integer.MIN_VALUE;    <span class="hljs-comment">//找每条路径上的最大值和最小值，再对其差值求最大</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxAncestorDiff</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> dfs(root, root.val, root.val);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> max - min;        max = Math.max(max, node.val);        min = Math.min(min, node.val);        <span class="hljs-keyword">int</span> lf = dfs(node.left, min, max);        <span class="hljs-keyword">int</span> rt = dfs(node.right, min, max);        <span class="hljs-keyword">return</span> Math.max(lf ,rt);    &#125;        &#125;</code></pre><h5 id="1110-删除二叉树的若干节点，返回森林"><a href="#1110-删除二叉树的若干节点，返回森林" class="headerlink" title="1110.删除二叉树的若干节点，返回森林"></a>1110.删除二叉树的若干节点，返回森林</h5><h6 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    ArrayList&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">delNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span>[] to_delete)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || to_delete.length == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-comment">//HashSet记录要删除的节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : to_delete)&#123;            set.add(val);        &#125;        <span class="hljs-comment">//根节点若不在删除范围内，则也是返回内容之一</span>        <span class="hljs-keyword">if</span> (!set.contains(root.val))&#123;            res.add(root);        &#125;        dfs(root, set);        <span class="hljs-keyword">return</span> res;            &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, HashSet&lt;Integer&gt; delSet)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//重新构建树</span>        node.left = dfs(node.left, delSet);        node.right = dfs(node.right, delSet);        <span class="hljs-keyword">if</span> (delSet.contains(node.val))&#123;            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;                res.add(node.left);            &#125;            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;                res.add(node.right);            &#125;            <span class="hljs-comment">//删除节点</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//保留节点</span>        <span class="hljs-keyword">return</span> node;    &#125;&#125;</code></pre><h5 id="889-根据先序遍历和后序遍历序列构建二叉树-不唯一"><a href="#889-根据先序遍历和后序遍历序列构建二叉树-不唯一" class="headerlink" title="889.根据先序遍历和后序遍历序列构建二叉树(不唯一)"></a>889.根据先序遍历和后序遍历序列构建二叉树(不唯一)</h5><h6 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h6><p><a href="https://blog.csdn.net/qq_37767455/article/details/96190238">解题思路</a></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre, <span class="hljs-keyword">int</span>[] post)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = pre.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(pre[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">if</span> (post[i] == pre[<span class="hljs-number">1</span>])&#123;                left = i + <span class="hljs-number">1</span>;            &#125;        &#125;        root.left = constructFromPrePost(Arrays.copyOfRange(pre, <span class="hljs-number">1</span>, left + <span class="hljs-number">1</span>), Arrays.copyOfRange(post, <span class="hljs-number">0</span>, left));        root.right = constructFromPrePost(Arrays.copyOfRange(pre, left + <span class="hljs-number">1</span>, n), Arrays.copyOfRange(post, left, n - <span class="hljs-number">1</span>));        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h5 id="1130-固定叶子节点的最小代价-非叶子节点值和-树"><a href="#1130-固定叶子节点的最小代价-非叶子节点值和-树" class="headerlink" title="1130.固定叶子节点的最小代价(非叶子节点值和)树"></a>1130.固定叶子节点的最小代价(非叶子节点值和)树</h5><ul><li>arr给出的叶子节点的顺序为构建出的二叉树中序遍历的顺序</li><li>每个非叶节点的值分别等于其左子树和右子树中最大叶值的乘积</li><li>每个节点有0或2个孩子</li></ul><h6 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"></code></pre><h5 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h5><h6 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">    public int val;</span><span class="hljs-comment">    public List&lt;Node&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Deque&lt;Node&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.addLast(root);        <span class="hljs-keyword">while</span> (!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                Node cur = q.pollFirst();                tmp.add(cur.val);                <span class="hljs-keyword">if</span> (cur.children != <span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-keyword">for</span> (Node d : cur.children)&#123;                        q.addLast(d);                    &#125;                &#125;            &#125;            res.add(tmp);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h5><h6 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        helper(root);        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;                helper(node.left);            &#125;            res.add(node.val);            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;                helper(node.right);            &#125;        &#125;            &#125;&#125;</code></pre><h5 id="951-翻转等效二叉树"><a href="#951-翻转等效二叉树" class="headerlink" title="951.翻转等效二叉树"></a>951.翻转等效二叉树</h5><p>定义翻转操作为：选择任意节点，并交换左右子树</p><p>等效的定义：当且仅当在一定数量的翻转操作之后我们可以使X等于Y时，二叉树X才等效于二叉树Y。</p><h6 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">flipEquiv</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(root1, root2);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode p, TreeNode q)</span></span>&#123;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || q == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (p.val == q.val)&#123;            <span class="hljs-keyword">return</span> dfs(p.left, q.left) &amp;&amp; dfs(p.right, q.right) || dfs(p.left, q.right) &amp;&amp; dfs(p.right, q.left);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h5 id="669-根据范围修剪二叉搜索树"><a href="#669-根据范围修剪二叉搜索树" class="headerlink" title="669.根据范围修剪二叉搜索树"></a>669.根据范围修剪二叉搜索树</h5><h6 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">//修剪全部发生在左子树</span>        <span class="hljs-keyword">if</span> (root.val &gt; high)&#123;            <span class="hljs-keyword">return</span> trimBST(root.left, low, high);        &#125;        <span class="hljs-comment">//修剪全部发生在右子树</span>        <span class="hljs-keyword">if</span> (root.val &lt; low)&#123;            <span class="hljs-keyword">return</span> trimBST(root.right, low, high);        &#125;        <span class="hljs-comment">//左右子树都要修剪</span>        root.left = trimBST(root.left, low, high);        root.right = trimBST(root.right, low, high);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h5 id="513-获取最后一层最左的叶子节点"><a href="#513-获取最后一层最左的叶子节点" class="headerlink" title="513.获取最后一层最左的叶子节点"></a>513.获取最后一层最左的叶子节点</h5><h6 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<span class="hljs-comment">//     //层次遍历，复杂度过高</span><span class="hljs-comment">//     int depth = 0;</span><span class="hljs-comment">//     List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><span class="hljs-comment">//     public int findBottomLeftValue(TreeNode root) &#123;</span><span class="hljs-comment">//         HashMap&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;();</span><span class="hljs-comment">//         Deque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();</span><span class="hljs-comment">//         q.addLast(root);</span><span class="hljs-comment">//         while(!q.isEmpty())&#123;</span><span class="hljs-comment">//             int size = q.size();</span><span class="hljs-comment">//             List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><span class="hljs-comment">//             for (int i = 0; i &lt; size; i++)&#123;</span><span class="hljs-comment">//                 TreeNode cur = q.pollFirst();</span><span class="hljs-comment">//                 tmp.add(cur.val);</span><span class="hljs-comment">//                 if (cur.left != null) q.addLast(cur.left);</span><span class="hljs-comment">//                 if (cur.right != null) q.addLast(cur.right);</span><span class="hljs-comment">//             &#125;</span><span class="hljs-comment">//             res.add(tmp);</span><span class="hljs-comment">//             depth++;</span><span class="hljs-comment">//         &#125;</span><span class="hljs-comment">//         return res.get(res.size() - 1).get(0);</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">//DFS</span>    <span class="hljs-keyword">int</span> prevlevel = Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-comment">//只有一个根节点，直接返回根结点的值</span>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.val;         <span class="hljs-comment">//left记录当前层最左节点的值</span>        <span class="hljs-keyword">int</span> left = root.val;        <span class="hljs-comment">//记录层数</span>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;;        <span class="hljs-keyword">return</span> helper(root, left, level);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> left;        left = helper(root.left, left, level + <span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span> (level &gt; prevlevel)&#123;            prevlevel = level;            left = root.val;        &#125;                left = helper(root.right, left, level + <span class="hljs-number">1</span>);                <span class="hljs-keyword">return</span> left;    &#125;&#125;</code></pre><h5 id="515-找到二叉树每层值最大的节点"><a href="#515-找到二叉树每层值最大的节点" class="headerlink" title="515.找到二叉树每层值最大的节点"></a>515.找到二叉树每层值最大的节点</h5><h6 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        q.offerLast(root);        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = q.size();            <span class="hljs-keyword">int</span> maxVal = Integer.MIN_VALUE;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;                TreeNode cur = q.pollFirst();                maxVal = Math.max(maxVal, cur.val);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) q.offerLast(cur.left);                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) q.offerLast(cur.right);            &#125;            res.add(maxVal);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h5 id="173-为二叉搜索树构建迭代器"><a href="#173-为二叉搜索树构建迭代器" class="headerlink" title="173.为二叉搜索树构建迭代器"></a>173.为二叉搜索树构建迭代器</h5><p>用栈实现中序遍历</p><h6 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;    Deque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        leftTraverse(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftTraverse</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)&#123;            q.offerFirst(node);            node = node.left;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        TreeNode cur = q.pollFirst();        <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)&#123;            leftTraverse(cur.right);        &#125;        <span class="hljs-keyword">return</span> cur.val;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> q.size() &gt; <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><span class="hljs-comment"> * BSTIterator obj = new BSTIterator(root);</span><span class="hljs-comment"> * int param_1 = obj.next();</span><span class="hljs-comment"> * boolean param_2 = obj.hasNext();</span><span class="hljs-comment"> */</span></code></pre><h5 id="538-将二叉搜索树转化为Greater树"><a href="#538-将二叉搜索树转化为Greater树" class="headerlink" title="538.将二叉搜索树转化为Greater树"></a>538.将二叉搜索树转化为Greater树</h5><h6 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h6><p>Greater树特性：原始BST的每个键都变成原始键加上BST中所有大于原始键的键的和</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        traverse(root);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        traverse(node.right);        sum += node.val;        node.val = sum;        traverse(node.left);    &#125;&#125;</code></pre><h5 id="508-最频繁出现的子树和"><a href="#508-最频繁出现的子树和" class="headerlink" title="508.最频繁出现的子树和"></a>508.最频繁出现的子树和</h5><h6 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;        helper(root);        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++)&#123;            arr[i] = res.get(i);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> leftSum = helper(root.left);            <span class="hljs-keyword">int</span> rightSum = helper(root.right);                        <span class="hljs-keyword">int</span> curSum = leftSum + rightSum + root.val;            <span class="hljs-keyword">int</span> freq =  map.getOrDefault(curSum, <span class="hljs-number">0</span>);            map.put(curSum, freq + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(freq + <span class="hljs-number">1</span> &gt; max) &#123;                 res.clear();                 res.add(curSum);                 max = freq + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(freq + <span class="hljs-number">1</span> == max) &#123;                res.add(curSum);            &#125;            <span class="hljs-keyword">return</span> curSum;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h5 id="863-二叉树中与目标节点距离为K的所有节点"><a href="#863-二叉树中与目标节点距离为K的所有节点" class="headerlink" title="863.二叉树中与目标节点距离为K的所有节点"></a>863.二叉树中与目标节点距离为K的所有节点</h5><h6 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;TreeNode, TreeNode&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    Set&lt;TreeNode&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode root, TreeNode target, <span class="hljs-keyword">int</span> K)</span> </span>&#123;        map.put(root, <span class="hljs-keyword">null</span>);        getParent(root.left, root);        getParent(root.right, root);        dfs(target, visited, <span class="hljs-number">0</span>, K);        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode target, Set&lt;TreeNode&gt; visited, <span class="hljs-keyword">int</span> curDist, <span class="hljs-keyword">int</span> targetDist)</span></span>&#123;        <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span> || visited.contains(target) || curDist &gt; targetDist)&#123;            <span class="hljs-keyword">return</span>;        &#125;        visited.add(target);        <span class="hljs-keyword">if</span> (curDist == targetDist)&#123;            res.add(target.val);        &#125;        <span class="hljs-comment">//parent</span>        dfs(map.get(target), visited, curDist + <span class="hljs-number">1</span>, targetDist);        <span class="hljs-comment">//left</span>        dfs(target.left, visited, curDist + <span class="hljs-number">1</span>, targetDist);        <span class="hljs-comment">//right</span>        dfs(target.right, visited, curDist + <span class="hljs-number">1</span>, targetDist);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getParent</span><span class="hljs-params">(TreeNode child, TreeNode parent)</span></span>&#123;        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        map.put(child, parent);        <span class="hljs-keyword">if</span> (child.left != <span class="hljs-keyword">null</span>) &#123;            getParent(child.left, child);        &#125;        <span class="hljs-keyword">if</span> (child.right != <span class="hljs-keyword">null</span>)&#123;            getParent(child.right, child);        &#125;    &#125;    &#125;</code></pre><h5 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h5><h6 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span>    <span class="hljs-comment">//     if (root == null) return res;</span>    <span class="hljs-comment">//     Deque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();</span>    <span class="hljs-comment">//     q.offerLast(root);</span>    <span class="hljs-comment">//     while (!q.isEmpty())&#123;</span>    <span class="hljs-comment">//         int size = q.size();</span>    <span class="hljs-comment">//         List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span>    <span class="hljs-comment">//         for (int i = 0; i &lt; size; i++)&#123;</span>    <span class="hljs-comment">//             TreeNode cur = q.pollFirst();</span>    <span class="hljs-comment">//             tmp.add(cur.val);</span>    <span class="hljs-comment">//             if (cur.left != null) q.offerLast(cur.left);</span>    <span class="hljs-comment">//             if (cur.right != null) q.offerLast(cur.right);</span>    <span class="hljs-comment">//         &#125;</span>    <span class="hljs-comment">//         res.add(tmp.get(tmp.size() - 1));</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     return res;</span>    <span class="hljs-comment">// &#125;</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;        helper(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (level == res.size())&#123;            res.add(node.val);        &#125;        helper(node.right, level + <span class="hljs-number">1</span>);        helper(node.left, level + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h5 id="1530-距离小于等于K的叶子节点对数"><a href="#1530-距离小于等于K的叶子节点对数" class="headerlink" title="1530.距离小于等于K的叶子节点对数"></a>1530.距离小于等于K的叶子节点对数</h5><h6 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"></code></pre><h5 id="1372-二叉树中最长的ZigZag路径"><a href="#1372-二叉树中最长的ZigZag路径" class="headerlink" title="1372.二叉树中最长的ZigZag路径"></a>1372.二叉树中最长的ZigZag路径</h5><h6 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestZigZag</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>) &#123;            dfs(root.left, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>) &#123;            dfs(root.right, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-comment">// 0 for left, 1 for right, direction for the last one</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode cur, <span class="hljs-keyword">int</span> direction, <span class="hljs-keyword">int</span> cnt)</span></span>&#123;        res = Math.max(res, cnt);        <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)&#123;            dfs(cur.left, <span class="hljs-number">0</span>, (direction == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span>: (cnt + <span class="hljs-number">1</span>));        &#125;        <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)&#123;            dfs(cur.right, <span class="hljs-number">1</span>, (direction == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span>: (cnt + <span class="hljs-number">1</span>));        &#125;    &#125;        &#125;</code></pre><h5 id="1443-收集所有苹果的最短时间"><a href="#1443-收集所有苹果的最短时间" class="headerlink" title="1443.收集所有苹果的最短时间"></a>1443.收集所有苹果的最短时间</h5><h6 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"></code></pre><h5 id="96-结构唯一的二叉搜索树的个数"><a href="#96-结构唯一的二叉搜索树的个数" class="headerlink" title="96.结构唯一的二叉搜索树的个数"></a><code>96.结构唯一的二叉搜索树的个数</code></h5><p>要找出所有二叉搜索树，可用动态规划的思想</p><ul><li>以1 … n 为节点组成的二叉搜索树，不同的树在于根结点的不同和左右子树的不同<ul><li>根结点不同，可能有n种情况，以1为根结点，以2为根结点…类推到以n为根结点，共有n种情况.</li><li>区分了根节点不同后，剩下的就是左右子树不同了，而左右子树的不同二叉树则是一个相同的问题，比如收当前有n个结点，以第k个元素作为根结点，那么左子树有k-1个元素，它是一个规模为k-1的子问题，而右子树有n-k个结点，它也是一个规模为n-k的子问题</li></ul></li></ul><h6 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;        <span class="hljs-comment">//dp[i]为给定整数i，结构唯一的二叉搜索树的个数</span>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;                dp[i] += dp [j - <span class="hljs-number">1</span>] * dp[i - j];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h5 id="437-路径和Ⅲ"><a href="#437-路径和Ⅲ" class="headerlink" title="437.路径和Ⅲ"></a>437.路径和Ⅲ</h5><h6 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h6><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//每个节点做根节点的子树</span>        <span class="hljs-keyword">return</span> dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode cur, <span class="hljs-keyword">int</span> rest)</span></span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//路径和满足</span>        <span class="hljs-keyword">if</span> (rest == cur.val) &#123;            res++;        &#125;                res += dfs(cur.left, rest - cur.val);        res += dfs(cur.right, rest - cur.val);        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础知识</title>
    <link href="/2021/01/15/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/01/15/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h2><p>NoSQL = Not Only SQL，泛指非关系型数据库。</p><h3 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h3><ul><li>新浪(Redis)</li><li>美团(Redis + Tair)</li><li>阿里、百度(Redis + memecache)</li></ul><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><ul><li>MongoDB —— MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档。MongoDB是一个介于关系型数据库和非关系型数据库中间的产品。MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的一个。</li><li>ConthDB</li></ul><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><ul><li>HBase</li><li>分布式文件系统</li></ul><h3 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a>图关系数据库</h3><ul><li>NEO4J</li></ul><h2 id="Redis-Remote-Dictionary-Server"><a href="#Redis-Remote-Dictionary-Server" class="headerlink" title="Redis(Remote Dictionary Server)"></a>Redis(Remote Dictionary Server)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li><li>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</li><li>免费和开源，是当下最热门的NoSQL技术之一，也被人们称之为结构化数据库。</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Redis可用作<code>数据库、缓存和消息中间件MQ</code>。具体用途如下：</p><ul><li>内存存储并持久化（RDB和AOF）</li><li>效率高，可用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器，计数器（如记录浏览量）</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Redis官方推荐在Linux服务器上搭建。</p><p>Redis是<code>单线程</code>的，它很快，<code>基于内存操作</code>。</p><p>CPU不是Redis的性能瓶颈，Redis的瓶颈是机器的内存和网络带宽。</p><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul><p><code>为什么Redis采用单线程还这么快？</code></p><p>Redis是<code>将所有的数据全部放到内存</code>中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的。多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案。</p><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><p><a href="https://www.runoob.com/redis/redis-install.html">Redis安装(菜鸟教程)</a></p><h2 id="客户端连接Redis"><a href="#客户端连接Redis" class="headerlink" title="客户端连接Redis"></a>客户端连接Redis</h2><pre><code class="hljs shell">redis-cli.exe -h 127.0.0.1 -p 6379</code></pre><h2 id="Redis压力测试"><a href="#Redis压力测试" class="headerlink" title="Redis压力测试"></a>Redis压力测试</h2><p>100000个写入请求，100个并发客户端</p><pre><code class="hljs shell">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre><h2 id="Redis基本知识"><a href="#Redis基本知识" class="headerlink" title="Redis基本知识"></a>Redis基本知识</h2><p>Redis有16个数据库，默认使用第0个，可以使用select进行切换。</p><p><code>基本指令</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">keys *</td><td style="text-align:center">查看数据库所有的key</td></tr><tr><td style="text-align:center">flushdb</td><td style="text-align:center">清空当前数据库</td></tr><tr><td style="text-align:center">flushall</td><td style="text-align:center">清空所有数据库</td></tr><tr><td style="text-align:center">set [key] [value]</td><td style="text-align:center">设置键值对，重复设置一个键会将原来的值给覆盖掉</td></tr><tr><td style="text-align:center">get [key]</td><td style="text-align:center">通过键名获取值</td></tr><tr><td style="text-align:center">EXISTS [key]</td><td style="text-align:center">检查键是否存在</td></tr><tr><td style="text-align:center">move [key] [0-15]</td><td style="text-align:center">将键移动到某个数据库</td></tr><tr><td style="text-align:center">expire [key] [time]</td><td style="text-align:center">将键设置为n秒后过期</td></tr><tr><td style="text-align:center">ttl [key]</td><td style="text-align:center">查看键剩余存活时间</td></tr><tr><td style="text-align:center">type [key]</td><td style="text-align:center">查看键类型</td></tr></tbody></table></div><h2 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>ps：value除了字符串还可以是数字</p><p><code>使用场景</code></p><ul><li>计数器</li><li>统计多单位的数目</li><li>对象缓存存储</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>append [key] [value]</code></td><td style="text-align:center">在键上追加值，若此键不存在，相当于set命令</td></tr><tr><td style="text-align:center"><code>strlen [key]</code></td><td style="text-align:center"><code>获取键的值的长度</code></td></tr><tr><td style="text-align:center"><code>incr [key]</code></td><td style="text-align:center">键的值加1</td></tr><tr><td style="text-align:center"><code>decr [key]</code></td><td style="text-align:center">键的值减1</td></tr><tr><td style="text-align:center"><code>incrby [key] [step]</code></td><td style="text-align:center">键的值加n</td></tr><tr><td style="text-align:center"><code>decrby [key] [step]</code></td><td style="text-align:center">键的值减n</td></tr><tr><td style="text-align:center"><code>getrange [key] [start] [end]</code></td><td style="text-align:center"><code>截取字符串。getrange [key] 0 -1 等同get命令</code></td></tr><tr><td style="text-align:center"><code>setrange [key] [location] [value]</code></td><td style="text-align:center">从指定位置开始替换</td></tr><tr><td style="text-align:center"><code>setex [key] [time] [value]</code></td><td style="text-align:center">可理解为set和expire连用</td></tr><tr><td style="text-align:center"><code>setnx [key] [value]</code></td><td style="text-align:center">若键不存在，创建并设置值（分布式锁中常用）</td></tr><tr><td style="text-align:center"><code>mset [key1] [value1] [key2] [value2]......</code></td><td style="text-align:center"><code>批量设置</code></td></tr><tr><td style="text-align:center"><code>mget[key1] [key2]......</code></td><td style="text-align:center"><code>批量取值</code></td></tr><tr><td style="text-align:center"><code>msetnx [key1] [value1] [key2] [value2]......</code></td><td style="text-align:center">若键不存在，创建并设置值（批量），具有原子性（若其中一个设置失败则整体失败）</td></tr><tr><td style="text-align:center"><code>getset [key] [value]</code></td><td style="text-align:center"><code>先get，返回get到的值，将value覆盖原有值</code></td></tr></tbody></table></div><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><code>特点</code></p><ul><li>值有序</li><li>可重</li><li>指令首的”l”含义：除了push和pop操作代表头尾的意思，其他都是list的意思</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>lpush [listname] [value]</code></td><td style="text-align:center">往列表头部插入数据</td></tr><tr><td style="text-align:center"><code>lrange [listname] [range(0 1)]</code></td><td style="text-align:center"><code>获取列表中某个范围的值（获取列表中第0和第1个值）</code></td></tr><tr><td style="text-align:center"><code>rpush [listname] [value]</code></td><td style="text-align:center">往列表尾部插入数据</td></tr><tr><td style="text-align:center"><code>lpop [listname]</code></td><td style="text-align:center">移除列表头元素</td></tr><tr><td style="text-align:center"><code>rpop [listname]</code></td><td style="text-align:center">移除列表尾元素</td></tr><tr><td style="text-align:center"><code>lindex [listname] [index]</code></td><td style="text-align:center"><code>通过下标获取值</code></td></tr><tr><td style="text-align:center"><code>llen [listname]</code></td><td style="text-align:center"><code>获取列表长度</code></td></tr><tr><td style="text-align:center"><code>lrem [listname] [count] [value]</code></td><td style="text-align:center">移除n个重复的指定值</td></tr><tr><td style="text-align:center"><code>ltrim [listname] [range(1 2)]</code></td><td style="text-align:center"><code>截取范围内值（截取列表中第1和第2个值）（注：原list将被改变，未被截取到的数据将被删除）</code></td></tr><tr><td style="text-align:center"><code>rpoplpush [source] [destination]</code></td><td style="text-align:center">移除列表的最后一个元素并将其插入另一个列表的头部</td></tr><tr><td style="text-align:center"><code>lset [listname] [index] [value]</code></td><td style="text-align:center"><code>修改下标值</code></td></tr><tr><td style="text-align:center"><code>exist [listname]</code></td><td style="text-align:center"><code>判断某列表是否存在</code></td></tr><tr><td style="text-align:center">`linsert [listname] [before</td><td style="text-align:center">after] [value] [value]`</td><td><code>在某个值的前面/后面插入值</code></td></tr></tbody></table></div><p><code>底层实现</code>：快速链表</p><p><code>使用场景</code>：消息队列、栈</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>特点</code></p><ul><li>值无序</li><li>不可重复</li><li>指令首”s”的含义：代表set</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>sadd [setname] [value]</code></td><td style="text-align:center">往集合中添加值</td></tr><tr><td style="text-align:center"><code>smembers [setname]</code></td><td style="text-align:center">查看某集合</td></tr><tr><td style="text-align:center"><code>sismember [setname] [value]</code></td><td style="text-align:center"><code>判断集合中是否存在该值</code>（返回0表示不存在，返回1表示存在）</td></tr><tr><td style="text-align:center"><code>scard [setname]</code></td><td style="text-align:center"><code>获取集合元素个数</code></td></tr><tr><td style="text-align:center"><code>srem [setname] [value]</code></td><td style="text-align:center">移除集合中的指定元素</td></tr><tr><td style="text-align:center"><code>srandmember [setname]</code></td><td style="text-align:center">随机取出一个元素</td></tr><tr><td style="text-align:center"><code>srandmember [setname] [count]</code></td><td style="text-align:center"><code>随机取出若干个元</code></td></tr><tr><td style="text-align:center"><code>spop [setname]</code></td><td style="text-align:center">移除一个元素</td></tr><tr><td style="text-align:center"><code>smove [source] [destination] [value]</code></td><td style="text-align:center"><code>移除列表的一个指定元素并将其添加到另一个集合</code></td></tr><tr><td style="text-align:center"><code>diff [set1] [set2]</code></td><td style="text-align:center">找出属于set1但不属于set2的元素（<code>求差集</code>）</td></tr><tr><td style="text-align:center"><code>sinter [set1] [set2]</code></td><td style="text-align:center"><code>求交集</code></td></tr><tr><td style="text-align:center"><code>sunion [set1] [set2]</code></td><td style="text-align:center"><code>求并集</code></td></tr></tbody></table></div><p><code>使用场景</code></p><ul><li>集合操作(交、并、差)</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><code>使用场景</code></p><ul><li>对象存储</li><li>经常变更的K-V数据，例如用户信息</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>hset [hashname] [key] [value]</code></td><td style="text-align:center">存键值对</td></tr><tr><td style="text-align:center"><code>hget [hashname] [key]</code></td><td style="text-align:center">由键取值</td></tr><tr><td style="text-align:center"><code>hmset [hashname] [key1] [value1] [key2][value2]......</code></td><td style="text-align:center">批量存键值对</td></tr><tr><td style="text-align:center"><code>hmget [hashname] [key1] [key2]......</code></td><td style="text-align:center">根据键批量取值</td></tr><tr><td style="text-align:center"><code>hgetall [hashname]</code></td><td style="text-align:center"><code>获取所有键值对</code></td></tr><tr><td style="text-align:center"><code>hdel [hashname] [key]</code></td><td style="text-align:center"><code>删除指定键值对</code></td></tr><tr><td style="text-align:center"><code>hlen [hashname]</code></td><td style="text-align:center"><code>获取哈希表长度（即有几个键值对）</code></td></tr><tr><td style="text-align:center"><code>hexist [hashname] [key]</code></td><td style="text-align:center">判断表中键值对是否存在（返回0表示不存在，返回1表示存在）</td></tr><tr><td style="text-align:center"><code>hkeys [hashname]</code></td><td style="text-align:center"><code>获取表中所有的key</code></td></tr><tr><td style="text-align:center"><code>hvals [hashname]</code></td><td style="text-align:center"><code>获取表中所有的value</code></td></tr><tr><td style="text-align:center"><code>hincrby [hashname] [key] [increase]</code></td><td style="text-align:center">将key对应的value增加若干大小（可通过负数实现减少）</td></tr><tr><td style="text-align:center"><code>hsetnx [hashname] [key] [value]</code></td><td style="text-align:center"><code>若键不存在，创建并设置值</code></td></tr></tbody></table></div><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p><code>特点</code></p><ul><li>在set基础上增加排序权重</li><li>有序集合</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>zadd [setname] [score] [value]</code></td><td style="text-align:center">往集合中添加值</td></tr><tr><td style="text-align:center"><code>zrange [setname] [range(0 1)]</code></td><td style="text-align:center">获取集合中某个范围的值（获取集合中第0和第1个值）</td></tr><tr><td style="text-align:center"><code>zrangebyscore [setname] -inf +inf</code></td><td style="text-align:center"><code>按分数从小到大获取集合中的值</code></td></tr><tr><td style="text-align:center"><code>zrevrangebyscore [setname] +inf -inf</code></td><td style="text-align:center"><code>按分数从大到小获取集合中的值</code></td></tr><tr><td style="text-align:center"><code>zrangebyscore [setname] -inf +inf withscores</code></td><td style="text-align:center"><code>按分数从小到大获取集合中的值并显示分数</code></td></tr><tr><td style="text-align:center"><code>zrem [setname] [value]</code></td><td style="text-align:center">移除集合中的指定元素</td></tr><tr><td style="text-align:center"><code>zcard [setname]</code></td><td style="text-align:center"><code>获取集合元素个数</code></td></tr><tr><td style="text-align:center"><code>zcount [setname] [scorerange(1 3)]</code></td><td style="text-align:center"><code>某分数范围内的值的个数（分数在[1,3]范围内的值的个数）</code></td></tr></tbody></table></div><h2 id="Redis三种特殊数据类型"><a href="#Redis三种特殊数据类型" class="headerlink" title="Redis三种特殊数据类型"></a>Redis三种特殊数据类型</h2><h3 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h3><p>底层基于<code>Zset</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>geoadd [key] [longitude] [latitude] [cityname]</code></td><td style="text-align:center"><code>添加地理位置（经纬度）</code></td></tr><tr><td style="text-align:center"><code>geopos [key] [cityname]</code></td><td style="text-align:center"><code>获取指定城市的地理位置</code></td></tr><tr><td style="text-align:center"><code>geodist [key] [cityname1] [cityname2] [unit]</code></td><td style="text-align:center"><code>查询两地的直线距离（默认单位为米）</code></td></tr><tr><td style="text-align:center"><code>georadius [key] [longitude] [latitude] [radius] [unit] [count]</code></td><td style="text-align:center">以某处为中心查询其方圆若干（单位）的城市（可限制显示数量）</td></tr><tr><td style="text-align:center"><code>georadius [key] [longitude] [latitude] [radius] [unit]    withdist [count]</code></td><td style="text-align:center">以某处为中心查询其方圆若干（单位）的城市（带直线距离）</td></tr><tr><td style="text-align:center"><code>georadius [key] [longitude] [latitude] [radius] [unit]    withcoord    [count]</code></td><td style="text-align:center">以某处为中心查询其方圆若干（单位）的城市（带经纬度）</td></tr><tr><td style="text-align:center"><code>georadiusbymember [key] [cityname] [radius] [unit]</code></td><td style="text-align:center">以某城市为中心查询其方圆若干（单位）的城市</td></tr><tr><td style="text-align:center"><code>geohash [key] [cityname]</code></td><td style="text-align:center">返回城市的哈希值（二维的经纬度转换成一维的字符串，两个字符串显示越靠近说明两地距离越接近）</td></tr></tbody></table></div><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p><code>概述</code></p><p>它是用作基数统计的算法。基数计算（cardinality counting）指的是统计一批数据中的不重复元素的个数。</p><p><code>应用场景</code></p><ul><li>网页的UV（用户访问量），同一个人访问网站多次，视为一次访问</li></ul><p><code>优点</code></p><p>占用的内存是固定的，264个不同元素的数据，只需要废12KB内存。所以如果要从内存角度来比较的话，Hyperloglog是首选。</p><p><code>缺点</code></p><p>具有0.81%的错误率</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>pfadd [key] [value1] [value2]......</code></td><td style="text-align:center">存放数据</td></tr><tr><td style="text-align:center"><code>pfcount [key]</code></td><td style="text-align:center"><code>统计元素数量</code></td></tr><tr><td style="text-align:center"><code>pfmerge [newkey] [key1] [key2]......</code></td><td style="text-align:center"><code>合并若干key到一个新的key</code></td></tr></tbody></table></div><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p><code>概述</code></p><p>位图，即位存储，操作二进制位来进行记录，只有0和1两个状态。</p><p><code>应用场景</code></p><p>用户状态统计。用户活跃度，登录状态，打卡记录。拥有两个状态的用户信息的存储都可以用Bitmap。</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>setbit [key] [offset] [value]</code></td><td style="text-align:center">存值</td></tr><tr><td style="text-align:center"><code>getbit [key] [offset]</code></td><td style="text-align:center">取值</td></tr><tr><td style="text-align:center"><code>bitcount [key]</code></td><td style="text-align:center"><code>统计1的个数</code></td></tr></tbody></table></div><h2 id="Redis基本事务操作"><a href="#Redis基本事务操作" class="headerlink" title="Redis基本事务操作"></a>Redis基本事务操作</h2><p><strong>Redis单条命令是保证原子性的，但是它的事务不保证原子性！</strong></p><p><code>Redis事务本质</code></p><p>一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照一次性、顺序性、排他性等原则执行一系列的命令！</p><p><strong>Redis事务没有隔离级别的概念！</strong></p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！<strong>Exec</strong></p><p><code>事务</code></p><ul><li>开启事务 —— multi</li><li>命令入队 —— 一系列命令</li><li>执行事务 —— exec</li><li>放弃事务 —— discard</li></ul><p><code>异常</code></p><ul><li>编译型异常 —— 命令使用错误，事务中其他命令都不会被执行</li><li>运行时异常 —— 命令没有语法错误，但是运行时产生错误，除了报错的命令外，事务中其他命令依然会被执行</li></ul><h2 id="Redis监控——悲观锁和乐观锁"><a href="#Redis监控——悲观锁和乐观锁" class="headerlink" title="Redis监控——悲观锁和乐观锁"></a>Redis监控——悲观锁和乐观锁</h2><p><code>悲观锁</code> —— 认为什么时候都可能出现问题，因此无论做什么都加锁</p><p><code>乐观锁(常用)</code> —— 认为什么时候不会出现问题，不会对任何操作上锁。只会更新数据的时候去判断一下，在此期间是否有人修改过这个数据，步骤如下：</p><ul><li>获取version （<code>watch</code> data）</li><li>更新时比对version，若version发生变动，则告诉事务，事务执行失败，执行失败后先<code>unwatch data</code>，再<code>watch data</code>更新version</li></ul><h2 id="Jedis-——-Java连接开发工具"><a href="#Jedis-——-Java连接开发工具" class="headerlink" title="Jedis —— Java连接开发工具"></a>Jedis —— Java连接开发工具</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="1-导入包"><a href="#1-导入包" class="headerlink" title="1. 导入包"></a>1. 导入包</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2-连接Redis"><a href="#2-连接Redis" class="headerlink" title="2.连接Redis"></a>2.连接Redis</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.redis;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJedis</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);        System.out.println(jedis.ping());    &#125;&#125;</code></pre><h4 id="3-关闭连接"><a href="#3-关闭连接" class="headerlink" title="3.关闭连接"></a>3.关闭连接</h4><pre><code class="hljs java">jedis.close();</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.redis;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.Transaction;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTransaction</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);        jedis.flushDB();        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;caoyusang&quot;</span>);        jsonObject.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">23</span>);        String result = jsonObject.toString();        System.out.println(result);        <span class="hljs-comment">// 开启事务</span>        Transaction multi = jedis.multi();        <span class="hljs-comment">// jedis.watch(result); // 开启监控——乐观锁</span>        <span class="hljs-keyword">try</span> &#123;            multi.set(<span class="hljs-string">&quot;user1&quot;</span>, result);            multi.lpush(<span class="hljs-string">&quot;list&quot;</span>,result);<span class="hljs-comment">//            int i= 1 / 0;  // 代码出现异常，执行失败！</span>            multi.exec();   <span class="hljs-comment">// 执行事务</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            multi.discard();    <span class="hljs-comment">// 放弃事务</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));            System.out.println(jedis.lpop(<span class="hljs-string">&quot;list&quot;</span>));            jedis.close();  <span class="hljs-comment">// 关闭连接</span>        &#125;    &#125;&#125;</code></pre><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>SpringBoot操作数据：spring-data (jpa jdbc mongodb redis elasticsearch)！</p><p>SpringBoot2.x之后，原来使用的Jedis被替换为了lettuce。</p><p><code>Jedis</code>：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool 连接池！ 更像 BIO 模式</p><p><code>lettuce</code>： 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(</span><span class="hljs-meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span><span class="hljs-meta">)</span>    <span class="hljs-comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span><span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;    <span class="hljs-comment">// 默认的RedisTemplate 没有过多的设置，redis对象都是需要序列化的！</span>    <span class="hljs-comment">// 两个泛型都是object，object的类型，我们后续使用需要强制转换成&lt;String,object&gt;</span>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>    <span class="hljs-comment">// 由于String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span><span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;</code></pre><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h3><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre><h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.config;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span></span>&#123;        <span class="hljs-comment">// 为了自己开发方便，一般直接使用&lt;String,Object&gt;</span>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        <span class="hljs-comment">// Json序列化配置</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        <span class="hljs-comment">// om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span>        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);        jackson2JsonRedisSerializer.setObjectMapper(om);        <span class="hljs-comment">// String的序列化</span>        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();        <span class="hljs-comment">// key采用String的序列化方式</span>        template.setKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// hash的key也采用String的序列化方式</span>        template.setHashKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// value序列化方式采用jackson</span>        template.setValueSerializer(jackson2JsonRedisSerializer);        <span class="hljs-comment">// hash的value序列化方式采用jackson</span>        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji;<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(&quot;redisTemplate&quot;)</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的命令一样</span>    <span class="hljs-comment">// opsForValue 操作字符串 类似 String</span>    <span class="hljs-comment">// opsForList 操作list 类似list</span>    <span class="hljs-comment">// 。。。依此类推</span>    <span class="hljs-comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的crud</span>    <span class="hljs-comment">// 获取redis 的连接对象</span>    <span class="hljs-comment">// RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>    <span class="hljs-comment">// connection.flushAll();</span>    <span class="hljs-comment">// connection.flushDb();</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;caoyusang&quot;</span>);        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础知识</title>
    <link href="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>开源免费</li><li>轻量级、非入侵式的框架</li><li><code>控制反转IOC + 面向切面编程AOP</code></li><li>支持事务处理以及框架整合</li></ul><p>总结：Spring就是一个<code>轻量级</code>的<code>控制反转</code>和<code>面向切面编程</code>的框架</p><h2 id="Spring七大模块"><a href="#Spring七大模块" class="headerlink" title="Spring七大模块"></a>Spring七大模块</h2><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/spring%E4%B8%83%E5%A4%A7%E6%A8%A1%E5%9D%97.png" class=""><h3 id="核心容器（Spring-Core）"><a href="#核心容器（Spring-Core）" class="headerlink" title="核心容器（Spring Core）"></a><strong>核心容器（Spring Core）</strong></h3><p>　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是<code>工厂模式</code>的实现。BeanFactory使用控制反转(IOC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</p><h3 id="应用上下文（Spring-Context）"><a href="#应用上下文（Spring-Context）" class="headerlink" title="应用上下文（Spring Context）"></a><strong>应用上下文（Spring Context）</strong></h3><p>　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><h3 id="Spring面向切面编程（Spring-AOP）"><a href="#Spring面向切面编程（Spring-AOP）" class="headerlink" title="Spring面向切面编程（Spring AOP）"></a><strong>Spring面向切面编程（Spring AOP）</strong></h3><p>　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><h3 id="JDBC和DAO模块（Spring-DAO）"><a href="#JDBC和DAO模块（Spring-DAO）" class="headerlink" title="JDBC和DAO模块（Spring DAO）"></a><strong>JDBC和DAO模块（Spring DAO）</strong></h3><p>　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p><h3 id="对象实体映射（Spring-ORM）"><a href="#对象实体映射（Spring-ORM）" class="headerlink" title="对象实体映射（Spring ORM）"></a><strong>对象实体映射（Spring ORM）</strong></h3><p>　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</p><h3 id="Web模块（Spring-Web）"><a href="#Web模块（Spring-Web）" class="headerlink" title="Web模块（Spring Web）"></a><strong>Web模块（Spring Web）</strong></h3><p>　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><h3 id="MVC模块（Spring-Web-MVC）"><a href="#MVC模块（Spring-Web-MVC）" class="headerlink" title="MVC模块（Spring Web MVC）"></a><strong>MVC模块（Spring Web MVC）</strong></h3><p>　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p><h2 id="IOC控制反转思想"><a href="#IOC控制反转思想" class="headerlink" title="IOC控制反转思想"></a>IOC控制反转思想</h2><h3 id="控制反转原型"><a href="#控制反转原型" class="headerlink" title="控制反转原型"></a>控制反转原型</h3><ul><li>以前，程序<code>主动</code>创建对象，<code>对象创建的控制权</code>在程序员手中</li><li>现在，程序不再具有主动性，变成了<code>被动</code>的接受对象</li></ul><p>这种思想从本质上解决了问题，获得依赖对象的方式反转了。程序员<code>不用再去管理对象的创建</code>，只需要提供用户接口和接口实现类，使用set方法进行注入，创建何种对象的选择权交给用户。</p><p>这样使得系统耦合度大大降低，程序员可以专注于业务。<br>从业务层理解：</p><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IOC%E6%80%9D%E6%83%B3%E4%B8%9A%E5%8A%A1%E5%B1%82%E7%90%86%E8%A7%A3.png" class=""><h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p>控制反转是一种通过描述(XML或者注解)使得<code>第三方生产或获取特定对象</code>的方式，在Spring中实现控制反转的是<code>IOC容器</code>，其实现方式为<code>依赖注入</code>(Dependency Injection)。</p><h2 id="简单样例——HelloSpring"><a href="#简单样例——HelloSpring" class="headerlink" title="简单样例——HelloSpring"></a>简单样例——HelloSpring</h2><h3 id="Maven导入Spring依赖包"><a href="#Maven导入Spring依赖包" class="headerlink" title="Maven导入Spring依赖包"></a>Maven导入Spring依赖包</h3><p>主要导两个：</p><ul><li>spring-webmvc(导入这个后，maven会自动帮我们补全额外的依赖)</li><li>spring-jdbc</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/HelloSpring.png" class=""><h3 id="实体类编写"><a href="#实体类编写" class="headerlink" title="实体类编写"></a>实体类编写</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-keyword">private</span> String str;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> str;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStr</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">this</span>.str = str;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&#123;&quot;</span> +                <span class="hljs-string">&quot;str=&#x27;&quot;</span> + str + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h3 id="XML文件配置"><a href="#XML文件配置" class="headerlink" title="XML文件配置"></a>XML文件配置</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--Spring默认使用无参构造器创建对象--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h3 id="测试类编写"><a href="#测试类编写" class="headerlink" title="测试类编写"></a>测试类编写</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.pojo.Hello;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取Spring的上下文对象</span>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        Hello hello = (Hello) context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);        System.out.println(hello.toString());    &#125;&#125;</code></pre><h3 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h3><h4 id="默认使用无参构造创建对象"><a href="#默认使用无参构造创建对象" class="headerlink" title="默认使用无参构造创建对象"></a>默认使用无参构造创建对象</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring默认使用无参构造器创建对象--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="使用有参构造创建对象"><a href="#使用有参构造创建对象" class="headerlink" title="使用有参构造创建对象"></a>使用有参构造创建对象</h4><ul><li>首先实体类需要一个有参构造方法</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hello</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">this</span>.str = str;&#125;</code></pre><ul><li><p>在xml配置文件中可使用三种方式进行对象创建：属性名、构造器参数下标、属性类型</p><ul><li>属性名</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方式1,通过属性名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li>构造器参数下标</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方式2,通过参数下标--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li>属性类型</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方式3,通过参数类型（不推荐使用）--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li></ul><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><h3 id="给Bean对象取别名"><a href="#给Bean对象取别名" class="headerlink" title="给Bean对象取别名"></a>给Bean对象取别名</h3><h4 id="name-推荐使用"><a href="#name-推荐使用" class="headerlink" title="name(推荐使用)"></a><code>name(推荐使用)</code></h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在bean标签最后添加name配置，可同时添加多个别名，别名之间用空格、逗号或者分号隔开(且分隔符可以混用)--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helloByIndex h1 h2 h3&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="lt-alias-gt-可用，但没必要"><a href="#lt-alias-gt-可用，但没必要" class="headerlink" title="&lt;alias&gt;(可用，但没必要)"></a><code>&lt;alias&gt;(可用，但没必要)</code></h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--给bean对象取别名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello1&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;helloByAttr&quot;</span>/&gt;</span></code></pre><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>一般用于团队开发使用，可以将多个配置文件导入合并为一个</p><p><code>applicationContext.xml</code></p><pre><code class="hljs xml">import resource=&quot;applicationContext2.xml&quot;import resource=&quot;applicationContext3.xml&quot;import resource=&quot;applicationContext4.xml&quot;</code></pre><h2 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Bean对象的创建依赖于容器</p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>Bean对象中的所有属性，由容器来注入</p><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>前面已经提到，Spring默认通过无参构造器进行注入，当然在有有参构造方法的前提下也可以使用有参构造器进行注入。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="Set注入"><a href="#Set注入" class="headerlink" title="Set注入"></a>Set注入</h3><h4 id="实体类Address"><a href="#实体类Address" class="headerlink" title="实体类Address"></a>实体类Address</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> address;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;        <span class="hljs-keyword">this</span>.address = address;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +                <span class="hljs-string">&quot;address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="实体类Student"><a href="#实体类Student" class="headerlink" title="实体类Student"></a>实体类Student</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Address address;    <span class="hljs-keyword">private</span> String[] books;    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; card;    <span class="hljs-keyword">private</span> Set&lt;String&gt; games;    <span class="hljs-keyword">private</span> String wife;    <span class="hljs-keyword">private</span> Properties info;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> address;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;        <span class="hljs-keyword">this</span>.address = address;    &#125;    <span class="hljs-keyword">public</span> String[] getBooks() &#123;        <span class="hljs-keyword">return</span> books;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBooks</span><span class="hljs-params">(String[] books)</span> </span>&#123;        <span class="hljs-keyword">this</span>.books = books;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getHobbies</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> hobbies;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobbies</span><span class="hljs-params">(List&lt;String&gt; hobbies)</span> </span>&#123;        <span class="hljs-keyword">this</span>.hobbies = hobbies;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">getCard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> card;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCard</span><span class="hljs-params">(Map&lt;String, String&gt; card)</span> </span>&#123;        <span class="hljs-keyword">this</span>.card = card;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getGames</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> games;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGames</span><span class="hljs-params">(Set&lt;String&gt; games)</span> </span>&#123;        <span class="hljs-keyword">this</span>.games = games;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getWife</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> wife;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWife</span><span class="hljs-params">(String wife)</span> </span>&#123;        <span class="hljs-keyword">this</span>.wife = wife;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Properties <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(Properties info)</span> </span>&#123;        <span class="hljs-keyword">this</span>.info = info;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;address=&quot;</span> + address.getAddress() + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;books=&quot;</span> + Arrays.toString(books) + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;hobbies=&quot;</span> + hobbies + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;card=&quot;</span> + card + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;games=&quot;</span> + games + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;wife=&#x27;&quot;</span> + wife + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;\n&#x27;</span> +                <span class="hljs-string">&quot;info=&quot;</span> + info +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="XML文件配置-1"><a href="#XML文件配置-1" class="headerlink" title="XML文件配置"></a>XML文件配置</h4><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Address&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addressByValue&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JiangXi&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Student&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;studentByValue&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--第一种：普通值注入value--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;caoyusang&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!--第二种：Bean注入, ref--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;addressByValue&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!--第三种：数组注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《红楼梦》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《三国演义》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《水浒传》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《西游记》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-comment">&lt;!--List注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>打篮球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>lol<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-comment">&lt;!--Map注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;洛天依&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;老天爷&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;鸡你太美&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;只因你太美&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-comment">&lt;!--Set注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>LOL<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>TFT<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;empty注入&amp;ndash;&amp;gt;--&gt;</span><span class="hljs-comment">&lt;!--        &lt;property name=&quot;wife&quot; value=&quot;&quot;/&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--null注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-comment">&lt;!--Properties注入--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>20200829<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;年龄&quot;</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.pojo.Student;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取Spring的上下文对象</span>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        Student s = (Student) context.getBean(<span class="hljs-string">&quot;studentByValue&quot;</span>);        System.out.println(s.toString());    &#125;&#125;</code></pre><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="D:/NutCloud/我的坚果云/pics/set注入.png"/></p><h3 id="扩展方式注入"><a href="#扩展方式注入" class="headerlink" title="扩展方式注入"></a>扩展方式注入</h3><p>可以使用p命名空间和c命名空间进行注入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--p命名空间注入，可以直接注入属性的值，property--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello99&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span> <span class="hljs-attr">p:str</span>=<span class="hljs-string">&quot;spring&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--c命名空间注入，通过构造器注入，constructor-args--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello100&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Hello&quot;</span> <span class="hljs-attr">c:str</span>=<span class="hljs-string">&quot;spring&quot;</span>/&gt;</span></code></pre><h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Bean%E4%BD%9C%E7%94%A8%E5%9F%9F.png" class=""><h3 id="单例模式-singleton"><a href="#单例模式-singleton" class="headerlink" title="单例模式(singleton)"></a>单例模式(singleton)</h3><p>一个单例bean只有一个共享实例被管理，所有对具有一个或多个与该bean定义匹配的ID的bean的请求都会导致Spring容器返回一个特定的bean实例。</p><p>当定义一个bean并将其定义为一个单例时，Spring IoC容器会为该bean定义所定义的对象创建一个实例。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span></code></pre><p>这个单实例存储在这样的单例bean的缓存中，所有后续的请求和引用都会返回缓存的对象。</p><p>下图显示了单例作用域的工作方式</p><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" class=""><h3 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式(prototype)"></a>原型模式(prototype)</h3><p>bean部署的原型模式作用范围将导致每次对特定bean发出请求时都会创建一个新的bean实例。</p><p>每次通过容器getBean()时都会产生一个新的对象。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span></code></pre><p>作用域使用规则：</p><ul><li>对所有有状态bean使用原型作用域</li><li>对无状态bean使用单例作用域。</li></ul><h3 id="Web开发中常用的四大模式"><a href="#Web开发中常用的四大模式" class="headerlink" title="Web开发中常用的四大模式"></a>Web开发中常用的四大模式</h3><p><code>后面再补</code></p><h2 id="Spring的三种装配模式"><a href="#Spring的三种装配模式" class="headerlink" title="Spring的三种装配模式"></a>Spring的三种装配模式</h2><h3 id="XML显示配置"><a href="#XML显示配置" class="headerlink" title="XML显示配置"></a>XML显示配置</h3><p><code>配置地狱</code></p><h3 id="隐式自动装配"><a href="#隐式自动装配" class="headerlink" title="隐式自动装配"></a>隐式自动装配</h3><p>Spring会在上下文中自动寻找，并自动给bean装配属性。</p><h4 id="ByName"><a href="#ByName" class="headerlink" title="ByName"></a>ByName</h4><p>需要保证所有Bean的id唯一，而且id需要和自动注入的属性的set方法名后的属性一致</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--byName--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;wandehua&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="ByType"><a href="#ByType" class="headerlink" title="ByType"></a>ByType</h4><p>需要保证需要保证所有Bean的class唯一，而且class需要和自动注入的属性类型一致</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--byType--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;wandehua&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h4><ul><li>导入context约束</li></ul><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></code></pre><ul><li>在XML文件中添加注解支持@Autowired</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加注解注入支持--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span></code></pre><ul><li>给实体类属性填上自动注入的注解</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Dog dog;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Cat cat;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Dog <span class="hljs-title">getDog</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dog;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDog</span><span class="hljs-params">(Dog dog)</span> </span>&#123;        <span class="hljs-keyword">this</span>.dog = dog;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Cat <span class="hljs-title">getCat</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cat;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCat</span><span class="hljs-params">(Cat cat)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cat = cat;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +                <span class="hljs-string">&quot;, cat=&quot;</span> + cat +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><p>ps:</p><ol><li>@Autowired可以在属性上使用，也可以在set方法上使用(<code>官方推荐</code>)</li><li>@Autowired默认是<code>byType</code>方式，如果有多个相同type的bean对象</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Dog&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.Dog&quot;</span>/&gt;</span></code></pre><p>需要配合@Qualifier(value = “bean id”)精准定位</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier(value = &quot;dog1&quot;)</span><span class="hljs-keyword">private</span> Dog dog;</code></pre><ol><li>当然还可使用java的原生注解@Resource进行自动注入，@Resource会执行byName和byType，都找不到则需要指定name</li></ol><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.Resource    ...<span class="hljs-meta">@Resource(name = &quot;dog1&quot;)</span></code></pre><h3 id="Java-config实现配置"><a href="#Java-config实现配置" class="headerlink" title="Java-config实现配置"></a>Java-config实现配置</h3><p><code>完全替代XML文件</code>，这种完全使用配置类的方式在SpringBoot中随处可见。</p><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>相当于xml文件</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.config;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//代表这是一个配置类</span><span class="hljs-meta">@ComponentScan(&quot;com.youzikeji.pojo&quot;)</span>    <span class="hljs-comment">//扫描包</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();    &#125;&#125;</code></pre><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>使用注解进行Bean的获取和属性的注入</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Value(&quot;caoyusang&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String    toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h4 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h4><p>如果完全使用配置类方式去进行容器配置，那么只能通过<code>AnnotationConfigApplicationContext</code>获取容器，通过配置<code>类的class对象</code>进行配置加载。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.config.JavaConfig;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);        User user = (User) context.getBean(<span class="hljs-string">&quot;getUser&quot;</span>);        System.out.println(user.getName());    &#125;&#125;</code></pre><h2 id="Spring使用注解开发"><a href="#Spring使用注解开发" class="headerlink" title="Spring使用注解开发"></a>Spring使用注解开发</h2><h3 id="获得对注解的支持"><a href="#获得对注解的支持" class="headerlink" title="获得对注解的支持"></a>获得对注解的支持</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--添加要扫描的包，该包下所有注解都会生效--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.youzikeji.pojo&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h3 id="获得Bean、进行属性注入以及作用域设定"><a href="#获得Bean、进行属性注入以及作用域设定" class="headerlink" title="获得Bean、进行属性注入以及作用域设定"></a>获得Bean、进行属性注入以及作用域设定</h3><p><code>@Component</code>放在类上，说明这个类被Spring管理了。</p><p><code>@Value</code>放在属性或者set方法上(<code>推荐</code>)，进行属性值的注入</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">//组件，等价于&lt;bean&gt;</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span> <span class="hljs-comment">//作用域</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;caoyusang&quot;)</span> <span class="hljs-comment">//等价于&lt;property&gt;</span>    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><h3 id="Component的衍生注解"><a href="#Component的衍生注解" class="headerlink" title="@Component的衍生注解"></a>@Component的衍生注解</h3><p>在实际的web开发中，<code>@Component</code>根据MVC三层架构可以有三类衍生注解：</p><ul><li>dao层 —— <code>@Repository</code></li><li>service层 —— <code>@Service</code></li><li>controller层 —— <code>@Controller</code></li></ul><p>它们都代表了组件的意思，起着和@Component同样的效果，只是@Component在不同层的”分身”</p><h2 id="设计模式——代理"><a href="#设计模式——代理" class="headerlink" title="设计模式——代理"></a>设计模式——代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h4 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h4><ul><li>抽象角色——一般使用接口或抽象类解决</li><li>真实角色——被代理的角色</li><li>代理角色——代理真实角色，真实角色能做的、不能做的，代理角色都一并做了</li><li>客户——访问代理对象的人</li></ul><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rent;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h5 id="真实角色类——房东"><a href="#真实角色类——房东" class="headerlink" title="真实角色类——房东"></a>真实角色类——房东</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rent;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landlord</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;房东要出租房屋&quot;</span>);    &#125;&#125;</code></pre><h5 id="代理角色——中介"><a href="#代理角色——中介" class="headerlink" title="代理角色——中介"></a>代理角色——中介</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.rent;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;    <span class="hljs-keyword">private</span> Landlord landlord;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//有参构造指定了被代理的对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Agent</span><span class="hljs-params">(Landlord landlord)</span> </span>&#123;        <span class="hljs-keyword">this</span>.landlord = landlord;    &#125;    <span class="hljs-comment">//房屋中介能做房东能做的，还能帮房东做他做不了的一些附属业务</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;        seeHouse();        landlord.rent();        sign();        charge();    &#125;    <span class="hljs-comment">//看房</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seeHouse</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;看房&quot;</span>);    &#125;    <span class="hljs-comment">//签合同</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sign</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;签合同&quot;</span>);    &#125;    <span class="hljs-comment">//收中介费</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;收中介费&quot;</span>);    &#125;&#125;</code></pre><h5 id="测试类-2"><a href="#测试类-2" class="headerlink" title="测试类"></a>测试类</h5><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.rent.Agent;<span class="hljs-keyword">import</span> com.youzikeji.rent.Landlord;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Landlord landlord = <span class="hljs-keyword">new</span> Landlord();        Agent agent = <span class="hljs-keyword">new</span> Agent(landlord);        agent.rent();    &#125;&#125;</code></pre><h4 id="代理的优势与缺点"><a href="#代理的优势与缺点" class="headerlink" title="代理的优势与缺点"></a>代理的优势与缺点</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><ul><li>使真实角色的操作更纯粹，不必关注公共的业务</li><li>公共业务被交给代理角色，实现了业务分工</li><li>公共业务发生扩展时，方便集中管理</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>一个真实角色就会产生一个代理，增加了代码量，降低了开发效率</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h5><p>JDK动态代理</p><p><code>Proxy类</code>：提供了创建动态代理类和实例的静态方法<code>Proxy.newProxyInstance</code></p><p>生成动态代理实例</p><p><code>InvocationHandler接口</code>：代理实例调用处理程序的接口</p><p><code>动态代理实例</code></p><p>业务接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.proxy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>接口实现类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.proxy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;得到用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;增加用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;删除用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;更新用户&quot;</span>);    &#125;&#125;</code></pre><p>动态代理实现类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.proxy;<span class="hljs-keyword">import</span> org.springframework.cglib.proxy.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-comment">//自动生成代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">//被代理的接口</span>    <span class="hljs-keyword">private</span> Object target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-comment">//生成代理类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="hljs-keyword">this</span>::invoke);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        log(method.getName());        Object result = method.invoke(target, objects);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String msg)</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span> + msg + <span class="hljs-string">&quot;方法&quot;</span>);    &#125;&#125;</code></pre><p>测试类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.proxy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//真实角色</span>        UserServiceImp imp = <span class="hljs-keyword">new</span> UserServiceImp();        <span class="hljs-comment">//代理角色</span>        ProxyInvocationHandler pih = <span class="hljs-keyword">new</span> ProxyInvocationHandler();        <span class="hljs-comment">//设置要代理的接口</span>        pih.setTarget(imp);        <span class="hljs-comment">//动态设置代理类</span>        UserService proxy = (UserService) pih.getProxy();        proxy.addUser();    &#125;&#125;</code></pre><p>效果展示</p><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" class=""><ul><li>一个动态代理类代理一般是接口的实现类，一般就是对应的一类业务</li><li>一个动态代理类可以代理多个接口实现类，只要这些类实现了同一个接口</li></ul><h5 id="基于类的动态代理"><a href="#基于类的动态代理" class="headerlink" title="基于类的动态代理"></a>基于类的动态代理</h5><p>cglib</p><h2 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h2><h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><p>AOP —— 面向切面编程，通过<code>预编译方式</code>和<code>运行期动态代理</code>实现程序<code>功能的统一维护</code>的一种技术。</p><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<code>耦合度降低</code>，提高程序的可重用性，同时提高了开发效率。</p><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/aop.png" class=""><h3 id="原生Spring-API接口实现AOP"><a href="#原生Spring-API接口实现AOP" class="headerlink" title="原生Spring API接口实现AOP"></a>原生Spring API接口实现AOP</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><h5 id="业务接口-1"><a href="#业务接口-1" class="headerlink" title="业务接口"></a>业务接口</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h5 id="接口实现类"><a href="#接口实现类" class="headerlink" title="接口实现类"></a>接口实现类</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;得到用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;增加用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;删除用户&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;更新用户&quot;</span>);    &#125;&#125;</code></pre><h5 id="API接口实现"><a href="#API接口实现" class="headerlink" title="API接口实现"></a>API接口实现</h5><p><code>MethodBeforeAdvice接口</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.log;<span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeforeLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;    <span class="hljs-comment">//method: 要执行的目标对象的方法</span>    <span class="hljs-comment">//objects: 参数</span>    <span class="hljs-comment">//o: 目标对象</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(o.getClass().getName()+<span class="hljs-string">&quot;的&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法被调用了&quot;</span>);    &#125;&#125;</code></pre><p><code>AfterReturningAdvice接口</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.log;<span class="hljs-keyword">import</span> org.springframework.aop.AfterReturningAdvice;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;, 返回结果为:&quot;</span> + o);    &#125;&#125;</code></pre><h5 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h5><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--注册bean--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.service.UserServiceImp&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beforeLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.log.BeforeLog&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.log.AfterLog&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--配置aop--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-comment">&lt;!--切入点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.youzikeji.service.UserServiceImp.*(..))&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;beforeLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><h5 id="测试类-3"><a href="#测试类-3" class="headerlink" title="测试类"></a>测试类</h5><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.service.UserService;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        <span class="hljs-comment">// 代理的是接口</span>        UserService service = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);        service.addUser();    &#125;&#125;</code></pre><h5 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h5><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/aop%E7%BB%93%E6%9E%9C.png" class=""><h3 id="自定义切面实现AOP"><a href="#自定义切面实现AOP" class="headerlink" title="自定义切面实现AOP"></a>自定义切面实现AOP</h3><h5 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h5><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.aspect;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SurroundLog</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;方法执行前&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;方法执行后&quot;</span>);    &#125;&#125;</code></pre><h5 id="注册bean"><a href="#注册bean" class="headerlink" title="注册bean"></a>注册bean</h5><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--自定义切面--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;surroundLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.aspect.SurroundLog&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-comment">&lt;!--自定义切面，ref——要引用的类--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;surroundLog&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--切入点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;point&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.youzikeji.service.UserServiceImp.*(..))&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!--通知--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre><h5 id="测试类-4"><a href="#测试类-4" class="headerlink" title="测试类"></a>测试类</h5><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.youzikeji.service.UserService;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);        <span class="hljs-comment">// 代理的是接口</span>        UserService service = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);        service.addUser();    &#125;&#125;</code></pre><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><img src="/2021/01/05/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/diy-aop-res.png" class=""><h3 id="注解实现AOP"><a href="#注解实现AOP" class="headerlink" title="注解实现AOP"></a>注解实现AOP</h3><h4 id="开启扫描包和注解支持"><a href="#开启扫描包和注解支持" class="headerlink" title="开启扫描包和注解支持"></a>开启扫描包和注解支持</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.youzikeji&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--开启注解支持--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span></code></pre><h4 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.annotation;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-comment">//切面类标注</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">annotationPointCut</span> </span>&#123;    <span class="hljs-meta">@Before(&quot;execution(* com.youzikeji.service.UserServiceImp.*(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;执行前&quot;</span>);    &#125;    <span class="hljs-meta">@After(&quot;execution(* com.youzikeji.service.UserServiceImp.*(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;执行后&quot;</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis基础知识</title>
    <link href="/2020/12/14/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/12/14/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis框架使用"><a href="#MyBatis框架使用" class="headerlink" title="MyBatis框架使用"></a>MyBatis框架使用</h3><h2 id="1-导入mybatis的jar包"><a href="#1-导入mybatis的jar包" class="headerlink" title="1. 导入mybatis的jar包"></a>1. 导入mybatis的jar包</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="2-根据数据表建立实体类"><a href="#2-根据数据表建立实体类" class="headerlink" title="2. 根据数据表建立实体类"></a>2. 根据数据表建立实体类</h2><img src="/2020/12/14/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/database.png" class="" title="database.png"><h3 id="方式1-——-借助IDEA"><a href="#方式1-——-借助IDEA" class="headerlink" title="方式1 —— 借助IDEA"></a>方式1 —— 借助IDEA</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-comment">// 实体类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, String pwd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.password = pwd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPwd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPwd</span><span class="hljs-params">(String pwd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = pwd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, pwd=&#x27;&quot;</span> + password + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h3 id="方式2-——-利用lombok插件"><a href="#方式2-——-利用lombok插件" class="headerlink" title="方式2 —— 利用lombok插件"></a>方式2 —— 利用lombok插件</h3><ol><li><p>先给IDEA安装lombok插件</p></li><li><p>lombok插件提供了众多pojo类注解，可以自动生成get/set/toString/hashCode/无参构造/有参构造等方法，常用的注解有</p><p>@Getter/@Setter</p><p>@ToString</p><p>@Data</p><p>@RequiredArgsConstructor</p><p>@AllArgsConstructor </p><p>@NoArgsConstructor </p><p>使用样例如下：</p></li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.pojo;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-comment">// 实体类</span><span class="hljs-meta">@Data</span>       <span class="hljs-comment">// 包含get、set方法、无参构造、toString和hashCode等</span><span class="hljs-meta">@AllArgsConstructor</span>     <span class="hljs-comment">// 全参构造，会覆盖无参方法</span><span class="hljs-meta">@NoArgsConstructor</span>      <span class="hljs-comment">// 无参构造</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;&#125;</code></pre><ol><li>导入lombok的jar包</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="3-业务接口定义与实现"><a href="#3-业务接口定义与实现" class="headerlink" title="3. 业务接口定义与实现"></a>3. 业务接口定义与实现</h2><h3 id="方式1-——-直接给dao层添加接口"><a href="#方式1-——-直接给dao层添加接口" class="headerlink" title="方式1 —— 直接给dao层添加接口"></a>方式1 —— 直接给dao层添加接口</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.dao;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">// 查询全部用户</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 根据ID查询用户</span>    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-comment">// 增加用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">// 修改用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">// 删除用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-comment">// 模糊查询</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getSimilarUser</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><p>定义好接口后，新建一个同名的xml文件用于绑定接口并定义实现的sql语句</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--bind Mapper interface--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.youzikeji.dao.UserMapper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--resultSet Mapping--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--sql command--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>        select * from mybatis.user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>        select  * from mybatis.user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>        insert into mybatis.user (id, name, pwd) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>        update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125;  where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>        delete from mybatis.user where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getSimilarUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>        select * from mybatis.user where name like concat(&#x27;%&#x27;, #&#123;name&#125; ,&#x27;%&#x27;)    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p>ps：</p><p>pojo类定义时的属性名和数据表对应位置的字段名不同时，需要进行结果集映射，即resultMap</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--resultSet Mapping--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><p>绑定好mapper接口之后，需要到<code>resources/mybatis-config.xml</code>文件中注册mapper</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mapper.xml registering--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/youzikeji/dao/UserMapper.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><p>ps：</p><p>使用<code>&lt;mapper resource=&quot;&quot;/&gt;</code>方式时，需要填入xml文件的相对路径</p><h3 id="方式2-——-使用注解"><a href="#方式2-——-使用注解" class="headerlink" title="方式2 —— 使用注解"></a>方式2 —— 使用注解</h3><p>在定义业务接口时使用注解将方法和对应sql命令进行绑定</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.dao;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.*;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">// 查询全部用户,注解实现</span>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 根据ID查询用户</span>    <span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span>    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-comment">// 增加用户</span>    <span class="hljs-meta">@Insert(&quot;insert into user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">// 修改用户</span>    <span class="hljs-meta">@Update(&quot;update user set name=#&#123;name&#125;, pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">// 删除用户</span>    <span class="hljs-meta">@Delete(&quot;delete from user where id=#&#123;uid&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-comment">// 模糊查询</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getSimilarUser</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><p>之后直接到<code>resources/mybatis-config.xml</code>文件中注册mapper</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mapper class registering--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.dao.UserMapper&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><h2 id="4-构建mybatis核心配置文件"><a href="#4-构建mybatis核心配置文件" class="headerlink" title="4. 构建mybatis核心配置文件"></a>4. 构建mybatis核心配置文件</h2><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--core setting--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!--load db.properties--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-comment">&lt;!--settings--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-comment">&lt;!--standard log settings--&gt;</span><span class="hljs-comment">&lt;!--        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--LOG4J setting, need dependency--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-comment">&lt;!--set typeAlias--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-comment">&lt;!--method 1--&gt;</span><span class="hljs-comment">&lt;!--        &lt;typeAlias type=&quot;com.youzikeji.pojo.User&quot; alias=&quot;user&quot;/&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--method 2--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.youzikeji.pojo&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-comment">&lt;!--multi-environments--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--JDBC--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-comment">&lt;!--database connect setting--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-comment">&lt;!--mapper class registering--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.youzikeji.dao.UserMapper&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p>关于配置文件的说明：</p><ol><li><p>所有核心的配置都在<code>&lt;configuration&gt;...&lt;/configuration&gt;</code>中，其中，各部分配置需要遵从既定的顺序。</p><p>前三个按顺序必须依次是<code>&lt;properties&gt; ——&gt; &lt;settings&gt; ——&gt; &lt;typeAliases&gt;</code>.</p><p>另外<code>&lt;mappers&gt;</code>必须在最后进行注册配置；</p></li><li><p><code>&lt;properties&gt;</code>，顾名思义，可以在这里配置属性.</p><p>这些属性可以在外部进行配置，并可以进行动态替换。</p><p>这说明既可以在java属性文件<code>resources/*.properties</code>中配置这些属性，也可以在<code>&lt;property&gt;</code>中设置。</p><p>在<code>db.properties</code>中的配置为：</p><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></code></pre><p>在<code>&lt;properties&gt;</code>的子属性<code>&lt;property&gt;</code>中的配置如下：</p><pre><code class="hljs properties"><span class="hljs-meta">&lt;!--load</span> <span class="hljs-string">db.properties--&gt;</span><span class="hljs-meta">&lt;properties</span> <span class="hljs-string">resource=&quot;db.properties&quot;&gt;</span>    <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name=&quot;username&quot; value=&quot;root&quot;/&gt;</span>    <span class="hljs-meta">&lt;property</span> <span class="hljs-string">name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><span class="hljs-attr">&lt;/properties&gt;</span></code></pre></li><li><p><code>&lt;settings&gt;</code>作为MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 一个配置完整的 settings 元素的示例如下：</p></li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--全局性地开启或关闭所有映射器配置文件中已配置的任何缓存--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipleResultSetsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useColumnLabel&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;WARNING&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SIMPLE&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatementTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultFetchSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;safeRowBoundsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OTHER&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><p>特别的，只是简单在<code>&lt;settings&gt;</code>中进行日志配置，可以使用自带的标准日志，也可使用log4j，使用log4j的步骤如下：</p><ul><li>前提——导入log4j的jar包</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ul><li>编写日志的属性文件<code>resources/log4j.properties</code></li></ul><pre><code class="hljs properties"><span class="hljs-comment">#将等级为DEBUG的日志信息输出到控制台和file两个目的地</span><span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">DEBUG,console,file</span><span class="hljs-comment">#控制台输出相关配置</span><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.console.Threshold</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.console.layout.ConversionPatten</span> = <span class="hljs-string">[%c]-%m%n</span><span class="hljs-comment">#文件输出相关设置</span><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><span class="hljs-meta">log4j.appender.file.File</span> = <span class="hljs-string">./log/youzikeji.log</span><span class="hljs-meta">log4j.appender.file.MaxFileSize</span> = <span class="hljs-string">10mb</span><span class="hljs-meta">log4j.appender.file.Threshold</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.appender.file.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.file.layout.ConversionPatten</span> = <span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><span class="hljs-comment">#日志输出级别</span><span class="hljs-meta">log4j.logger.org.mybatis</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.Statement</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span> = <span class="hljs-string">DEBUG</span><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span> = <span class="hljs-string">DEBUG</span></code></pre><ul><li>在<code>&lt;setting&gt;</code>中配置</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-comment">&lt;!--LOG4J setting, need dependency--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><ol><li><p><code>&lt;typeAliases&gt;</code>为取别名的配置，有两种方式取别名</p></li><li><p>传统方式</p></li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-comment">&lt;!--method 1--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.youzikeji.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre><ol><li>声明包名方式——(该包下的类的别名默认为其小写形式)</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-comment">&lt;!--method 2--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.youzikeji.pojo&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre><h2 id="5-从XML中构建SqlSessionFactory"><a href="#5-从XML中构建SqlSessionFactory" class="headerlink" title="5. 从XML中构建SqlSessionFactory"></a>5. 从XML中构建SqlSessionFactory</h2><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>由XML文件生成SqlSessionFactory对象这一步骤是既定的，可以包装成工具类MybatisUtils</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.utils;<span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">// Mybatis工具类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 使用Mybatis第一步：获取sqlSessionFactory对象</span>        <span class="hljs-keyword">try</span> &#123;            String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;            <span class="hljs-comment">// 将XML文件读入输入流</span>            InputStream inputStream = Resources.getResourceAsStream(resource);            <span class="hljs-comment">// 从XML文件中构建 SqlSessionFactory 的实例</span>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 第二步：获取SqlSession对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre><h2 id="6-由SqlSessionFactory获取SqlSession"><a href="#6-由SqlSessionFactory获取SqlSession" class="headerlink" title="6. 由SqlSessionFactory获取SqlSession"></a>6. 由SqlSessionFactory获取SqlSession</h2><p>在MybatisUtils类中定义了一个方法，通过调用openSession()获取SqlSession对象</p><pre><code class="hljs java">SqlSession session = MybatisUtils.getSqlSession();</code></pre><h2 id="7-编写测试类"><a href="#7-编写测试类" class="headerlink" title="7. 编写测试类"></a>7. 编写测试类</h2><p>获取SqlSession对象后，通过<code>getMapper()</code>方法获取Mapper对象，通过Mapper对象调用接口方法执行SQL语句</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.youzikeji.dao;<span class="hljs-keyword">import</span> com.youzikeji.pojo.User;<span class="hljs-keyword">import</span> com.youzikeji.utils.MybatisUtils;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.log4j.Logger;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperTest</span> </span>&#123;    <span class="hljs-comment">//通过反射获取本类的日志对象</span>    <span class="hljs-keyword">static</span> Logger logger  = Logger.getLogger(UserMapperTest.class);    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 1.获取SqlSession对象</span>        SqlSession session = MybatisUtils.getSqlSession();        <span class="hljs-comment">// 2.执行SQL(getmapper())</span>        UserMapper mapper = session.getMapper(UserMapper.class);        List&lt;User&gt; list = mapper.getUserList();        <span class="hljs-keyword">for</span> (User user : list) &#123;            System.out.println(user);        &#125;        <span class="hljs-comment">// 3.关闭SqlSession</span>        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;        SqlSession session = MybatisUtils.getSqlSession();        UserMapper mapper = session.getMapper(UserMapper.class);        User user = mapper.getUserById(<span class="hljs-number">1</span>);        System.out.println(user);        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>&#123;        SqlSession session = MybatisUtils.getSqlSession();        UserMapper mapper = session.getMapper(UserMapper.class);        mapper.addUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;lalalalal&quot;</span>, <span class="hljs-string">&quot;111111&quot;</span>));        <span class="hljs-comment">// autocommit=true ——&gt; 自动提交事务</span>        session.commit();        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>&#123;        SqlSession session = MybatisUtils.getSqlSession();        UserMapper mapper = session.getMapper(UserMapper.class);        mapper.updateUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;nba&quot;</span>, <span class="hljs-string">&quot;111112&quot;</span>));        session.commit();        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>&#123;        SqlSession session = MybatisUtils.getSqlSession();        UserMapper mapper = session.getMapper(UserMapper.class);        mapper.deleteUser(<span class="hljs-number">4</span>);        session.commit();        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSimilarUser</span><span class="hljs-params">()</span></span>&#123;        SqlSession session = MybatisUtils.getSqlSession();        UserMapper mapper = session.getMapper(UserMapper.class);        List&lt;User&gt; users = mapper.getSimilarUser(<span class="hljs-string">&quot;an&quot;</span>);        <span class="hljs-keyword">for</span> (User user : users) &#123;            System.out.println(user);        &#125;        session.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLog4j</span><span class="hljs-params">()</span></span>&#123;        logger.info(<span class="hljs-string">&quot;info —— 我在测试testLog4j&quot;</span>);        logger.debug(<span class="hljs-string">&quot;debug —— 我在测试testLog4j&quot;</span>);        logger.error(<span class="hljs-string">&quot;error —— 我在测试testLog4j&quot;</span>);    &#125;&#125;</code></pre><h2 id="8-动态SQL"><a href="#8-动态SQL" class="headerlink" title="8. 动态SQL"></a>8. 动态SQL</h2><p>参考<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">官方文档</a></p><h2 id="9-MyBatis缓存"><a href="#9-MyBatis缓存" class="headerlink" title="9. MyBatis缓存"></a>9. MyBatis缓存</h2><h3 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h3><p>MyBatis中默认定义了两级缓存：<code>一级缓存</code>和<code>二级缓存</code></p><ul><li><p>默认只开启一级缓存，SqlSession(会话)级别的缓存，也称为<code>本地缓存</code></p></li><li><p>二级缓存需要手动开启，基于<code>namespace</code>(接口)级别的缓存</p><ul><li><p>所有数据都会先放在一级缓存中，当会话提交或者关闭时，数据才会提交到二级缓存中</p></li><li><p>要启用全局的二级缓存，只需要在 SQL 映射文件中添加一行：<code>&lt;cache/&gt;</code>，该语句的效果如下:</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存</li><li>缓存默认会使用<code>最近最少使用</code>算法（LRU, Least Recently Used）算法来清除不需要的缓存<ul><li>可用的清除策略有：<ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul></li></ul></li><li>缓存默认不会定时进行刷新</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul></li><li><p>二级缓存的属性可以通过 cache 元素的属性来修改：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> </span><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre><p>上面语句的效果如下：</p><ul><li>创建了一个 FIFO 缓存</li><li>每隔 60 秒刷新</li><li>最多可以存储结果对象或列表的 512 个引用</li><li>返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</li></ul></li></ul></li><li><p>为了提高扩展性，定义了<code>缓存接口Cache</code>，可以通过实现Cache接口来自定义二级缓存</p><p>Cache接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.ibatis.cache;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cache</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object var1, Object var2)</span></span>;    <span class="hljs-function">Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object var1)</span></span>;    <span class="hljs-function">Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> ReadWriteLock <span class="hljs-title">getReadWriteLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>自定义缓存方式请参考官方文档<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache">MyBatis缓存</a></p></li></ul><h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><img src="/2020/12/14/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png" class="" title="缓存原理.png">]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于多知识库迭代检索的常识问答系统</title>
    <link href="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="多知识库常识知识迭代检索"><a href="#多知识库常识知识迭代检索" class="headerlink" title="多知识库常识知识迭代检索"></a>多知识库常识知识迭代检索</h2><p><a href="https://arxiv.org/pdf/2011.02705v1.pdf">论文地址</a></p><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-1.png" class=""><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>常识问答任务需要引入外部知识来帮助模型更好地理解自然语言问题，现有的解决方案大都采用两阶段框架：</p><ul><li>第一阶段 —— 从广泛的知识来源中找到与给定问题相关的知识事实或者用预训练模型生成相关的知识</li><li>第二阶段 —— 将找到的或者生成的知识与问题融合以预测答案。</li></ul><p>实验结果证明，外部知识融合到问答系统的做法是十分有效的，但这仍然存在一个关键的问题：就从<strong>单一</strong>外部知识库找寻相关知识而言，<strong>抽取到的部分知识可能对解决问题基本毫无作用，甚至还可能损害模型的性能</strong>。例如，以下面一个QA为例，对于问题实体<script type="math/tex">farmland</script>和三个选项实体<script type="math/tex">midwest \space countryside \space illinois</script>，从<strong>ConceptNet</strong>中抽取到的知识显示，<script type="math/tex">farmland</script>和三个选项实体都直接相关<script type="math/tex">(AtLocation)</script>。</p><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-2.jpg" class=""><p>虽然外部知识给到了模型，但模型仍然很难做出正确的选择，因为这三个选项看上去似乎都是正确的。这样的问题在论文中被称为知识的多价值属性，这种问题在问答系统中十分常见，实体关系的多值属性会损害现有模型的性能。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>提出一种新的多知识源问答方法，通过利用多种知识来源，在所需的背景知识和原始问题以及选择之间建立精确的联系，以解决多值属性带来的挑战。</p><p>三个创新：</p><ul><li><strong>提出基于图的迭代检索模块</strong> —— 通过问题中实体之间的隐藏关系来缩小和细化潜在的有用知识事实</li><li><strong>引入词典为实体或者概念提供解释</strong> —— 综合实体或概念解释和迭代检索的知识事实可以帮助模型精确区分欺骗性的答案选择</li><li><strong>提出答案选择感知注意力机制</strong> —— 在将隐层状态向量输入最终预测的线性分类器之前，引入答案选择感知注意机制来计算给定问题、检索的知识和候选选择的各自的隐层向量之间的注意力分数</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-3.png" class=""><p>仍然采用两阶段的框架(默认已经进行了对QA对的实体识别)：</p><ul><li><p>第一阶段 —— 从多个外部知识库中抽取与QA对相关的知识，这部分大多是在检索知识</p><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-4.png" class=""><ul><li><strong>结构化证据</strong> —— 从ConceptNet中找到问题概念和识别的关键实体(包含选项实体)，并把它们作为初始节点。根据问题的类型，使用<strong>基于规则</strong>的方法推断可能的关系，并使用这些关系来缩小知识提取的范围。基于初始节点和潜在关系，迭代地检索与问题相关的知识事实。</li><li><strong>非结构化证据</strong> —— 将维基百科文档拆分成句子，使用ElasticSearch构建索引。根据原问题检索相关句子，使用<strong>标题</strong>和段落缩小文档的范围。然后使用段落级候选词和它们的句子来建立索引，并检索前10个相关的句子</li><li><strong>实体或概念解释</strong> —— 从字典中提取答案选择和问题概念的含义，帮助模型区分分散注意力的实体</li></ul></li><li><p>第二阶段 —— 用预训练模型对构造的输入进行编码，将编码后的三个隐层向量通过一个答案选择感知注意力计算注意力得分，最终输入到分类器中得到QA对的得分。</p><ul><li><strong>输入构造</strong> —— <script type="math/tex">[CLS] \space Question \space [SEP] \space Extracted \space Knowledge \space [SEP] \space Choices</script></li><li><strong>答案选择感知注意力机制</strong> —— 主要是计算QA对各自隐层向量的注意力系数以及证据和选项各自隐层向量的注意力系数，最后串接加权后的问题隐层向量<script type="math/tex">O_{qa}h_{q}</script>和加权后的证据隐层向量<script type="math/tex">O_{ca}h_{c}</script>以及选项隐层向量<script type="math/tex">h_{a}</script></li></ul></li></ul><h3 id="多源知识库"><a href="#多源知识库" class="headerlink" title="多源知识库"></a>多源知识库</h3><p>结构化的ConceptNet、非结构化的Wikipedia以及剑桥词典(Cambridge Dictionary)。</p><ul><li><strong>ConceptNet</strong> —— 最大的结构化知识库之一，知识主要来自其他众包资源、专家创造的资源</li><li><strong>Wikipedia</strong> —— 一个免费的在线百科全书，由世界各地的志愿者创建和编辑，论文中选用最新的Wikipedia 22-May-2020版本</li><li><strong>Cambridge Dictionary</strong> —— 1995年出版，囊括超140k单词、短语及解释。</li></ul><h3 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h3><p>在从多个知识源中检索与问题相关的知识事实后，使用<script type="math/tex">[SEP]</script>来分割证据知识、原始问题和候选答案。</p><p>具体做法：</p><ol><li>将原始答案选择与来自剑桥词典的答案解释连接起来作为<script type="math/tex">A= \left\{ a_{1},a_{2},\dots,a_{n} \right\}</script></li><li>将来自维基百科和概念网的证据连接起来作为上下文<script type="math/tex">C=\left\{c_{1}, c_{2}, \ldots, c_{k}\right\}</script>。</li><li>将来自剑桥词典的概念解释与问题词干连接起来作为<script type="math/tex">Q=\left\{q_{1}, q_{2}, \ldots, q_{m}\right\}</script>。</li></ol><p>从形式上来看，预先训练的语言模型的输入是问题Q、相关证据C和答案选择A的连接：</p><script type="math/tex; mode=display">h_{q}=\operatorname{Encoder}(Q), h_{a}=\operatorname{Encoder}(A), h_{c}=\operatorname{Encoder}(C)</script><h3 id="答案选择感知注意力机制"><a href="#答案选择感知注意力机制" class="headerlink" title="答案选择感知注意力机制"></a>答案选择感知注意力机制</h3><p>通常在从RoBERTa模型中获得最后的隐藏状态向量后，对于下游任务中的问题回答，以往的模型方案是通常直接使用线性分类器来预测答案。</p><p>然而，在论文的实验过程中，观察到线性分类器在检索到的证据或背景知识上表现不佳。因此，论文引入了一种答案选择感知的注意机制来计算问题<script type="math/tex">h_{q}</script>和选择之间的注意分数，并且通过标准的注意计算来计算检索到的证据<script type="math/tex">h_{c}</script>和答案选择<script type="math/tex">h_{a}</script>之间的注意分数。</p><script type="math/tex; mode=display">O_{q a}=A T T\left(h_{q}, h_{a}\right), O_{c a}=A T T\left(h_{c}, h_{a}\right)</script><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-5.png" class=""><p>最后，将注意力重新加权的隐藏状态连接起来，通过线性分类器与ReLU进行传递，以计算最终的双向注意力向量进行预测。公式如下:</p><script type="math/tex; mode=display">P(q, a)=\operatorname{Linear}\left(O_{q a} h_{q}, O_{c a} h_{c}, h_{a}\right)</script><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul><li>pretrained model —— RoBERTa-large(24-layers)</li><li>max update step —— 6000</li><li>warmup update step —— 150</li><li>max length —— 512</li><li>dropout —— 0.1</li><li>optimizer —— Adam</li><li>loss function —— cross-entropy loss</li><li>batch size —— 4</li><li>learning rate —— 1e-5</li></ul><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-6.png" class=""><h3 id="创新有效性研究"><a href="#创新有效性研究" class="headerlink" title="创新有效性研究"></a>创新有效性研究</h3><p>左图是对使用多元知识库有效性的研究，可以看到证据来源的知识库越多，模型的表现越好。单知识库来源下，模型表现：剑桥字典 &gt; ConceptNet &gt; Wikipedia。</p><p>右图是对图的迭代知识检索以及QA感知注意力机制有效性的研究，实验证明，这两处创新皆能提升模型表现。</p><img src="/2020/11/25/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9F%A5%E8%AF%86%E5%BA%93%E8%BF%AD%E4%BB%A3%E6%A3%80%E7%B4%A2%E7%9A%84%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/GIR-7.png" class=""><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>处理多项选择题回答任务，需要额外的背景知识或常识。通过有效地整合多种知识资源，提出了一种基于图迭代检索的新的常识问答系统。首先，论文提出一个新的基于图的迭代知识检索模块来迭代检索与给定问题及其选择相关的概念和实体。此外，论文还提出了一种答案选择感知的注意机制，用于融合由预先训练的语言模型编码的所有隐藏层的状态表示。论文作者在CommonsenseQA数据集上进行了实验，实验结果表明，该方法在Commonsenseqa测试集上的准确率上明显优于其他模型。最后，论文进行了对创新的有效性研究，研究结果显示了基于图的迭代知识检索模块和答案选择感知注意模块在从多个知识源检索和合成背景知识方面的有效性。</p>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常识问答大比拼</title>
    <link href="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/"/>
    <url>/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="不同的道路"><a href="#不同的道路" class="headerlink" title="不同的道路"></a>不同的道路</h2><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/0.png" class=""><h3 id="不引入相关知识"><a href="#不引入相关知识" class="headerlink" title="不引入相关知识"></a>不引入相关知识</h3><h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><h5 id="BERT-MLP-Softmax"><a href="#BERT-MLP-Softmax" class="headerlink" title="BERT + MLP + Softmax"></a>BERT + MLP + Softmax</h5><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/1.png" class=""><p>BERT可以换成RoBERTa、XLNet或者ALBERT等。</p><h4 id="Text2Text"><a href="#Text2Text" class="headerlink" title="Text2Text"></a>Text2Text</h4><h5 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h5><p>提出了一种文本到文本的范式，需要指定任务类型。</p><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/4.png" class=""><h5 id="UnifiedQA"><a href="#UnifiedQA" class="headerlink" title="UnifiedQA"></a>UnifiedQA</h5><p>使用单个QA系统，跨越不同QA数据集的格式障碍。虽然基于T5，但不需要指定任务类型。</p><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/5.png" class=""><h3 id="引入相关知识"><a href="#引入相关知识" class="headerlink" title="引入相关知识"></a>引入相关知识</h3><h4 id="ConceptNet-Wikipedia-XLNet-GNN"><a href="#ConceptNet-Wikipedia-XLNet-GNN" class="headerlink" title="ConceptNet + Wikipedia + XLNet + GNN"></a>ConceptNet + Wikipedia + XLNet + GNN</h4><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/2.png" class=""><h4 id="ConceptNet-GPT2-ALBERT-RN"><a href="#ConceptNet-GPT2-ALBERT-RN" class="headerlink" title="ConceptNet + GPT2 + ALBERT + RN"></a>ConceptNet + GPT2 + ALBERT + RN</h4><img src="/2020/11/17/%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94%E5%A4%A7%E6%AF%94%E6%8B%BC/3.png" class=""><h4 id="ConceptNet-ALBERT-KCR"><a href="#ConceptNet-ALBERT-KCR" class="headerlink" title="ConceptNet + ALBERT + KCR"></a>ConceptNet + ALBERT + KCR</h4><ul><li>为每个QA对获取三元组路径<ul><li>找到三元组路径<ul><li>[CLS] stem [SEP] question_concept relation choice_concept [SEP]</li></ul></li><li>没找到三元组路径<ul><li>找到选项实体相关的其他三元组 —— [CLS] stem [SEP] choice_concept relation object [SEP]</li><li>没找到任何三元组 —— [CLS] stem [SEP] question_concept [SEP] choice_concept [SEP]</li></ul></li></ul></li><li>根据以上三种输入模式，经ALBERT文本编码得到文本嵌入hc</li><li>hc经过一个线性分类器得到QA对的置信得分</li></ul><h4 id="Wikipedia-ALBERT"><a href="#Wikipedia-ALBERT" class="headerlink" title="Wikipedia + ALBERT"></a>Wikipedia + ALBERT</h4><ul><li>清洗Wikipedia数据，得到word: definition形式的句子</li><li>输入构造 —— [CLS] ‘Q:’ + question [SEP] ‘A:’ + Choice + 10 recalled word of definition [SEP]</li><li>取ALBERT编码后得到的最后四层隐层向量的平均hc</li><li>hc经一个线性层和Softmax层得到归一化的QA对得分</li></ul>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预训练模型——开创NLP新纪元</title>
    <link href="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/"/>
    <url>/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h2 id="预训练模型——开创NLP新纪元"><a href="#预训练模型——开创NLP新纪元" class="headerlink" title="预训练模型——开创NLP新纪元"></a>预训练模型——开创NLP新纪元</h2><p><a href="https://arxiv.org/pdf/2003.08271v3.pdf">论文地址</a></p><p><a href="https://github.com/tomohideshibata/BERT-related-papers">BERT相关论文列表</a></p><p><a href="https://github.com/thunlp/PLMpapers">清华整理-预训练语言模型</a></p><p><a href="https://github.com/cedrickchee/awesome-bert-nlp">awesome-bert-nlp</a></p><p><a href="https://bertlang.unibocconi.it/">BERT Lang Street</a></p><p><a href="https://huggingface.co/models">huggingface models</a></p><h3 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h3><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-1.png" class=""><ul><li><p>对如今自然语言处理研究中常用的预训练模型进行了全面的概述，包括背景知识、模型架构、预训练任务、预训练模型的各种扩展、预训练模型的适应方法、预训练模型相关资源和应用。</p></li><li><p>基于现有的对预训练模型分类方法，从四个不同的角度提出了一个新的分类方法，它从四个不同的角度对现有的原型系统进行分类:</p><ul><li>表示类型</li><li>模型结构</li><li>预训练任务的类型</li><li>特定类型场景的扩展</li></ul></li><li><p>收集了大量的预训练模型的资源，包括预训练模型的开源实现、可视化工具、语料库和论文列表</p></li><li><p>针对预训练模型，提出了几个可能的未来研究方向。</p></li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="语言表示学习"><a href="#语言表示学习" class="headerlink" title="语言表示学习"></a>语言表示学习</h4><p>一个好的语言嵌入表示应该能够蕴含文本语料中隐含的语言规则和常识信息，例如<strong>词汇的含义、句法结构、语义角色、语用学</strong>等信息。<strong>分布式表示</strong>的核心在于用<strong>低维实值向量</strong>来描述一段文本的含义，该向量的每个维度上的值都没有对应的意义，但是向量<strong>整体代表了一个具体的概念</strong>。</p><h5 id="与上下文无关的嵌入"><a href="#与上下文无关的嵌入" class="headerlink" title="与上下文无关的嵌入"></a>与上下文无关的嵌入</h5><p>将离散的语言符号映射到分布式嵌入空间中，具体来说，对于词汇表 <script type="math/tex">\text{V}</script> 中每个单词 <script type="math/tex">x</script> ，将其映射成一个 <script type="math/tex">d</script> 维的实值向量，由此得到一个由<strong>词汇表中全部单词的嵌入向量作为列向量</strong>的嵌入矩阵 <script type="math/tex">\text{E}^{d × |\text{V}|}</script>，矩阵的列数就是词汇表 <script type="math/tex">\text{V}</script> 中单词的总数 <script type="math/tex">|\text{V}|</script>，矩阵的行数就是嵌入向量的维度 <script type="math/tex">d</script>。因此，<strong>单词 <script type="math/tex">x</script> 的嵌入向量 <script type="math/tex">e_{x}</script> 也可以由其唯一的独热编码 <script type="math/tex">h_{x}</script>乘上嵌入矩阵得到</strong>，即</p><script type="math/tex; mode=display">e_{x} = h_{x}E</script><p><strong>问题</strong></p><ul><li>嵌入是<strong>静态</strong>的，即单词的嵌入与上下文无关。然而当遇到<strong>多义词</strong>时，不跟据上下文语境的话，无法判断其真实代表的含义。</li><li><strong>词汇量不足</strong>。采用字符或者单词的<strong>子词</strong>作为基本表示单位。例如<strong>CharCNN、FastText</strong>和<strong>Byte-Pair Encoding</strong>等表示方法。</li></ul><h5 id="语境嵌入"><a href="#语境嵌入" class="headerlink" title="语境嵌入"></a>语境嵌入</h5><p>为了解决与上下文无关嵌入存在的问题，需要区分单词在不同语境下代表的语义。</p><p><strong>利用不同的神经上下文编码器 <script type="math/tex">f_{\mathrm{enc}} \left(·\right)</script> 对与上下文无关的嵌入 <script type="math/tex">x_{t}</script> 进行编码，得到蕴含上下文信息的语境嵌入 <script type="math/tex">h_{t}</script>。</strong></p><script type="math/tex; mode=display">\left[\mathbf{h}_{1}, \mathbf{h}_{2}, \cdots, \mathbf{h}_{T}\right]=f_{\mathrm{enc}}\left(x_{1}, x_{2}, \cdots, x_{T}\right)</script><p>下图是展示了利用神经编码器对上下文无关嵌入向量进行编码后得到语境嵌入，然后将其用于下游的面向具体任务的模型。</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-2.png" class=""><h4 id="神经上下文编码器"><a href="#神经上下文编码器" class="headerlink" title="神经上下文编码器"></a>神经上下文编码器</h4><p>大多数神经上下文编码器可以归结为两类：</p><ul><li><p><strong>序列模型</strong> —— 按照顺序捕捉单词的局部上下文信息</p><ul><li><strong>卷积模型</strong> —— 将输入句子中单词的嵌入作为输入，通过卷积运算<strong>聚集</strong>某个单词来自其<strong>邻居的局部信息</strong>来获取该单词的含义</li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-3.png" class=""><ul><li><strong>递归模型</strong> —— 递归模型<strong>捕捉短记忆单词的上下文表示</strong>，如<strong>LSTMs 和GRUs</strong>。从一个词的两边收集信息，但递归模型的性能往往受到<strong>长句子语义依赖问题</strong>的影响。</li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-4.png" class=""><ul><li><strong>优点</strong><ul><li>易于训练</li><li>对于各种自然语言处理任务能获得良好的结果</li></ul></li><li><strong>缺点</strong><ul><li>学到的单词的上下文表示具有局部性偏差</li><li>难以捕捉单词之间的长期交互</li></ul></li></ul></li></ul><ul><li><p><strong>非序列模型</strong> —— 非序列模型通过预先定义的单词之间的树或图结构来学习上下文表示，例如句法结构或语义关系。经典的模型包括<strong>Recursive NN、TreeLSTM和图卷积网络GCN。</strong></p><ul><li><p><strong>图模型存在的问题</strong> </p><ul><li>如何建立一个好的图结构也是一个具有挑战性的问题</li><li>图结构严重依赖于专家知识或外部NLP工具。</li></ul></li><li><p><strong>全连接自注意力模型</strong> </p><ul><li>为所有单词嵌入建立全连接图，让模型自行学习关系结构。</li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-5.png" class=""><ul><li>连接权重由自注意力机制动态计算得到</li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-6.png" class=""><ul><li><strong>Transformer</strong></li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-7.png" class=""></li><li><p><strong>优点</strong></p><ul><li>直接对序列中每两个单词之间的依存关系进行建模，更强大，已成为当前预训练模型采用的主流架构</li><li>更适合对语言的长程依存关系进行建模</li></ul></li><li><p><strong>缺点</strong></p><ul><li>由于其复杂而又沉重的架构以及较小的模型偏差，Transformer通常需要一个大的训练语料库进行训练</li><li>训练时，容易在小的或中等大小的数据集上出现过拟合问题</li></ul></li></ul></li></ul><h4 id="预训练模型诞生背景"><a href="#预训练模型诞生背景" class="headerlink" title="预训练模型诞生背景"></a>预训练模型诞生背景</h4><p>随着深度学习的发展，模型参数的数量迅速增加。需要更大的数据集来充分训练模型参数并防止过度拟合。然而，对于大多数自然语言处理任务来说，构建大规模标注数据集是一个巨大的挑战，因为标注成本非常昂贵，尤其是对于语法和语义相关的任务。相比之下，大规模的无标签语料库相对容易构建。</p><p>为了利用大量未标记的文本数据，可以首先从它们那里学习一个好的表示，然后将这些表示用于其他任务。研究表明，借助于从大型未标注语料库的语料库中提取的表征，许多自然语言处理任务的性能有了显著提高。</p><p>预训练的优势有如下几点：</p><ul><li>在大规模文本语料库中能学习到一般的语言表示以用于下游任务</li><li>使得下游任务采用的模型能更好地被初始化，并获得更好的泛化表现，加速下游任务模型的收敛</li><li>预训练可以看作一种正则化的方式，避免模型在小规模数据上过拟合</li></ul><h4 id="预训练模型的发展史"><a href="#预训练模型的发展史" class="headerlink" title="预训练模型的发展史"></a>预训练模型的发展史</h4><p>预训练一直是学习模型参数的一种有效策略，预训练完毕之后，利用标记数据对模型参数进行微调以适应下游任务。</p><h5 id="第一代：预训练词嵌入"><a href="#第一代：预训练词嵌入" class="headerlink" title="第一代：预训练词嵌入"></a>第一代：预训练词嵌入</h5><p><strong>模型发展：</strong></p><ul><li><strong>NNLM</strong></li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-8.png" class=""><p><strong>学习任务</strong></p><p>输入某个句子中某个单词的前 <script type="math/tex">t-1</script> 个单词，要求NNLM网络<strong>最大化</strong>第 <script type="math/tex">t</script> 个位置出现该单词的概率，例如给定文本句子：”The most popular pre-train models is Bert”，根据前6个单词，让模型预测单词”Bert”即最大化以下概率：</p><script type="math/tex; mode=display">P\left(W_{t}="Bert" \mid W_{1},W_{2},W_{3},\cdots，W_{t-1};\theta\right)</script><p>其中 <script type="math/tex">W_{i}</script> 为单词的独热编码，它们作为模型的初始输入，<script type="math/tex">W_{i}</script> 乘上矩阵 <script type="math/tex">Q</script> 之后就得到对应单词的word embedding值 <script type="math/tex">C\left(W_{i}\right)</script>。将每个单词的word embdding拼接起来，上接隐层向量，然后经过一个 <script type="math/tex">softmax</script> 层预测后面紧跟着应该接哪个词。</p><p>事实上，矩阵 <script type="math/tex">Q</script> 的每一行代表着对应单词的word embedding值，只不过矩阵 <script type="math/tex">Q</script> 的内容也是模型参数，需要学习获得，<script type="math/tex">Q</script> 最初用随机值初始化。当模型训练完毕，矩阵 <script type="math/tex">Q</script> 就是NNLM模型在大规模文本语料库上完成语言模型的训练任务后得到的副产品，这个 <script type="math/tex">Q</script> 的每一行都是对应单词的嵌word embedding。</p><ul><li><p><strong>Word2Vec</strong> —— 基于预测的模型(两种不同训练方式)</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-9.png" class=""><ul><li><p><strong>CBOW</strong> —— 从上下文预测中间词(完形填空)</p></li><li><p><strong>Skip-Gram</strong> —— 从中间词预测上下文</p></li></ul></li><li><p><strong>Glove</strong> —— 基于统计的模型</p><p>基于全局语料库构建词的<strong>共现矩阵</strong>，矩阵的每一行是一个word，每一列是context。共现矩阵就是计算每个word在每个context出现的频率。通过对词的共现计数矩阵进行降维，来得到词向量；首先需要根据整个语料建立一个大型的体现词共现情况的矩阵，其<strong>目标是优化减小重建损失</strong>(reconstruction loss)，即降维之后的向量能尽量表达原始向量的完整信息。</p><p>GloVe 相对于 Word2Vec 有一个优点是<strong>更容易并行化执行</strong>，可以更快，更容易地在大规模语料上训练。</p></li></ul><p><strong>第一代预训练词嵌入的优势：</strong></p><ul><li>尽管网络结构简单，但是仍然可以学习到高质量的单词嵌入来捕捉单词之间潜在的句法和语义相似性</li></ul><p><strong>不足之处：</strong></p><ul><li>得到的词嵌入向量与上下文无关，当词嵌入被应用于下游任务时，模型的其他参数需要重新训练。</li></ul><h5 id="第二代：预训练语境编码器"><a href="#第二代：预训练语境编码器" class="headerlink" title="第二代：预训练语境编码器"></a>第二代：预训练语境编码器</h5><p><strong>模型发展</strong>：</p><script type="math/tex; mode=display">\text{ELMO} \rightarrow \text{GPT} \rightarrow \text{BERT}</script><p>由于大多数自然语言处理任务超出了单词层面，自然要在句子层面或更高层面对神经编码器进行预训练。神经编码器的输出向量也被称为上下文单词嵌入，因为它们根据单词的上下文来表示单词的语义。</p><p>研究者发现，序列模型<strong>Seq2Seq</strong>在做文本分类任务时，编码器和解码器的权重用两种语言模型的预训练权重初始化，然后用标记数据微调。模型的表现大大提升。</p><p>现如今，预训练模型通常使用<strong>更大规模</strong>的语料库、更复杂的神经网络模型结构(例如，Transformer)和新的预训练任务来训练。</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-10.png" class=""><ul><li><p><strong>ELMo</strong></p><ul><li><p><strong>预训练阶段</strong></p><ul><li>利用<strong>语言模型</strong>进行预训练，该语言模型的任务是根据单词的上下文序列正确预测该单词。</li><li><strong>ELMO</strong>网络结构<strong>采用了双层双向LSTM</strong>，左右两端分别是正反向的双层的LSTM编码器。</li><li>模型输入的句子中每个单词都能得到对应的三个嵌入向量：最底层的(<strong>黄色部分</strong>)是词嵌入Word Embedding，第一层双向LSTM中对应单词位置的Embedding，蕴含单词的<strong>句法信息</strong>；然后第二层LSTM中对应单词位置的Embedding，蕴含单词的<strong>语义信息</strong>。</li></ul></li><li><p><strong>微调阶段</strong></p><ul><li>将下游任务模型的输入通过ELMO进行编码得到文本嵌入，集成三种Embedding，将整合后的Embedding用于下游任务模型网络结构中对应单词的输入。</li></ul></li><li><p><strong>特点</strong></p><ul><li>采用了典型的<strong>预训练-微调</strong>的两阶段过程</li><li>预训练过程中，不仅学会了单词的word embedding，还学到了一个双层双向的LSTM网络结构，这个双层双向的网络结构可以用来提取文本的句法信息、语义信息。</li></ul></li><li><p><strong>不足</strong></p><ul><li>LSTM的<strong>特征抽取能力</strong>远比不上Transformer</li><li>双向拼接的<strong>融合特征的能力</strong>不够强</li></ul></li></ul></li><li><p><strong>GPT</strong></p><ul><li><p><strong>预训练阶段</strong></p><ul><li>预训练的过程其实和ELMO类似，仍然以语言模型为目标任务，但是<strong>语言模型改成单向</strong>的，即只根据上文正确预测当前位置的单词，而把单词的下文完全抛开。</li><li>特征抽取器换成了<strong>Transformer</strong>,特征抽取的能力大大提升</li></ul></li><li><p><strong>微调阶段</strong></p><ul><li><p>对于不同的下游任务，<strong>网络结构要向GPT的网络结构看齐</strong>。在做下游任务的时候，利用预训练好的参数初始化GPT的网络结构，这样通过预训练学到的语言学知识就被引入到下游任务中。</p></li><li><p>模型参数初始化后，用下游任务去训练这个网络，对网络参数进行Fine-tuning，使得网络更适合解决下游问题。</p></li><li><p>改造下游任务<br>（1）对于<strong>分类</strong>问题，加上一个起始和终结符号即可；<br>（2）对于<strong>句子关系</strong>判断问题，比如Entailment NLI，两个句子中间再加个分隔符即可；<br>（3）对<strong>文本相似性</strong>判断问题，把两个句子顺序颠倒下做出两个输入即可，这是为了告诉模型句子顺序不重要；<br>（4）对于<strong>多项选择</strong>问题，则多路输入，每一路把文章和答案选项拼接作为输入即可</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-12.png" class=""></li></ul></li><li><p><strong>特点</strong></p><ul><li>训练的是单向语言模型</li><li>采用更强大的特征提取器Transformer</li></ul></li><li><p><strong>不足</strong></p><ul><li>单向语言模型改成双向就好了</li></ul></li></ul></li><li><p><strong>BERT</strong></p><ul><li><p><strong>预训练阶段</strong></p><ul><li><p><strong>MLM(掩盖语言模型)</strong></p><p>（1）<strong>MLM</strong>任务，即<strong>随机屏蔽</strong>(MASK)部分输入token，然后只预测那些被屏蔽的token。</p><p>（2）但是这么干之后，预训练阶段和finetuning阶段之间就不匹配了，因为在finetuning期间不会见到[MASK]。为了解决这个问题，BERT的做法是：不总是用实际的[MASK]替换被“masked”的词汇。相反，训练一个数据生成器随机选择15％的token，执行以下过程：</p><p><strong>80％</strong>的时间：用<strong>[MASK]标记替换</strong>单词，例如，my dog is hairy → my dog is [MASK]<br><strong>10％</strong>的时间：用一个<strong>随机的单词替换</strong>该单词，例如，my dog is hairy → my dog is apple<br><strong>10％</strong>的时间：保持单词<strong>不变</strong>，例如，my dog is hairy → my dog is hairy. </p><p>（3）<strong>缺陷</strong>：MLM模型下，一些单词会被随机替换，而Transformer的encoder部分不知道它将被要求预测的那些单词或哪些单词已被随机单词替换，因此它被迫保持每个输入token的分布式上下文表示。同时，由于训练MLM时，每个batch只预测了15％的token，这表明模型可能需要更多的预训练步骤才能收敛。这无疑增加了训练成本。</p></li><li><p>和GPT不同的地方在于，BERT采用和ELMO一样的<strong>双向语言模型任务</strong>作为预训练任务；</p></li><li><p>和ELMO不同的地方在于，BERT采用和GPT一样的特征提取器<strong>Transformer</strong>，集两家之所长。</p></li></ul></li><li><p><strong>微调阶段</strong></p><ul><li><p>和GPT一样，BERT也面临对下游任务进行改造的问题</p></li><li><p>改造下游任务</p><p><strong>（1）句子对分类</strong> —— 在句子开头加上[<strong>CLS</strong>]，后接单句的组成token，句子对之间用[<strong>SEP</strong>]分隔开，最后[<strong>CLS</strong>]对应位置输出的向量 <script type="math/tex">C</script> 由于不具备特别的语义特征，因此能更好地表示整个<strong>句对的语义信息</strong>。最后， 把第一个起始符号对应的<strong>Transformer</strong>最后一层位置上的输出 <script type="math/tex">C</script> 串接一个 <script type="math/tex">\mathbf{softmax}</script> 分类层对句对关系进行分类</p><p><strong>（2）单句分类</strong> —— [<strong>CLS</strong>]作为句子开头，后接单句的组成token，同样[<strong>CLS</strong>]对应位置输出的向量 <script type="math/tex">C</script> 后接上一个 <script type="math/tex">\mathbf{softmax}</script>分类器对句子进行分类</p><p><strong>（3）问答</strong> —— [<strong>CLS</strong>]作为句子开头，问题句的组成token和背景文本句的组成token用[<strong>SEP</strong>]隔开，将每个属于背景句子的token所在对应位置的输出向量与<strong>Start</strong>向量<strong>做点积算得分</strong>，根据得分确定答案在背景文本中的起始位置，结束位置的确定也是一样。最后在背景文本中，<strong>起始位置和结束位置之间对应的这段文本就当作问题的最终回答</strong>。</p><p><strong>（4）序列标注</strong> —— [<strong>CLS</strong>]作为句子开头，后接单句的组成token，将每个token对应位置输出的向量输入到一个多分类器中，输出每个token的标注分类预测。</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-13.png" class=""></li></ul></li><li><p><strong>特点</strong></p><ul><li><p><strong>MLM</strong>双向语言模型</p></li><li><p><strong>Transformer</strong>做特征提取器</p></li><li><p><strong>BERT</strong>输入部分的处理</p><p><strong>输入部分是个线性序列</strong>，两个句子通过分隔符分割，最前面和最后增加两个标识符号。每个单词有三个embedding</p><p>(1)<strong>单词embedding</strong> </p><p>​    预训练后得到的单词Embedding。</p><p>(2)<strong>位置embedding</strong></p><p>​    自注意力机制没有位置概念，每个位置等同看待，为了弄清楚token所在位置，需要引入位置嵌入，告诉模型当前的token处于句子的什么位置。</p><p>(3)<strong>句子embedding</strong></p><p>​    整个句子的Embedding代表了整个句子的语义信息，句子嵌入需要给到那个句子中每个token。</p><p>把单词对应的三个embedding叠加，就形成了Bert的输入。</p></li></ul></li></ul></li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-14.png" class=""><ul><li><p><strong>不足</strong></p><ul><li>同预训练阶段<strong>MLM</strong>模型的缺陷</li></ul></li></ul><h3 id="预训练模型概览"><a href="#预训练模型概览" class="headerlink" title="预训练模型概览"></a>预训练模型概览</h3><h4 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h4><h5 id="语言模型-LM"><a href="#语言模型-LM" class="headerlink" title="语言模型(LM)"></a>语言模型(LM)</h5><p>语言模型通常特指自回归语言模型或者单向语言模型。</p><ul><li><strong>任务</strong> —— 给定上文，根据紧接着的下一词汇在词汇表中的概率分布输出更可能的下文，即最大化句子出现的概率。给定一串文本序列 <script type="math/tex">x_{1:T} = \left[ x_{1},x_{2}, \dots, x_{T} \right]</script>，其联合分布概率可以表示为如下条件概率的乘积：</li></ul><script type="math/tex; mode=display">p\left(\mathbf{x}_{1: T}\right)=\prod_{t=1}^{T} p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)</script><p>其中，<script type="math/tex">x_{0}</script> 为起始标记 <script type="math/tex">[Start]</script> 对应的token。上述条件概率 <script type="math/tex">p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)</script> 可以通过计算给定语境下(即上文<script type="math/tex">x_{0:t-1}</script>) 词汇表中所有词的概率分布来建模，其中，语境上文又可以通过神经编码器 <script type="math/tex">f_{enc}(·)</script> 来进行编码，利用一个预测层 <script type="math/tex">g_{LM}(·)</script> 输出词汇表中所有词在当前位置出现的概率分布。</p><script type="math/tex; mode=display">p\left(x_{t} \mid \mathbf{x}_{0: t-1}\right)=g_{LM}( f_{enc}(x_{0:t-1}))</script><p>当给定一个巨大的语料库时，可以用最大似然估计来训练整个网络。</p><ul><li><strong>缺点</strong> —— 每个token的表示只编码了上文的token和它自己。然而，更好的文本语境表示应该编码来自上文和下文两个方向的上下文信息。</li><li><strong>改进</strong> —— 考虑单向LM的缺陷，用两个单向LM组合起来构成双向LM(BiLM)。BiLM由两个单向LM组成：一个向前的从左到右LM和一个向后的从右到左LM。</li><li><strong>代表模型</strong><ul><li>单向 —— GPT、GPT2、GPT3</li><li>双向 —— ELMO</li></ul></li></ul><h5 id="掩盖语言模型-MLM"><a href="#掩盖语言模型-MLM" class="headerlink" title="掩盖语言模型(MLM)"></a>掩盖语言模型(MLM)</h5><ul><li><strong>任务</strong> —— 完形填空(cloze task)，从文本中的其他词预测当前被掩盖位置最可能出现的词。由于是同时考虑文本的上文和下文对掩盖词进行预测，因此MLM很好地克服了标准单向线性模型语境编码不完全的缺点。</li><li><strong>缺点</strong> —— 由于MLM首先会从输入文本中随机掩盖掉一些token，然后用其余的token来预测掩盖掉的token。因此，这种预训练方法会在预训练阶段和微调阶段之间造成不匹配，因为 <script type="math/tex">[MASK]</script> 不会在微调阶段出现。</li><li><strong>改进</strong>  —— 不总是用 <script type="math/tex">[MASK]</script> 进行替换，训练一个数据生成器<ul><li>在80%的时间内使用特殊的[MASK]进行替换</li><li>在10%的时间内使用随机的token执行替换</li><li>在10%的时间内使用原始token来执行替换</li></ul></li><li><strong>代表模型</strong> —— BERT及其庞大的BERT家族</li></ul><h5 id="排列语言模型-PLM"><a href="#排列语言模型-PLM" class="headerlink" title="排列语言模型(PLM)"></a>排列语言模型(PLM)</h5><p>虽然MLM效果惊人，但是不能忽视的是，MLM在预训练中使用的一些特殊标记(如[MASK])在模型应用于下游任务时并不存在，这导致预训练和微调之间存在差距。为了克服这个问题，提出了排列语言模型PLM。</p><ul><li><strong>任务</strong> —— 基于输入序列的随机排列的语言建模。简单来说，就是从所有可能的排列中随机抽样一个排列。然后，将排列序列中的一些token作为目标，然后训练模型来预测这些目标。需要注意的是，这种随机排列不会影响序列的自然位置，仅会定义token预测的顺序。</li><li><strong>代表模型</strong> —— XLNet</li></ul><h5 id="去噪自编码器-DAE"><a href="#去噪自编码器-DAE" class="headerlink" title="去噪自编码器(DAE)"></a>去噪自编码器(DAE)</h5><ul><li><strong>任务</strong> —— 输入部分损坏的文本，重建原始的未失真的文本。</li></ul><p>破坏文本的方式有：</p><ol><li>token掩盖：从输入中随机采样token，并用[MASK]替换它们。</li><li>token删除：从输入中随机删除token。与掩盖token不同，模型需要确定缺失输入的位置。</li><li>文本填充：像SpanBERT一样，许多文本跨度被采样并用单个[MASK]标记替换。每个跨度长度由泊松分布(λ = 3)得出。该模型需要预测一个跨度中缺少多少个token。</li><li>句子排列：根据句号将文档分成句子，并以随机顺序排列这些句子。</li><li>文档翻转：随机均匀地选择一个token，并翻转文档，使其从该token开始。模型需要识别文档的真正开始位置</li></ol><h5 id="比较学习-CL"><a href="#比较学习-CL" class="headerlink" title="比较学习(CL)"></a>比较学习(CL)</h5><ul><li><strong>总体任务</strong> —— 假设一些观察到的文本对在语义上比随机抽样的文本更相似。学习文本对 <script type="math/tex">(x，y)</script> 的得分函数 <script type="math/tex">s(x，y)</script> 以最小化目标函数：</li></ul><script type="math/tex; mode=display">\mathcal{L}_{\mathrm{CTL}}=\mathbb{E}_{x, y^{+}, y^{-}}\left[-\log \frac{\exp \left(s\left(x, y^{+}\right)\right)}{\exp \left(s\left(x, y^{+}\right)\right)+\exp \left(s\left(x, y^{-}\right)\right)}\right]</script><p>其中，<script type="math/tex">\left(x, y^{+}\right)</script> 是更相似的一对，<script type="math/tex">y^{+}</script> 和 <script type="math/tex">y^{-}</script> 分别为正样本和负样本。文本对的得分函数 <script type="math/tex">s(x，y)</script> 通常通过训练神经网络来学习。</p><p>训练的方式有两种：</p><script type="math/tex; mode=display">s(x, y)=f_{\mathrm{enc}(x)}^{\mathrm{T}} f_{\mathrm{enc}(y)}</script><script type="math/tex; mode=display">s(x, y)=f_{\text {enc }}(x \oplus y)</script><ul><li><strong>代表任务</strong> <ul><li>下一句预测(NSP) —— NSP训练模型来区分两个输入句子是否是来自训练语料库的连续片段。具体来说，在为每个预训练例子选择句子对时，50%的时候，第二句是第一句的实际下一句，50%的时候，是从语料库中随机抽取的一句。通过这样做，它能够教模型理解两个输入句子之间的关系，从而有利于对该信息敏感的下游任务，例如问答和自然语言推理。 但是NSP任务的有效性和必要性备受质疑。</li><li>句子顺序预测(SOP) —— 和NSP不同，SOP使用同一文档中的两个连续片段作为正面示例，使用相同的两个连续片段，但它们的顺序交换作为反面示例。</li></ul></li></ul><h4 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h4><p>为了阐明自然语言处理中现有预训练模型之间的关系，可以从四个不同的角度对现有预训练模型进行分类：</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-15.png" class=""><ul><li><p>表示类型</p><ul><li>与上下文独立的表示 —— Word2Vec、Glove等</li><li>与上下文相关的表示 —— ELMO、GPT、BERT等</li></ul></li><li><p>架构(基础网络)</p><ul><li>LSTM —— ELMO</li><li>Transformer<ul><li>encoder —— BERT</li><li>decoder —— GPT（使用了三角矩阵实现了掩盖自注意力机制，即不允许模型在预测的时候看到下文）</li><li>full</li></ul></li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-16.png" class=""></li><li><p>预训练任务</p><ul><li>监督学习 —— 学习一个函数，该函数基于由输入输出对组成的训练数据将输入映射到输出。</li><li>无监督 —— 从未标记的数据中发现一些内在的知识，如LM。</li><li>自监督 —— 监督学习和非监督学习的结合，学习范式和监督学习完全一样，只是训练数据的标签是自动生成的。关键思想是从其他部分以某种形式预测输入的任何部分。如MLM。</li></ul></li><li><p>扩展：特定场景下的预训练模型，包括知识丰富的预训练模型、多语言或特定语言的预训练模型、多模型预训练模型、特定领域的预训练模型等</p></li></ul><h4 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h4><h5 id="非上下文词嵌入"><a href="#非上下文词嵌入" class="headerlink" title="非上下文词嵌入"></a>非上下文词嵌入</h5><ul><li><strong>思想</strong> —— 通过神经网络语言模型学习的单词表示能够捕捉语言中的语言规律，单词之间的关系可以通过特定关系的向量偏移来表征。例如，<script type="math/tex">vec(“China”) − vec(“Beijing”) ≈ vec(“Japan”) −vec(“Tokyo”)</script> ，另外，经过神经语言模型训练得到的词向量还具有组合性，<script type="math/tex">vec(“Germany”) + vec(“capital”) ≈ vec(“Berlin”)</script>。</li><li><strong>缺点</strong> —— 这种分布式单词表示擅长预测分类属性(例如，狗是一种动物)，但不能真正学习属性(例如，天是蓝的)。而且，考虑到多义词需要结合上下文语境进行词义的判断，而这种与上下文无关的分布式词表示往往无法代表词的正确意思。</li></ul><h5 id="上下文词嵌入"><a href="#上下文词嵌入" class="headerlink" title="上下文词嵌入"></a>上下文词嵌入</h5><ul><li><strong>思想</strong> —— 在做语言模型任务时，把上下文语境文本融合进词表示向量，使得词表示向量能够蕴含除词本义之外的上下文语义知识信息和语言学信息。<ul><li>语言学信息 —— 研究人员从BERT中提取依赖树和支持树，证明了BERT对语法结构进行编码的能力。<ul><li>语言特征似乎表现在单独的语义和句法子空间中</li><li>注意矩阵包含语法表征</li><li>BERT非常精细地区分词义。</li></ul></li><li>语义知识信息 —— 除了语言知识，预训练模型还可以存储训练数据中呈现的世界知识。探索世界知识的一个简单方法是用“填空”完形填空语句来查询BERT，例如，“但丁诞生于[MASK]”。研究人员通过从几个知识来源手动创建单标记完形填空语句(查询)来构建LAMA(语言模型分析)任务。他们的实验表明BERT包含的世界知识比传统的信息抽取方法更有竞争力。</li></ul></li></ul><h3 id="预训练模型拓展"><a href="#预训练模型拓展" class="headerlink" title="预训练模型拓展"></a>预训练模型拓展</h3><h4 id="基于知识增强"><a href="#基于知识增强" class="headerlink" title="基于知识增强"></a>基于知识增强</h4><ul><li><strong>思想</strong> —— 将外部知识纳入预训练模型</li><li><strong>代表模型</strong><ul><li>LIBERT —— 通过额外的语言限制任务整合语言知识</li><li>SentiLR —— 集成每个词的情感极性，将MLM扩展为具有标签感知能力的MLM(LA-MLM)</li><li>SenseBERT —— 经过预先训练，不仅可以预测掩码标记，还可以预测它们在WordNet中的超集。</li><li>ERNIE —— 将预先在知识图上训练的实体嵌入与文本中相应的实体提及相结合，以增强文本表示。</li><li>KnowBERT —— 将BERT与实体链接模型结合起来，以端到端的方式整合实体表示。</li><li>K-BERT —— 允许在对下游任务进行微调的过程中注入事实知识。</li><li>知识-文本融合模型 —— 机器阅读理解中获取相关语言和事实知识。</li></ul></li></ul><h4 id="基于多语言和特定语言"><a href="#基于多语言和特定语言" class="headerlink" title="基于多语言和特定语言"></a>基于多语言和特定语言</h4><ul><li>多语言<ul><li>跨语言理解</li><li>跨语言生成</li></ul></li><li>特定语言</li></ul><h4 id="基于多模态"><a href="#基于多模态" class="headerlink" title="基于多模态"></a>基于多模态</h4><p>这些多模态模型中的绝大多数是为一般的视觉和语言特征编码而设计的。这些模型是在大量跨模态数据的基础上进行预训练的（如带有口语词的视频或带有字幕的图像），并结合扩展的预训练任务来充分利用多模态特征。</p><h5 id="视频-文本-Video-Text"><a href="#视频-文本-Video-Text" class="headerlink" title="视频-文本(Video-Text)"></a>视频-文本(Video-Text)</h5><p>视频分别由基于CNN的编码器和现成的语音识别技术进行预处理。使用一个单独的Transformer编码器在处理过的数据上进行训练，学习视频字幕等下游任务的视觉语言表示。代表模型有，VideoBERT和CBT。</p><h5 id="图像-文本-Image-Text"><a href="#图像-文本-Image-Text" class="headerlink" title="图像-文本(Image-Text)"></a>图像-文本(Image-Text)</h5><p>引入图像-文本对，旨在微调下游任务，如视觉问题回答(<strong>VQA</strong>)和视觉常识推理(<strong>VCR</strong>)。</p><p><strong>分类：</strong></p><ul><li>采用两个独立的编码器来独立地表示图像和文本， 例如ViLBERT和LXMERT。</li><li>使用single-stream unified Transformer,虽然这些模型体系结构不同，但是在这些方法中引入了类似的预训练任务，例如MLM和图像-文本匹配。例如，VisualBERT，B2T2，VLBERT， Unicoder-VL和UNITER。</li></ul><h5 id="音频-文本-Audio-Text"><a href="#音频-文本-Audio-Text" class="headerlink" title="音频-文本(Audio-Text)"></a>音频-文本(Audio-Text)</h5><p>SpeechBERT模型试图用一个Transformer编码器编码音频和文本以建立一个端到端的语音问答(SQA)模型。</p><h4 id="基于特定领域与任务"><a href="#基于特定领域与任务" class="headerlink" title="基于特定领域与任务"></a>基于特定领域与任务</h4><p>大多数预训练模型都是在维基百科等通用领域语料库上进行预训练的，这限制了它们在特定领域或任务上的应用。</p><ul><li><strong>训练特定领域预训练模型</strong><ul><li>生物医学 —— BioBERT</li><li>科学 —— SciBERT </li><li>临床医学 —— ClinicalBERT</li></ul></li><li><strong>利用通用领域预训练模型适应具体任务</strong><ul><li>情感分析 —— 感知情感标签的MLM</li><li>文本摘要 —— 间歇句生成</li><li>不流畅检测 —— 噪声词检测</li></ul></li></ul><h4 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h4><ul><li><strong>动机</strong> —— 预训练模型参数量过于庞大，很难在现实应用和资源受限的设备上进行部署，因此，如何压缩模型也成为了研究的一个热点。</li><li><strong>模型压缩方法</strong> —— 一种减小模型尺寸和提高计算效率的潜在方法<ul><li><strong>模型修剪</strong> —— 去除不重要的参数，具体来说，就是去除部分神经网络(如权值、神经元、层、通道、注意头)，从而达到减小模型规模、加快推理时间的效果。修剪选择和修剪时机的把握有待研究。</li><li>连接权重量化 —— 用较少的比特表示参数，将精度较高的参数压缩到较低的精度。</li><li><strong>参数共享</strong> —— 对于那些相似的模型单元，共享它们的参数。这种方法广泛应用于CNNs、RNNs和Transformer。例如，ALBERT使用跨层参数共享和因子化嵌入参数化来减少模型的参数。虽然参数数量大大减少，但是ALBERT的训练和推理时间甚至比标准的BERT还要长。通常，参数共享不会提高推理阶段的计算效率。</li><li><strong>知识提取</strong> —— 在原模型的基础上，根据原模型的中间结果学习一个更小的模型</li><li>模块替换 —— 用更紧凑的模块替换原模型具有相似功能的模块。例如使用<strong>Theseus-Compress</strong>，压缩模型的同时保持98%的模型性能，速度是原来的1.4倍。</li></ul></li></ul><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-17.png" class=""><h3 id="预训练模型应用于下游任务"><a href="#预训练模型应用于下游任务" class="headerlink" title="预训练模型应用于下游任务"></a>预训练模型应用于下游任务</h3><h4 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h4><p>迁移学习是将知识从源任务(或领域)调整到目标任务(或领域)。</p><img src="/2020/11/16/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E5%BC%80%E5%88%9BNLP%E6%96%B0%E7%BA%AA%E5%85%83/PTM-18.png" class=""><h4 id="如何迁移"><a href="#如何迁移" class="headerlink" title="如何迁移"></a>如何迁移</h4><ul><li><p>选择合适的预训练任务、模型架构和语料库</p><ul><li>不同的预训练任务有各自的偏向，对不同的任务有不同的效果。例如，NSP任务使预训练模型学习了两句话之间的关系。因此，训练后的预训练模型可以受益于问答和自然语言推理(NLI)等下游任务。</li><li>BERT虽然能很好地解决自然语言推理任务，但是很难用于生成式的任务。</li><li>下游任务的数据分布应该接近预训练模型。</li></ul></li><li><p>选择合适的层</p><ul><li><p>给定一个预先训练的深度模型，不同的层应该捕获不同种类的信息，例如词性标注、解析、长期依赖、语义角色、共指。对于基于RNN的模型，研究表明，多层LSTM编码器的不同层学习到的表示有益于不同的任务。</p></li><li><p>有三种方法可以选择表示：</p><ul><li>只选择预先训练的静态嵌入表示，而模型的其余部分仍然需要为新的目标任务从头开始训练。这些部分无法获取更高级别的信息，而这些信息可能更有用。</li><li>顶层表示。最简单有效的方法是将顶层的表示馈入特定任务模型。</li><li>所有层。更灵活的方法是自动选择最佳层：</li></ul><script type="math/tex; mode=display">\mathbf{r}_{t}=\gamma \sum_{l=1}^{L} \alpha_{l} \mathbf{h}_{t}^{(l)}</script><p>​            其中，<script type="math/tex">\alpha</script> 表示 <script type="math/tex">l</script> 层的软最大归一化权重，<script type="math/tex">\gamma</script>是缩放预训练模型输出的向量的标量。混合表示 <script type="math/tex">r_{t}</script> 被输入到特定任务模型中。</p></li></ul></li></ul><h4 id="微调策略"><a href="#微调策略" class="headerlink" title="微调策略"></a>微调策略</h4><ul><li><strong>两阶段微调</strong> —— 在第一阶段，预训练模型被转换成一个由中间任务或语料库微调的模型。在第二阶段，转移的模型被微调到目标任务。</li><li><strong>多任务微调</strong> —— 多任务学习框架下的微调BERT，多任务学习和预训练是互补的技术。</li><li><strong>使用额外的自适应模块进行微调</strong> —— 微调的主要缺点是参数效率低，每个下游任务都有自己的微调参数。因此，更好的解决方案是在原始参数固定的情况下，往预训练模型中注入一些可微调的自适应模块。</li></ul><h3 id="预训练模型资源"><a href="#预训练模型资源" class="headerlink" title="预训练模型资源"></a>预训练模型资源</h3><ul><li><strong>预训练模型的开源实现</strong><ul><li><a href="https://github.com/tmikolov/word2vec">word2vec</a></li><li><a href="https://nlp.stanford.edu/projects/glove">GloVe</a></li><li><a href="https://github.com/facebookresearch/fastText">FastText</a></li><li><a href="https://github.com/huggingface/transformers">Transformer</a></li><li><a href="https://github.com/pytorch/fairseq">Fairseq</a></li><li><a href="https://github.com/flairNLP/flair">Flair</a></li><li><a href="https://github.com/allenai/allennlp">AllenNLP</a></li><li><a href="https://github.com/fastnlp/fastNLP">fastNLP</a></li><li><a href="https://github.com/microsoft/unilm">UniLMs</a></li><li><a href="https://github.com/ymcui/Chinese-BERT-wwm">Chinese-BERT</a></li><li><a href="https://github.com/google-research/bert">BERT</a></li><li><a href="https://github.com/pytorch/fairseq/tree/master/examples/roberta">RoBERTa</a></li><li><a href="https://github.com/zihangdai/xlnet/">XLNet</a></li><li><a href="https://github.com/google-research/ALBERT">ALBERT</a></li><li><a href="https://github.com/google-research/text-to-text-transfer-transformer">T5</a></li><li><a href="https://github.com/PaddlePaddle/ERNIE">ERNIE</a></li><li><a href="https://github.com/salesforce/ctrl">CTRL</a></li><li><a href="https://github.com/jessevig/bertviz">BertViz</a></li><li><a href="https://github.com/bhoov/exbert">exBERT</a></li><li><a href="https://github.com/airaria/TextBrewer">TextBrewer</a></li><li><a href="https://github.com/deepmipt/DeepPavlov">DeepPavlov</a></li></ul></li><li>语料库<ul><li><a href="https://github.com/jcpeterson/openwebtext">OpenWebText</a></li><li><a href="http://commoncrawl.org/">Common Crawl</a></li><li><a href="https://dumps.wikimedia.org/enwiki/">WikiEn</a></li></ul></li></ul><h3 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h3><ul><li>预训练模型还未到达上限 —— 模型可以通过更多的训练步骤和更大的语料库来进一步改进。</li><li>预训练模型架构优化 —— 为预训练模型寻找更有效的模型架构对于获取更大范围的上下文信息非常重要。深度架构的设计具有挑战性，可能会寻求一些自动化方法的帮助，比如神经架构搜索。</li><li>面向任务的预训练和模型压缩</li><li>实现超越微调的知识转移</li><li>提高预训练模型的可解释性和可靠性</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] Qiu X, Sun T, Xu Y, et al. Pre-trained models for natural language processing: A survey[J]. arXiv preprint arXiv:2003.08271, 2020.</p><p>[2] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.</p><p>[3] Radford A, Narasimhan K, Salimans T, et al. Improving language understanding by generative pre-training[J]. 2018.</p><p>[4] Yang Z, Dai Z, Yang Y, et al. Xlnet: Generalized autoregressive pretraining for language understanding[C]//Advances in neural information processing systems. 2019: 5753-5763.</p><p>[5] <a href="https://zhuanlan.zhihu.com/p/49271699">从Word Embedding到Bert模型—自然语言处理中的预训练技术发展史 by 张俊林</a></p>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常识Transformer用于自动知识图构建</title>
    <link href="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="《COMET：Commonsense-Transformers-for-Automatic-Knowledge-Graph-Construction》"><a href="#《COMET：Commonsense-Transformers-for-Automatic-Knowledge-Graph-Construction》" class="headerlink" title="《COMET：Commonsense Transformers for Automatic Knowledge Graph Construction》"></a>《COMET：Commonsense Transformers for Automatic Knowledge Graph Construction》</h3><p><a href="https://arxiv.org/pdf/1906.05317v2.pdf">论文地址</a></p><p><a href="https://github.com/atcbosselut/comet-commonsense">论文源码</a></p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ul><li><strong>目的层面</strong> —— 根据两个当前最常用的常识知识图<strong>ATOMIC</strong>和<strong>ConceptNet</strong>构建一个用于<strong>开发常识知识</strong>的自适应生成模型<strong>COMET</strong>，以协助完成常识知识的<strong>自我补充</strong>。</li></ul><p>​    <strong>COMET</strong>是一个自适应框架，用于通过在知识元组的种子集上训练语言模型来从语言模型构建常识知识库。这些知识元组为<strong>COMET</strong>提供了必须学习的知识库结构和关系，<strong>COMET</strong>学习调整从预处理中学习的语言模型表示，以向种子知识图添加新的节点和边。</p><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/1.png" class=""><ul><li><strong>实验层面</strong> <ul><li>训练知识库 —— 格式为 <script type="math/tex">\{s ,r, o\}</script>的自然语言元组, 其中 <script type="math/tex">s</script> 为元组的短语主语,  <script type="math/tex">r</script> 为元组的关系， <script type="math/tex">o</script> 为元组的短语宾语。例如 <script type="math/tex">\left(s="take \space a \space nap", r=Causes, o="have \space energy" \right)</script>。</li><li>任务 —— 给定 <script type="math/tex">s</script> 和 <script type="math/tex">r</script> 作为输入， 要求生成 <script type="math/tex">o</script>。 </li></ul></li></ul><h4 id="Transformer语言模型"><a href="#Transformer语言模型" class="headerlink" title="Transformer语言模型"></a>Transformer语言模型</h4><p>​    采用<strong>GPT</strong>的语言模型架构构建<strong>COMET</strong>。</p><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/2.png" class=""><h5 id="多头注意力"><a href="#多头注意力" class="headerlink" title="多头注意力"></a>多头注意力</h5><p>​    多头注意力机制 —— 顾名思义， 注意力由多个头部组成，每个头部使用查询 <script type="math/tex">Q</script> 和键 <script type="math/tex">K</script> 来计算一个唯一的点积注意力分布。</p><script type="math/tex; mode=display">\text { ATTENTION }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V</script><p>​    其中，<script type="math/tex">d_{k}</script> 为 <script type="math/tex">Q, \space K, \space V</script> 的输入向量的维度。对于每个注意力头来说，在计算注意力之前， <script type="math/tex">Q, \space K, \space V</script> 被一组矩阵唯一映射。(<strong>对应a图蓝色部分</strong>)</p><script type="math/tex; mode=display">H_{i} = \text { ATTENTION }(QW_{i}^{Q}, KW_{i}^{K}, V_{i}^{V})</script><p>​    <script type="math/tex">H_{i}</script> 为单个注意力头的输出， <script type="math/tex">W_{i}^{Q}, \space W_{i}^{K}, \space W_{i}^{V}</script> 为特定头的关于 <script type="math/tex">Q, \space K, \space V</script> 的映射矩阵。</p><p>​    同时，多个注意力头的输出将被连接在一起。(<strong>对应a图紫色部分</strong>)</p><script type="math/tex; mode=display">\operatorname{MULTIH}(\mathrm{Q}, \mathrm{K}, \mathrm{V})=\left[H_{1} ; \ldots ; H_{b}\right] W^{O}</script><p>​    其中 <script type="math/tex">W^{O}</script> 为输出的映射矩阵。</p><p><strong>多头注意力的输入</strong></p><p>​    如b图所示，当前层多头注意力的输入来源于上一层Transformer Block的输出。其中，输入的 <script type="math/tex">Q</script> 对应于上一层Block的输出 <script type="math/tex">h_{t}^{l-1}</script>，而 <script type="math/tex">K</script> 和 <script type="math/tex">V</script> 对应于所有先前时间步长的前一层块的输出 <script type="math/tex">\mathbf{h}_{t}^{l-1} = \left\{h^{l-1}\right\}_{<t}</script> 。</p><script type="math/tex; mode=display">\operatorname{MULTIATTN}\left(h_{t}^{l-1}\right)=\operatorname{MULTIH}\left(h_{t}^{l-1}, \mathbf{h}_{t}^{l-1}, \mathbf{h}_{t}^{l-1}\right)</script><h5 id="Transformer块"><a href="#Transformer块" class="headerlink" title="Transformer块"></a>Transformer块</h5><p>​    如b图所示，每个Transformer层包含一个架构上相同的Transformer Block块(尽管具有唯一的可训练参数)，该Transformer Block对该块的输入应用以下变换:</p><script type="math/tex; mode=display">\begin{aligned}\tilde{g}^{l} &=\mathrm{MULTIATTN}\left(h^{l-1}\right) \\g^{l} &=\mathrm{LAYERNORM}\left(\tilde{g}^{l}+h^{l-1}\right) \\\tilde{h}^{l} &=\mathrm{FFN}\left(g^{l}\right) \\h^{l} &=\text { LAYERNORM }\left(\tilde{h}^{l}+g^{l}\right)\end{aligned}</script><p>​    其中，<script type="math/tex">\tilde{g}^{l}</script> 为多头注意力的输出，<script type="math/tex">FFN</script> 是一个两层的前馈神经网络(Feedforward Network), 而 <script type="math/tex">LAYERNORM</script>层是对多头注意力层输出以及前馈层输出的正则化操作，操作的输入包含一个残差连接，该连接将前一个操作的输出和输入相加。</p><h5 id="输入编码器"><a href="#输入编码器" class="headerlink" title="输入编码器"></a>输入编码器</h5><p>​    <strong>文本嵌入</strong> —— <script type="math/tex">\mathbf{X}= \{ X^{s}, \space X^{r}, \space X^{o} \}</script>,  其中 <script type="math/tex">X^{s}, \space X^{r}, \space X^{o}</script> 分别代表知识元组 <script type="math/tex">\{s ,r, o\}</script> 中每一项的单词序列，<script type="math/tex">\mathbf{X}</script> 为三者的串联。对于任意 <script type="math/tex">x_{t} \in \mathbf{X}</script> ，单词 <script type="math/tex">x_{t}</script> 的单词嵌入为 <script type="math/tex">e_{t} = \sum x_{t}^{i}</script> ，这里的 <script type="math/tex">\sum</script> 为向量和。</p><p><strong>为何单词嵌入是一种向量和的形式？</strong></p><p>这是因为GPT采用<strong>字节对编码</strong>(BPE)的方式构建字词，准确来说，GPT以子词表中子词作为词嵌入的基本单位的，这里输入的文本中的完整单词在字词表中可能是好几个字词之和，所以在表示完整单词的文本嵌入时，用的是子词嵌入向量的和。关于<strong>字节对编码</strong>的具体步骤，我之前的一篇<a href="https://caoyusang.github.io/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/">文章</a>中有提到，这里不再赘述。    </p><p>​    <strong>位置嵌入</strong> —— 因为transformer是一种自注意力模型，没有token顺序的概念，所以引入位置编码 <script type="math/tex">p_{t}</script> 来指示模型各个token在文本序列中所处的绝对位置。</p><p>​    <strong>最终输入</strong> —— <script type="math/tex">h_{t}^{l} = e_{t} + p_{t}</script>， 其中 <script type="math/tex">l</script> 表示transformer层数， <script type="math/tex">t</script> 代表第 <script type="math/tex">t</script> 个时间步。如c图所示，第一层的输入为： <script type="math/tex">h^{0} = e_{0} + p_{0}</script>，</p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><ul><li><strong>训练任务</strong> —— 给定知识元组 <script type="math/tex">\{ s, \space r, \space o \}</script>，要求以 <script type="math/tex">s</script> 和 <script type="math/tex">r</script> 对应token的串接 <script type="math/tex">\left[ X^{s}, X^{r} \right]</script> 作为输入，模型需要学会生成 <script type="math/tex">o</script> 对应的那些tokens，即 <script type="math/tex">X^{o}</script> 。</li><li><strong>损失函数</strong> —— 标准的语言模型的损失函数，即对数似然函数。</li></ul><script type="math/tex; mode=display">\mathcal{L}=-\sum_{t=|s|+|r|}^{|s|+|r|+|o|} \log P\left(x_{t} \mid x_{<t}\right)</script><p>​    已知前 <script type="math/tex">t-1</script> 个生成的token <script type="math/tex">x_{<t}</script> ，当前第 <script type="math/tex">t</script> 个位置生成token <script type="math/tex">x_{t}</script>的概率为：</p><script type="math/tex; mode=display">P\left(x_{t} \mid x_{<t}\right)=\operatorname{softmax}\left(\mathbf{W}_{\text {vocab}} \cdot \mathbf{h}_{\mathrm{t}}\right)</script><p>​    其中，<script type="math/tex">|s|, \space |r|, \space |o|</script> 分别为短句主语、关系、宾语对应的token数目。 这里 <script type="math/tex">h_{t}</script> 表示在解码时GPT对<script type="math/tex">x_{t}</script> 的最终表示，<script type="math/tex">\mathbf{W}_{\text {vocab}}</script>是GPT使用的词汇表的嵌入矩阵。</p><ul><li><p><strong>实验数据集</strong> —— ATOMIC 和 ConceptNet</p></li><li><p><strong>输入构造</strong></p><ul><li>ATOMIC —— 关系token只有一个</li></ul><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/3.png" class=""><ul><li>ConceptNet —— 关系token可能有多个，引入第二组mask来分隔关系token和宾语token。</li></ul><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/4.png" class=""></li><li><p><strong>模型参数初始化</strong> —— 使用GPT的预训练模型权重初始化模型，为了微调，往词汇表中加入了一些特殊的token。例如，关系嵌入(如oReact for ATOMIC和IsA for ConceptNet)是通过从标准正态分布中采样来初始化的。</p></li><li><p><strong>超参设置 </strong></p><ul><li><strong>12</strong> layers</li><li><strong>768</strong>-dimensional hidden states </li><li><strong>12</strong> attention heads</li><li>dropout    <strong>0.1</strong></li><li>activation fuction    <strong>GeLU</strong></li><li>batch size    <strong>64</strong></li><li>lr    <strong>6.25e-5</strong> (with a warmup period of 100 minibatches)</li><li>decay method    <strong>linear</strong></li></ul></li></ul><h4 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h4><h5 id="ATOMIC"><a href="#ATOMIC" class="headerlink" title="ATOMIC"></a>ATOMIC</h5><h6 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h6><ul><li>877K 知识元组，涵盖围绕特定事件的社会常识知识</li><li>九个关系维度提炼事件中的常识知识</li></ul><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/5.png" class=""><p>​    对应到实验中，ATOMIC事件(例如，“<strong>X goes to the store</strong>”)是短语主体 <script type="math/tex">s</script> ，<strong>xIntent</strong>是短语关系 <script type="math/tex">r</script> ，<strong>causes/effects</strong>(例如，“<strong>to get food</strong>”)是短语客体 <script type="math/tex">o</script>。训练集/开发集/测试集的数目分别为：<strong>710k/80k/87k</strong></p><h6 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h6><ul><li><strong>自动评估</strong></li></ul><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/6.png" class=""><p>​    上图为采用自动评估标准的评估结果(评估的是生成 <script type="math/tex">o</script> 的质量和新颖性，第一列对比的模型为<strong>ATOMIC</strong>提出文章中的<strong>baseline</strong>，后面两个是论文提出的COMET模型。从第二列开始都是评估的指标，第二列是困惑度<strong>PPL</strong>，第三列是<strong>BLEU-2</strong>，第三列是模型生成元组所占的比例，第四列是模型生成的未出现在训练集元组中 <script type="math/tex">o</script> 所占的比例(<strong>元组新颖性</strong>)，为了证明模型生成的元组新客体不是唯一的，把产生的新客体的数目作为测试集事件产生的唯一客体集合的函数，就是第五列。</p><ul><li><strong>人工评估</strong></li></ul><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/7.png" class=""><p>​    <strong>BLEU-2</strong>的评估结果表明，<strong>COMET</strong>模型超越了所有baseline的表现，比表现最好的baseline实现了51%的相对表现提升。对于人工评估的结果，<strong>COMET</strong>报告了统计上显著的<strong>相对Avg性能</strong>，比最高基线提高了18%。</p><p>​    为了评估在大型语料库上的预训练如何帮助模型学习产生知识，训练了一个没有用预训练权重初始化的COMET版本(COMET(- pretrain))。通过在不同比例的训练数据上训练模型来评估方法的数据效率。</p><p>​    最后，因为最终目标是能够执行高质量、多样化的知识库构建，所以探索了各种解码方案如何影响候选知识元组的质量，采用了不同生成策略进行了实验，这些策略包括：argmax贪婪解码、波束大小的波束搜索、b=2、5、10和k = 5、10的top-k采样。对于每种解码方法，对每种方法产生的最终候选数进行人工评估，结果如下：</p><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/8.png" class=""><p>​    上述结果表明，使用贪婪解码来产生知识元组，与人工评估ATOMIC测试集相比，仅存在10%的相对性能差距，表明由模型产生的知识接近人工性能。</p><h5 id="ConceptNet"><a href="#ConceptNet" class="headerlink" title="ConceptNet"></a>ConceptNet</h5><h6 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h6><ul><li>标准的SRO三元组格式，涵盖大量关系三元组，例如(take a nap,  Causes,  have energy)</li></ul><p>​    对应到实验中，各选取了1200个三元组作为测试集和开发集，包含34个关系类型的100k版本的训练集用于训练模型。</p><h6 id="模型评估-1"><a href="#模型评估-1" class="headerlink" title="模型评估"></a>模型评估</h6><img src="/2020/11/05/%E5%B8%B8%E8%AF%86Transformer%E7%94%A8%E4%BA%8E%E8%87%AA%E5%8A%A8%E7%9F%A5%E8%AF%86%E5%9B%BE%E6%9E%84%E5%BB%BA/9.png" class=""><p><strong>生成质量评估</strong></p><p>​    为了评估生成知识的质量，给出在测试集中生成的正面示例的数量，这些正面示例被评为正确。对于给定的 <script type="math/tex">s \space r \space o \space</script>元组，考虑该模型产生元组是否正确的概率，以50%的概率对分数进行阈值化，以识别正确的预测。</p><p>​    结果表明，该模型可以生成高质量的知识：上表中的<strong>低困惑度</strong>(<strong>PPL</strong>)分数表明其预测的高模型置信度，而高分类器得分Score<strong>(95.25%)</strong>表明知识库补全模型在大多数情况下将生成的元组评分为正确。在人工评估(遵循与ATOMIC相同的设计)中，贪婪解码得到的元组的91.7%被评为正确。</p><p><strong>生成新颖度评估</strong></p><p>​    其中<script type="math/tex">N/T \space sro</script> 达到了<strong>59.25%</strong>，说明有接近<strong>6成</strong>的生成元组未出现在训练集中，显示该模型能够在节点之间生成新的边，甚至创建新的节点(<script type="math/tex">N/T \space o = 3.75</script> ，即<strong>3.75%的节点是新的</strong>)来扩展知识图的大小。但是需要注意的是，有一些新产生的元组仅仅是训练集中元组的简化形式。为此论文进行了研究，这些简化形式的新元组到底有多少。结论是<strong>大多数产生的新元组与训练集中它们最接近的元组具有明显不同的单词序列。</strong></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>​    本文引入常识转换器<strong>(COMET)</strong>来自动构建常识知识库。<strong>COMET</strong>是一个框架，用于调整语言模型的权重，以学习生成新颖和多样的常识知识元组。在两个常识知识库<strong>ATOMIC</strong>和<strong>ConceptNet上</strong>的实验结果表明，<strong>COMET</strong>经常产生人类评估者认为是正确的新常识知识。这些积极的结果表明未来可以寻求将该方法扩展到各种其他类型的知识库上，以及研究<strong>COMET</strong>是否可以学习为任意知识种子产生OpenIE风格的知识元组。</p>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然语言处理任务梳理</title>
    <link href="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/"/>
    <url>/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="NLP任务"><a href="#NLP任务" class="headerlink" title="NLP任务"></a>NLP任务</h1><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/1.png" class="" title="1.png"><h2 id="前处理任务"><a href="#前处理任务" class="headerlink" title="前处理任务"></a>前处理任务</h2><p>前处理任务的结果可作为下游任务输入的额外特征。</p><h3 id="POSTa-词性标注"><a href="#POSTa-词性标注" class="headerlink" title="POSTa(词性标注)"></a>POSTa(词性标注)</h3><p>往模型中输入句子，对每一个token进行词性的识别。</p><p>识别出的词性可以用于下游任务。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/2.png" class="" title="2.png"><h3 id="Word-Segmentation-分词"><a href="#Word-Segmentation-分词" class="headerlink" title="Word Segmentation(分词)"></a>Word Segmentation(分词)</h3><p>对于英文，显然句子有天然的分词。所以分词通常是针对中文句子。</p><p>分词之后，模型的输入就可以以词汇作单位，而不再以字作单位。</p><p>以下面例子做说明：</p><p>将一个句子按字输入模型，训练模型来对每个字来进行二分类决定每个字的对应位置输出N或者Y(N/Y是词的边界标识)</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/3.png" class="" title="3.png"><h3 id="Parsing-语义分析"><a href="#Parsing-语义分析" class="headerlink" title="Parsing(语义分析)"></a>Parsing(语义分析)</h3><p>给定句子产生树状结构——句子的语法结构。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/4.png" class="" title="4.png"><h3 id="Coreference-Rosolution-共指消解"><a href="#Coreference-Rosolution-共指消解" class="headerlink" title="Coreference Rosolution(共指消解)"></a>Coreference Rosolution(共指消解)</h3><p>从一段文章或者一段对话中找出指代同一个人或事物的所有词汇。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/5.png" class="" title="5.png"><h2 id="具体NLP任务"><a href="#具体NLP任务" class="headerlink" title="具体NLP任务"></a>具体NLP任务</h2><h3 id="Summarization-文本摘要"><a href="#Summarization-文本摘要" class="headerlink" title="Summarization(文本摘要)"></a>Summarization(文本摘要)</h3><p><strong>抽取式摘要：</strong>基于二分类任务，每个句子分开考虑。</p><p>衡量文章中句子应不应该放到摘要里面，但是这么做远远不够。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/6.png" class="" title="6.png"><p><strong>生成式摘要：</strong>属于seq2seq模型，输入长文本，模型用自己的语言进行短摘要的生成。</p><p><strong>模型的copy能力</strong>：输入文本序列和输出摘要很有可能有很多共用词汇，这些共用词汇经过模型的修改整合形成摘要的文本。因此模型需要增加输入copy能力，怎么实现？Pointer network(指针网络)。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/7.png" class="" title="7.png"><h3 id="Machine-Translation-机器翻译"><a href="#Machine-Translation-机器翻译" class="headerlink" title="Machine Translation(机器翻译)"></a>Machine Translation(机器翻译)</h3><p><strong>seq2seq</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/8.png" class="" title="8.png"><p><strong>audio2seq</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/9.png" class="" title="9.png"><p><strong>audio2audio</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/10.png" class="" title="10.png"><h3 id="Grammer-Error-Correction-语法纠正"><a href="#Grammer-Error-Correction-语法纠正" class="headerlink" title="Grammer Error Correction(语法纠正)"></a>Grammer Error Correction(语法纠正)</h3><p><strong>seq2seq?</strong> </p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/11.png" class="" title="11.png"><p>不，杀鸡焉用牛刀。</p><p><strong>seq2class</strong></p><p>输入句子，做分类，输出要对token要做的动作的标识（C/R/A/D)。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/12.png" class="" title="12.png"><p>C——复制，保持不变</p><p>A——在后面增加词汇</p><p>R——置换，把词换个时态或者换成别的词</p><p>D——删除</p><h3 id="Sentiment-Classfication-情感分类"><a href="#Sentiment-Classfication-情感分类" class="headerlink" title="Sentiment Classfication(情感分类)"></a>Sentiment Classfication(情感分类)</h3><p>输入一段文本或者评论，训练模型，输出文本的情感分类(正面/负面)。</p><p><strong>seq2class</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/13.png" class="" title="13.png"><h3 id="Stance-Detection-立场侦测"><a href="#Stance-Detection-立场侦测" class="headerlink" title="Stance Detection(立场侦测)"></a>Stance Detection(立场侦测)</h3><p><strong>seq2class</strong></p><p>通过一则博文或者文章以及其下的评论回复来进行评论者所处立场的判断。</p><p>立场通常有四类：SDQC(Support、Denying、Querying and Commenting)。</p><p>立场侦测经常被用于事实预测:</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/14.png" class="" title="14.png"><p><strong>事实预测：</strong></p><p><strong>seq2class</strong></p><p>根据新闻消息或者博文的评论立场以及外部的知识判断消息或文章内容的真实性。</p><h3 id="Natural-Language-Inference-自然语言推理"><a href="#Natural-Language-Inference-自然语言推理" class="headerlink" title="Natural Language Inference(自然语言推理)"></a>Natural Language Inference(自然语言推理)</h3><p><strong>seq2class</strong></p><p><strong>推理模型的文本输入</strong>：premise(前提) + hypothesis(假设)</p><p><strong>模型输出：</strong>对假设是否成立的判断结果，矛盾/包含(可推得)/中立(contradiction/entailment/neutral)</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/15.png" class="" title="15.png"><h3 id="Question-Answering-问答"><a href="#Question-Answering-问答" class="headerlink" title="Question Answering(问答)"></a>Question Answering(问答)</h3><h4 id="传统的基于检索的问答系统"><a href="#传统的基于检索的问答系统" class="headerlink" title="传统的基于检索的问答系统"></a>传统的基于检索的问答系统</h4><p><strong>简单的(模组少)：</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/16.png" class="" title="16.png"><ul><li><p>问题处理——对问题进行格式化，检测其答案的类别</p></li><li><p>检索资料库——进行文档、文章的检索选择</p></li><li><p>答案的生成和评估——从候选文章中抽取答案，抽取的答案根据第一步检测到的答案类别评估其正确性</p></li></ul><p><strong>复杂的(模组多)：</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/17.png" class="" title="17.png"><p><strong>和简单架构的区别：</strong></p><ul><li><p>问题处理——模组更多</p></li><li><p>候选答案生成——综合检索文章得到的候选答案和从自带的有结构资料库中调取的答案</p></li><li>答案评分</li><li>融合对等答案，返回答案及其可信度</li></ul><h4 id="基于深度学习的QA"><a href="#基于深度学习的QA" class="headerlink" title="基于深度学习的QA"></a>基于深度学习的QA</h4><p><strong>seq2seq</strong></p><p>输入问题文本和外部结构化/无结构化的知识(大多来自搜索引擎)，训练模型得到问题的答案。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/18.png" class="" title="18.png"><p>但是要实现直接向模型输入问题和外部知识就生成问题答案还有非常长的一段路要走。目前我们常做的只是从文本中抽取答案。</p><p><strong>抽取式QA：</strong></p><p><strong>seq2seq</strong></p><p>答案就在背景文章里面，向模型输入背景文章和问题，其实就是做通常意义上的阅读理解，模型产生抽取的答案文本在文章中的 start position 和 end position。</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/19.png" class="" title="19.png"><h3 id="Dialogue-对话"><a href="#Dialogue-对话" class="headerlink" title="Dialogue(对话)"></a>Dialogue(对话)</h3><p>对话涉及到自然语言生成(NLG)和自然语言理解(NLU)</p><h4 id="Chatting-闲聊"><a href="#Chatting-闲聊" class="headerlink" title="Chatting(闲聊)"></a>Chatting(闲聊)</h4><p><strong>seq2seq</strong></p><p>聊天都是有背景的，所以模型的输入应该是增量式的，模型的输出是根据之前的对话内容产生的。</p><p>根据对话的需求可以进行定制：</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/20.png" class="" title="20.png"><h4 id="Task-oriented-任务导向的对话"><a href="#Task-oriented-任务导向的对话" class="headerlink" title="Task-oriented(任务导向的对话)"></a>Task-oriented(任务导向的对话)</h4><p><strong>seq2seq</strong></p><p>需要实现一定的功能，比如提供订票、订餐厅、订酒店等服务</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/21.png" class="" title="21.png"><p><strong>系统架构</strong></p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/22.png" class="" title="22.png"><p>State Tracker记录当前对话的状态</p><h2 id="知识图"><a href="#知识图" class="headerlink" title="知识图"></a>知识图</h2><h3 id="NER-命名实体识别"><a href="#NER-命名实体识别" class="headerlink" title="NER(命名实体识别)"></a>NER(命名实体识别)</h3><p><strong>seq2class</strong></p><p>识别出句子中的人名、地名、组织等实体</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/23.png" class="" title="23.png"><h3 id="RE-关系抽取"><a href="#RE-关系抽取" class="headerlink" title="RE(关系抽取)"></a>RE(关系抽取)</h3><p><strong>seq2class</strong></p><p>输入文本和文本中两个实体，训练模型得到两个实体之间的关系</p><p>关系的种类基本是固定的，因此关系抽取的模型往往是去做一个复杂的分类任务</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/24.png" class="" title="24.png"><h2 id="综合任务"><a href="#综合任务" class="headerlink" title="综合任务"></a>综合任务</h2><p>综合任务的意义：看模型是否是真的“理解”了人类语言，能“举一反三”</p><h3 id="GLUE"><a href="#GLUE" class="headerlink" title="GLUE"></a>GLUE</h3><p>分为三大类</p><ul><li>文本分类(语法错误检查、文本情感分析)</li><li>文本相似度计算</li><li>自然语言推理</li></ul><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/25.png" class="" title="25.png"><h3 id="Super-GLUE"><a href="#Super-GLUE" class="headerlink" title="Super GLUE"></a>Super GLUE</h3><p>包含8个NLP任务，大多和QA有关</p><h3 id="DecaNLP"><a href="#DecaNLP" class="headerlink" title="DecaNLP"></a>DecaNLP</h3><p>同一个模型解决10个NLP任务</p><p>怎么实现？往QA的方向改造这些任务</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/26.png" class="" title="26.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据这些NLP任务的输入输出，把这些任务和任务相关的一些技术手段进行梳理</p><img src="/2020/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86/27.png" class="" title="27.png"><h3 id="one-on-one"><a href="#one-on-one" class="headerlink" title="one on one"></a>one on one</h3><p><strong>seq2class</strong></p><ul><li>情感分析</li><li>立场检测</li><li>文本内容辨真伪</li><li>文本意图识别</li><li>对话决策</li></ul><p><strong>seq2tokenclass</strong></p><ul><li>词性标注</li><li>分词</li><li>抽取式摘要</li><li>命名实体识别</li></ul><p><strong>seq2seq</strong></p><ul><li>抽象式摘要</li><li>机器翻译</li><li>文本语法矫正</li><li>自然语言生成</li></ul><h3 id="n-on-one"><a href="#n-on-one" class="headerlink" title="n on one"></a>n on one</h3><p><strong>seq2class</strong></p><ul><li>自然语言推理</li><li>搜索引擎</li><li>关系抽取</li></ul><p><strong>copy from input</strong></p><ul><li>抽取式QA</li></ul><p><strong>seq2seq</strong></p><ul><li>常规QA</li><li>任务导向对话</li><li>聊天机器人</li><li>State Tracker</li></ul><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><ul><li>语义分析</li><li>共指消解</li></ul>]]></content>
    
    
    <categories>
      
      <category>综述</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>溯因推理</title>
    <link href="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/"/>
    <url>/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Abductive-Commonsense-Reasoning-溯因推理"><a href="#Abductive-Commonsense-Reasoning-溯因推理" class="headerlink" title="Abductive Commonsense Reasoning(溯因推理)"></a>Abductive Commonsense Reasoning(溯因推理)</h2><p><a href="https://arxiv.org/pdf/1908.05739v2.pdf">论文地址</a><br><a href="https://github.com/allenai/abductive-commonsense-reasoning">论文代码</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>溯因推理</strong>是对不完全观察情境的<strong>最合理解释</strong>或假设的推论。</p><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/1.png" class=""><p><strong>上图给出的是一个简明扼要的例子：</strong></p><p>给定不同时间节点上的情境观测值 <script type="math/tex">O_{1}</script> 和 <script type="math/tex">O_{2}</script> ，溯因推理的任务是从给出的一众解释性假设 <script type="math/tex">H_{1}, \space H_{2}, \space \cdots ,H_{n}</script> 中选出<strong>最合理</strong>的。例如，上图在 <script type="math/tex">t_{0}</script> 时刻观测到的情境 <script type="math/tex">O_{1}</script> 是：<strong>Jenny打扫好了房间并给窗户留了条缝隙之后去工作了</strong>。而在 <script type="math/tex">t_{n}</script> 时刻，情境变成了：<strong>当Jenny回到家，发现房间里一片狼藉。</strong>针对这两个观测到的不同时间节点上情境，有若干个解释性假设 <script type="math/tex">H_{1}, \space H_{2}, \space H_{3}</script>。</p><ul><li>对于假设 <script type="math/tex">H_{1}</script> ，小偷的入室盗窃(<strong>broke into</strong>)很好的承接了 <script type="math/tex">O_{1}</script> 中”<strong>未关紧窗户(a crack open)</strong>“带来的安全隐患，并很好地解释了情境 <script type="math/tex">O_{2}</script> 中房间为什么一团乱(<strong>小偷翻东西</strong>)，因此看上去假设 <script type="math/tex">H_{1}</script> 非常合理的解释了情境 <script type="math/tex">O_{1}</script> 到情境 <script type="math/tex">O_{2}</script> 的转换。</li><li>对于假设 <script type="math/tex">H_{2}</script> ，假设中提到的大只的鸟(<strong>large bird</strong>)似乎不太可能从窗户缝隙飞进房间，但是如果不考虑情境 <script type="math/tex">O_{1}</script>，该假设可以很好地解释房间乱的现象(<strong>鸟儿被困房间，为了逃离，弄得房间很乱</strong>)</li><li>对于假设 <script type="math/tex">H_{3}</script>，前半部分<strong>(At work)</strong>可以很好地承接情境 <script type="math/tex">O_{1}</script>(<strong>Jenny去工作了，因此Jenny在工作中</strong>)，但是该假设后半部分(<strong>blew her papers everywhere</strong>)完全没法解释情境 <script type="math/tex">O_{2}</script>， 因为该假设完全指的是发生在<strong>办公处</strong>的事情，而情境 <script type="math/tex">O_{2}</script> 则是Jenny<strong>家中</strong>的场景。</li></ul><p>综合以上对三个假设的考量，我们很容易得出，第一个假设是最符合情境 <script type="math/tex">O_{1}</script> 和 <script type="math/tex">O_{2}</script> 的。然而这看似简单的推理过程，对于现有的模型来说，却不是那么容易的。</p><p>虽然长期以来<strong>”溯因“</strong>这种行为被认为是人们解读、理解自然语言的核心，但受限于数据集的缺乏和模型的性能，支撑溯因自然语言推理和生成的研究却相对较少。</p><h3 id="ART数据集"><a href="#ART数据集" class="headerlink" title="ART数据集"></a>ART数据集</h3><p>ART(<strong>叙事文本中的溯因推理</strong>——ABDUCTIVE REASONING IN NARRATIVE TEXT)是第一个用于研究叙事文本中溯因推理的大规模基准数据集。其组成如下：</p><ul><li><strong>20K左右的叙述背景</strong> ——成对的观察结果&lt;<script type="math/tex">O_{1}\space，O_{2}</script>&gt;<ul><li>这些观察情境是根据<strong>ROCStories</strong>数据集进行编写的。<strong>ROCStories</strong>是一个由五句话组成的手动精选短篇故事的大集合。它被设计为每个故事都有一个清晰的开始和结束，这自然对应到ART数据集中的 <script type="math/tex">O_{1},O_{2}</script> 。</li></ul></li><li><strong>超过200K的解释性假设</strong><ul><li>按可能的解释性假设 <script type="math/tex">h^{+}</script> 和不太可能的解释性假设 <script type="math/tex">h^{-}</script> 进行众包。对于 <script type="math/tex">h^{-}</script> 的众包 ,要求众包工人在 <script type="math/tex">h^{+}</script> 的基础上，进行最小限度的编辑(最多改动5个单词)，为每个 <script type="math/tex">h^{+}</script> 创造不可信的假设变量 <script type="math/tex">h^{-}</script>。</li></ul></li><li><strong>数据集分析</strong><ul><li>下面分别分析了训练集、开发集、测试集上对应每个观测的平均对应的正反解释性假设的个数和假设及观测文本句的平均词长。</li></ul></li></ul><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/2.png" class=""><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>论文中提出的两个溯因推理任务分别是αNLI(溯因自然语言推理——Abductive Natural Language Inference)和αNLG(溯因自然语言生成 —— Abductive Natural Language Generation)。</p><p>ART数据集中每个例子按如下格式定义：</p><ul><li><script type="math/tex">O_{1}</script> —— <script type="math/tex">t_{1}</script>时刻的观察</li><li><script type="math/tex">O_{2}</script> —— <script type="math/tex">t_{2}</script>时刻的观察</li><li><script type="math/tex">h^{+}</script> —— 对观察 <script type="math/tex">O_{1}</script> 和观察 <script type="math/tex">O_{2}</script> 的更合理的解释</li><li><script type="math/tex">h^{-}</script> —— 对观察 <script type="math/tex">O_{1}</script> 和观察 <script type="math/tex">O_{2}</script> 来说不太合理的解释</li></ul><h4 id="αNLI"><a href="#αNLI" class="headerlink" title="αNLI"></a>αNLI</h4><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/4.png" class=""><p>给定一对观测和一对解释性假设，αNLI的任务是选出两个假设中更有可能的那个。</p><p>在概率框架下模型的目标函数为：</p><script type="math/tex; mode=display">h^{*}=\arg \max _{h^{i}} P\left(H=h^{i} \mid O_{1}, O_{2}\right)</script><p>根据贝叶斯法则，以观测 <script type="math/tex">O_{1}</script> 为先验条件，可以重写上述公式：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P\left(h^{i} \mid O_{1}, O_{2}\right) = \frac{P\left(O_{2}, O_{1}, h^{i}\right)}{P\left(O_{1} , O_{2}\right)} \\=\frac{P\left(O_{2}\mid h^{i}, O_{1}\right)P\left(h^{i},O_{1}\right)}{P\left(O_{2}, O_{1}\right)} \\=\frac{P\left(O_{2}\mid h^{i}, O_{1}\right)P\left(h^{i} \mid O_{1}\right)}{P\left(O_{2}\mid O_{1}\right)}\end{aligned}\end{equation}</script><p>因为 <script type="math/tex">P\left(O_{2}\mid O_{1}\right)</script> 是定值，所求又是优化问题，所以可以仅考虑左侧的目标函数与右侧乘式的相关关系即可：</p><script type="math/tex; mode=display">P\left(h^{i} \mid O_{1}, O_{2}\right) \propto P\left(O_{2} \mid h^{i}, O_{1}\right) P\left(h^{i} \mid O_{1}\right)</script><p>根据上式，建立如下若干独立性假设，为αNLI任务构建一套概率模型：</p><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/3.png" class=""><ul><li><script type="math/tex">H_{i}</script> 与 <script type="math/tex">O_{1},O_{2}</script>都无关时(模型没用到观测值)</li></ul><script type="math/tex; mode=display">P\left(h^{i} \mid O_{1}, O_{2}\right)=P\left(h_{i}\right)</script><ul><li><p><script type="math/tex">H_{i}</script> 仅与 <script type="math/tex">O_{1},O_{2}</script>其中一个有关（模型用到了一个观测值）</p></li><li><p><strong>线性链</strong>模型 —— <script type="math/tex">H_{i}</script> 与 <script type="math/tex">O_{1},O_{2}</script>都直接相关，但 <script type="math/tex">O_{1} \perp O_{2}</script> (模型使用两个观测值，但独立地考虑了每个观测值对假设的影响)，</p></li></ul><script type="math/tex; mode=display">h^{*}=\arg \max _{h^{i}} P\left(O_{2} \mid h^{i}\right) P\left(h^{i} \mid O_{1}\right) \text { where }\left(O_{1} \perp O_{2} \mid H\right)</script><ul><li><strong>全连接</strong>(模型使用两个观测值，结合两个观测值的信息选择合理的假设)，目标函数为：</li></ul><script type="math/tex; mode=display">h^{*}=\arg \max _{h^{i}} P\left(O_{2} \mid h^{i},O_{1}\right) P\left(h^{i} \mid O_{1}\right)</script><p>在论文的实验中，将不同的独立性假设文本输入BERT进行编码。对于前两个概率模型，可以通过简单地将模型的输入限制为相关变量来加强独立性。另一方面，相关线性链模型将所有三个变量 <script type="math/tex">O_{1},O_{2},H</script> 都作为输入，通过限制模型的形式以加强条件独立性。具体来说，学习一个具有二分类功能的分类器:</p><script type="math/tex; mode=display">P_{\text {Linear }} \text { Chain }\left(h \mid O_{1}, O_{2}\right) \propto e^{\phi\left(O_{1}, h\right)+\phi^{\prime}\left(h, O_{2}\right)}</script><p>其中，<script type="math/tex">\phi</script> 和 <script type="math/tex">\phi^{\prime}</script> 为产生标量值的神经网络模型。</p><h4 id="αNLG"><a href="#αNLG" class="headerlink" title="αNLG"></a>αNLG</h4><p>给定 <script type="math/tex">O_{1},O_{2},h^{+}</script> 为一组的的训练数据，<strong>αNLG</strong>的任务就是最大化 <script type="math/tex">O_{1},O_{2},h^{+}</script> 对应的文本句在生成模型中的生成概率。同时，还可以在给定两个观测的基础上再添加背景知识 <script type="math/tex">\text{K}</script> 作为条件，模型的损失函数构造如下：</p><script type="math/tex; mode=display">\mathcal{L}=-\sum_{i=1}^{N} \log P\left(w_{i}^{h} \mid w_{<i}^{h}, w_{1}^{o 1} \ldots w_{m}^{o 1}, w_{1}^{o 2} \ldots w_{n}^{o 2}, \mathcal{K}\right)</script><p>其中，<script type="math/tex">O_{1}=\left\{w_{1}^{o 1} \ldots w_{m}^{o 1}\right\}</script> ，<script type="math/tex">O_{2}=\left\{w_{1}^{o 2} \ldots w_{n}^{o 2}\right\}</script>，<script type="math/tex">h^{+}=\left\{w_{1}^{h} \ldots w_{l}^{h}\right\}</script>，它们都由其自然语言文本对应的token组成。 <script type="math/tex">w_{<i}^{h}</script> 代表当前位置的前 <script type="math/tex">i</script> 个token，<script type="math/tex">w_{i}^{h}</script> 为当前位置 <script type="math/tex">i</script> 处的token。模型的训练目标就是最大化句子的生成概率 <script type="math/tex">P</script>，也即最小化上述公式的损失 <script type="math/tex">L</script>。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="αNLI-1"><a href="#αNLI-1" class="headerlink" title="αNLI"></a>αNLI</h4><p>αNLI任务被构造成了一个二分类问题。</p><h5 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h5><ul><li><strong>SVM</strong> —— 利用Glove词嵌入，考虑词长度、词的重叠和情感特征等对两个假设选项进行选择。(<strong>50.6%</strong>)</li><li><strong>BOW</strong> —— 将两个观察和一个解释性假设文本串接在一起，利用<strong>Glove</strong>为串接起来的文本构建句子嵌入，再通过一个全连接网络为包含每个不同的解释性假设选项的句子的嵌入打分。(<strong>50.5%</strong>)</li><li><strong>Bi-LSTM + max-pooling</strong> —— 用Bi-LSTM编码句子，使用经过最大池化后的句子嵌入进行打分。(<strong>50.8%</strong>)</li></ul><p>可以看到，传统分类器 + 上下文无关的单词嵌入的方式对解决这个二分类问题看上去几乎毫无作用(因为随机二选一都有一半的概率选对)。</p><h5 id="实验模型"><a href="#实验模型" class="headerlink" title="实验模型"></a>实验模型</h5><p>采用预训练模型GPT和BERT编码观测和解释性假设。</p><ul><li>对于GPT，将观测 <script type="math/tex">O_{1}</script> 和解释性假设 <script type="math/tex">H</script> 串接在一起，然后使用 [SEP] 将其与观测 <script type="math/tex">O_{2}</script> 分隔开，以[START] 和 [SEP] 结尾。</li><li>对于BERT，根据不同独立性假设。有如下五种输入的构造方式：</li></ul><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/6.png" class=""><h5 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h5><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/5.png" class=""><p>最后一列代表模型在论文提出的 <script type="math/tex">\text{ART}</script> 数据集上的表现，和前四个baseline相比，基于GPT和BERT构造的分类模型在数据集上的表现明显提高了很多，最好的<strong>BERT-ft[Linear Chain]</strong>比最佳baseline提升了10.1个百分点，达到了68.9。但是和人类的表现相比，这样的结果还是非常差的。因此，在溯因推理方面的研究还有很多工作要做。</p><h4 id="αNLG-1"><a href="#αNLG-1" class="headerlink" title="αNLG"></a>αNLG</h4><h5 id="实验模型-1"><a href="#实验模型-1" class="headerlink" title="实验模型"></a>实验模型</h5><ul><li><p><script type="math/tex">O_{1}-O_{2}-\text{Only}</script> —— 以组成两个观测值 <script type="math/tex">O_{1}</script> 和 <script type="math/tex">O_{2}</script> 的token为起始训练GPT2。</p></li><li><p>使用<strong>COMET</strong>生成<strong>ATOMIC</strong>格式(<strong>如果-那么</strong>)的知识 —— 包含常识知识的图，是一个以推理“如果-那么”的知识为主的知识库，它以事件作为节点，下列九大关系作为边：</p></li></ul><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/10.png" class=""><p><strong>ATOMIC</strong>是对<script type="math/tex">\text{ART}</script> 数据集中的叙事上下文进行推理所需的背景常识的来源。<strong>COMET</strong>是基于<strong>ATOMIC</strong>训练的专门实现常识知识图自动构建的Transformer，这里借助<strong>COMET</strong>生成基于事件的常识推理知识，然后再GPT2中集成了COMET生成的信息用于αNLG任务。集成方式分两种：</p><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/9.png" class=""><ul><li><strong>COMeT-Txt+GPT-2</strong>（作为文本短语的方式集成）</li></ul><p>在单词嵌入层嵌入输入标记之后，我们在通过Transformer架构的层之前，向串接的观察序列添加18个(对应于每个观察的九个关系)<strong>自然语言文本</strong>，由GPT2进行编码。</p><ul><li><strong>COMeT-Emb+GPT2</strong>（作为嵌入的方式集成）</li></ul><p>和上面那种方式一样，不过在观察序列前添加的是18个<strong>COMeT Embedding</strong>，这允许模型在处理COMeT嵌入时学习每个token的表示——有效地将背景常识知识集成到语言模型中。</p><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/7.png" class=""><h5 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h5><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/8.png" class=""><ul><li><strong>自动评估</strong> —— BLEU、METEOR、ROUGE、CIDEr、BERT-Score</li><li><strong>人工评估</strong> —— 向众包人员展示成对的观察结果和一个生成的假设，要求他们标注该假设是否解释了给定的观察结果。最后一栏为对应的评估分数。人工编写的假设在96%的情况下是正确的，而我们最好的生成模型，即使有背景常识知识的增强，也只能达到45%——这表明αNLG生成任务对当前最优越的文本生成器来说尤其具有挑战性。</li></ul><h5 id="生成实例"><a href="#生成实例" class="headerlink" title="生成实例"></a>生成实例</h5><img src="/2020/11/04/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86/11.png" class=""><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>文章提出了第一项研究，调查基于语言的溯因推理的可行性。概念化并引入溯因自然语言推理(αNLI)——一个关注叙事语境中溯因推理的新任务。该任务被表述为一个选择题回答问题。文章还介绍了溯因自然语言生成(αNLG)——一种新的任务，需要机器为给定的观察结果生成可信的假设。为了支持这些任务，创建并引入了一个新的挑战数据集ART，它由20k个常识性叙述和200k多个解释性假设组成。在实验中，基于最先进的NLI和语言模型建立了这一新任务的Baseline，其准确率为68.9%，与人类性能(91.4%)有相当大的差距。αNLG任务要困难得多——虽然人类可以写出96%的有效解释，但是当前表现最好模型只能达到45%。文章的分析让我们对深度预训练语言模型无法执行的推理类型有了新的见解——尽管预训练模型在NLI蕴涵的密切相关但不同的任务中表现出色，但是在应对基于 <script type="math/tex">\text{ART}</script> 数据集提出的溯因推理和溯因生成任务时，表现却差强人意，这为未来的研究指出了有趣的途径。作者希望ART将成为未来基于语言的溯因推理研究的一个具有挑战性的基准，并且αNLI和αNLG任务将鼓励在人工智能系统中实现复杂推理能力的表征学习。</p>]]></content>
    
    
    <categories>
      
      <category>溯因推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建动态知识路径生成器用于常识推理</title>
    <link href="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/"/>
    <url>/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="构建常识问答知识路径生成器"><a href="#构建常识问答知识路径生成器" class="headerlink" title="构建常识问答知识路径生成器"></a>构建常识问答知识路径生成器</h2><h3 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h3><p>  提出学习一个多跳知识路径产生器来根据问题动态产生结构化证据。生成器以预先训练的语言模型为主干，利用语言模型中存储的大量非结构化知识来补充知识库的不完整性。路径生成器生成的这些相关路径被进一步聚合为知识嵌入，并与文本编码器给出的上下文嵌入进行融合。</p><h3 id="论文架构"><a href="#论文架构" class="headerlink" title="论文架构"></a>论文架构</h3><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/1.png" class=""><ul><li><p>从问题和答案选择中提取实体</p></li><li><p>使用构造的路径生成器生成一个多跳知识路径来连接每对问答实体</p><p>生成器学习将问题实体（红色）和选择实体（绿色）与生成的路径连接起来，这些路径充当QA的动态KG。</p></li></ul><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/2.png" class=""><ul><li>将生成的路径聚合为一个知识嵌入，并将其与文本编码器中的上下文嵌入相融合以进行分类。</li></ul><h4 id="识别实体"><a href="#识别实体" class="headerlink" title="识别实体"></a>识别实体</h4><p>从问题选项对中识别出问题中出现的实体和选项中出现的实体</p><ul><li>字符串匹配(论文中实际使用的方法)</li><li>NER(命名实体识别)</li></ul><h4 id="知识路径采样"><a href="#知识路径采样" class="headerlink" title="知识路径采样"></a>知识路径采样</h4><p>使用随机游走从一个常识KG中抽取符号路径，为GPT-2知识路径生成器采样具有代表性的关系路径作为训练的原始数据。</p><p><strong>提高路径质量</strong></p><p>假设使用Random Walk采样的这些样本路径包含和常识问答任务相关的知识，为了保证这些采样路径的质量，制定了两种启发式策略：</p><ul><li><p>保证相关性——定义了一个可能对回答常识问题有帮助的关系类型的子集。例如 {atlocation，isa}。在进行采样之前，丢弃一些被认为是帮助不大甚至无用处的关系类型，这些关系对于回答问题没什么帮助，这些关系包括：relatedto（相关)、synonym（同义）、antonym（反义）、derived-from（派生自）、formof（一种..形式）、etymologicallyderivedfrom（词源派生自） 和 etymologicallyrelatedto（词源相关）。</p></li><li><p>保证信息性——要求采样的路径不包含具有重复关系类型的边，即路径上每条边的关系都是唯一的。</p></li></ul><h5 id="局部采样（帮助生成器生成适用于任务的路径）"><a href="#局部采样（帮助生成器生成适用于任务的路径）" class="headerlink" title="局部采样（帮助生成器生成适用于任务的路径）"></a>局部采样（帮助生成器生成适用于任务的路径）</h5><ul><li>其中<script type="math/tex">E</script> 为实体集，<script type="math/tex">R</script>为关系集，<script type="math/tex">E</script> 由问题实体和选项实体组成，<script type="math/tex">R</script> 为定义的关系集合关系。以此给出静态的知识图(KG)，<script type="math/tex">G=(E,R)</script>。</li><li>随机游走是从任务训练集中的问题和答案选择中出现的实体开始的。随机游走算法进行图 <script type="math/tex">G</script> 上的路径采样，采样的路径形式为<script type="math/tex">({e_{0},r_{0},e_{1},r_{1},\cdots ,r_{T-1},e_{T}})</script>，其中<script type="math/tex">e_{T} \epsilon E</script>，<script type="math/tex">r_{T} \epsilon R</script>，<script type="math/tex">T</script> 为路径跳数</li></ul><h5 id="全局采样（防止生成器偏向生成KG的局部结构的路径）"><a href="#全局采样（防止生成器偏向生成KG的局部结构的路径）" class="headerlink" title="全局采样（防止生成器偏向生成KG的局部结构的路径）"></a>全局采样（防止生成器偏向生成KG的局部结构的路径）</h5><p>从静态KG中随机采样一些实体，并从它们开始进行随机游走，得到一些局部KG以外的路径用于生成器的泛化。</p><p>此外，还为每个关系添加了一个反向关系，这样采样的路径中不光有正向的路径和有反向的路径，这将使得路径生成器更加灵活地连接两个实体。</p><p>除此之外，还对具有混合跳数的路径进行采样，以训练生成器在需要事用可变长的路径来连接实体。对跳数从1到3的路径进行采样，以构造具有混合跳数的路径集。从特定任务数据集的全局采样和局部采样中获得的路径数如下表所示。将这两种抽样策略的路径合并，并进一步将其分成训练/开发/测试集，其比率为 9:0.5:0.5。</p><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/3.png" class=""><h4 id="基于GPT-2的路径生成器构建"><a href="#基于GPT-2的路径生成器构建" class="headerlink" title="基于GPT-2的路径生成器构建"></a>基于GPT-2的路径生成器构建</h4><p>  在随机游走采样的那些路径上对GPT-2进行微调。</p><p>  GPT-2是一种预训练的大容量语言模型，它从庞大的语料库中编码出丰富的非结构化知识。用它来作为路径生成器带来的好处是双重的：</p><ul><li>微调时使用到的结构化知识路径帮助丰富GPT-2，使得它学到按照设计生成具有“常识”风格路径的能力。</li><li>GPT-2从庞大的语料库中编码出的非结构化知识可以缓解KG的稀疏性问题。</li></ul><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/4.png" class=""><h5 id="采样的路径转化为文本化输入"><a href="#采样的路径转化为文本化输入" class="headerlink" title="采样的路径转化为文本化输入"></a><strong>采样的路径转化为文本化输入</strong></h5><p>  GPT-2 使用字节对编码（Byte Pair Encoding）方式来创建词汇表中的词（token），也就是说词（token）其实通常只是单词的一部分。使用GPT2的字节对编码(Byte-Pair Encoding)方法将上一步直接对知识图进行随机游走采样得到的符号路径转换成GPT-2输入的文本形式：</p><script type="math/tex; mode=display">{x}=\left\{X_{0}, Y_{0}, X_{1}, Y_{1}, \ldots, Y_{T-1}, X_{T}\right\}</script><p>  其中，<script type="math/tex">X_{t}=\left\{x_{t}^{0}, x_{t}^{1}, \ldots, x_{t}^{\left|e_{t}\right|}\right\}</script> 是实体 <script type="math/tex">e_{t}</script> 的短语token，而<script type="math/tex">Y_{t}=\left\{y_{t}^{0}, y_{t}^{1}, \ldots, y_{t}^{\left|r_{t}\right|}\right\}</script>是关系 <script type="math/tex">r_{t}</script> 的短语token。<br>  这样生成的文本形式的路径，方可在GPT-2中作为输入。</p><h6 id="字节对编码方法"><a href="#字节对编码方法" class="headerlink" title="字节对编码方法"></a><strong>字节对编码方法</strong></h6><p>  BPE最早是一种数据压缩算法，于2015年被引入到机器翻译领域并很快得到推广。该算法简单有效，因而目前它是最流行的子词表构建方法。GPT-2和RoBERTa使用的Subword算法都是BPE。</p><p>  BPE获得Subword的步骤如下：</p><ul><li>准备足够大的训练语料，并确定期望的Subword词表大小；</li><li>将单词拆分为成最小单元。比如英文中26个字母加上各种符号，这些作为初始词表；</li><li>在语料上统计单词内相邻单元对的频数，选取频数最高的单元对合并成新的Subword单元；</li><li>重复第3步直到达到第1步设定的Subword词表大小或下一个最高频数为1。</li></ul><p>假设有语料集经过统计后表示为{‘l o w &lt;/w&gt;’: 5, ‘l o w e r &lt;/w&gt;’: 2, ‘n e w e s t &lt;/w&gt;’: 6, ‘w i d e s t &lt;/w&gt;’: 3}，其中数字代表的是对应单词在语料中的频数。其中&lt;/w&gt;为终止符，用于区分单词的边界。</p><p>step 1, 最高频连续字节对”e”和”s”出现了6+3=9次，合并成”es”。输出：</p><pre><code class="hljs json">&#123;&#x27;l o w &lt;/w&gt;&#x27;: 5, &#x27;l o w e r &lt;/w&gt;&#x27;: 2, &#x27;n e w es t &lt;/w&gt;&#x27;: 6, &#x27;w i d es t &lt;/w&gt;&#x27;: 3&#125;</code></pre><p>step 2, 最高频连续字节对”es”和”t”出现了6+3=9次, 合并成”est”。输出：</p><pre><code class="hljs json">&#123;&#x27;l o w &lt;/w&gt;&#x27;: 5, &#x27;l o w e r &lt;/w&gt;&#x27;: 2, &#x27;n e w est &lt;/w&gt;&#x27;: 6, &#x27;w i d est &lt;/w&gt;&#x27;: 3&#125;</code></pre><p>step 3, 以此类推，最高频连续字节对为”est”和”&lt;/w&gt;” 输出：</p><pre><code class="hljs json">&#123;&#x27;l o w &lt;/w&gt;&#x27;: 5, &#x27;l o w e r &lt;/w&gt;&#x27;: 2, &#x27;n e w est&lt;/w&gt;&#x27;: 6, &#x27;w i d est&lt;/w&gt;&#x27;: 3&#125;</code></pre><p>……</p><p>step n, 继续迭代直到达到预设的subword词表大小或下一个最高频的字节对出现频率为1。</p><h6 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h6><ul><li><p>编码</p><p>在之前的算法中，已经得到了subword的词表，对该词表按照子词长度由大到小排序。编码时，对于每个单词，遍历排好序的子词词表寻找是否有token是当前单词的子字符串，如果有，则该token是表示单词的tokens之一。</p><p>从最长的token迭代到最短的token，尝试将每个单词中的子字符串替换为token。 最终，我们将迭代所有tokens，并将所有子字符串替换为tokens。 如果仍然有子字符串没被替换但所有token都已迭代完毕，则将剩余的子词替换为特殊token，如<unk>。</p></li></ul><p>例子</p><pre><code class="hljs text">// 给定单词序列[“the&lt;/w&gt;”, “highest&lt;/w&gt;”, “mountain&lt;/w&gt;”]// 假设已有排好序的subword词表[“errrr&lt;/w&gt;”, “tain&lt;/w&gt;”, “moun”, “est&lt;/w&gt;”, “high”, “the&lt;/w&gt;”, “a&lt;/w&gt;”]// 迭代结果&quot;the&lt;/w&gt;&quot; -&gt; [&quot;the&lt;/w&gt;&quot;]&quot;highest&lt;/w&gt;&quot; -&gt; [&quot;high&quot;, &quot;est&lt;/w&gt;&quot;]&quot;mountain&lt;/w&gt;&quot; -&gt; [&quot;moun&quot;, &quot;tain&lt;/w&gt;&quot;]</code></pre><ul><li>解码</li></ul><p>将所有的tokens拼在一起，以<script type="math/tex"></w></script>为界定符。</p><p>例子：</p><pre><code class="hljs python">// 编码序列[“the&lt;/w&gt;”, “high”, “est&lt;/w&gt;”, “moun”, “tain&lt;/w&gt;”]// 解码序列“the&lt;/w&gt; highest&lt;/w&gt; mountain&lt;/w&gt;”</code></pre><p>通过BPE编码和解码，为采样的路径构造出适合GPT-2的输入的文本格式。</p><h5 id="GPT-2生成器输入构造"><a href="#GPT-2生成器输入构造" class="headerlink" title="GPT-2生成器输入构造"></a>GPT-2生成器输入构造</h5><p>  为了进一步模拟生成器提供一个问题实体和一个选择实体的场景，在每个路径的开始处添加最后一个实体短语标记 <script type="math/tex">x_{T}</script> 和一个单独的标记[SEP]。这样，生成器将知道在生成路径时它应该输出的最后一个实体。</p><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/5.png" class=""><p> 将目标实体 + [SEP]标记 + 起始实体，即灰色部分交给GPT-2生成器来生成连接这两个实体的路径。</p><p>  已知前 <script type="math/tex">t-1</script> 个生成的token <script type="math/tex">s_{<t}</script>，当前第t个位置生成token <script type="math/tex">s_{t}</script> 的概率为：</p><script type="math/tex; mode=display">P\left(s_{t} \mid s_{<t}\right)=\operatorname{softmax}\left(\mathbf{W}_{\text {vocab}} \cdot \mathbf{h}_{\mathrm{t}}\right)</script><p>  这里 <script type="math/tex">h_{t}</script> 表示在解码时GPT-2对 <script type="math/tex">s_{t}</script> 的最终表示， <script type="math/tex">W_{vocab}</script> 是GPT-2使用的词汇表的嵌入矩阵。</p><p>  为了在给定实体对的情况下最大化生成句子 <script type="math/tex">s</script> 的概率，将损失函数定义为：</p><script type="math/tex; mode=display">\mathcal{L}=-\sum_{\mathbf{s}} \log P\left(\mathbf{s} \mid X_{T},[S E P], X_{0}\right)</script><p>  其中，<script type="math/tex">P\left(\mathbf{s} \mid X_{T},[S E P], X_{0}\right)</script> 为条件概率的乘积，另外，由于输入的 <script type="math/tex">X_{0}</script> 和 <script type="math/tex">X_{1}</script> 以及 <script type="math/tex">[SEP]</script>是固定的输入，所以 <script type="math/tex">t</script> 的下标从 <script type="math/tex">|X_{0}|+|X_{1}| + 1</script> 开始。</p><script type="math/tex; mode=display">P\left(\mathbf{s} \mid X_{T},[S E P], X_{0}\right)=\prod_{t=\left|X_{0}\right|+\left|X_{T}\right|+1}^{|\mathbf{s}|} P\left(s_{t} \mid s_{<t}\right)</script><h4 id="文本编码器的选择和构建"><a href="#文本编码器的选择和构建" class="headerlink" title="文本编码器的选择和构建"></a>文本编码器的选择和构建</h4><p>  本文常识问答的框架由两个主要部分组成。第一部分是前面提到的路径生成器。第二部分是一个上下文编码器，它对问题和选择进行编码，以输出一个上下文嵌入 <script type="math/tex">c</script> 作为非结构化证据。</p><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/6.png" class=""><p>  该论文实验采用的文本编码器为BERT和Robert，两种常用的文本输入上下文编码器。问题和选择通过添加一些特殊的标记串接起来，然后输入上下文编码器得到 <script type="math/tex">c</script> 。上下文嵌入 <script type="math/tex">c</script> 和路径生成器生成的路径进行Attention之后，输出一个知识嵌入 <script type="math/tex">p</script> 作为结构化证据。最后，这两类证据被输入分类器，为每个选择输出一个似然性得分。</p><h5 id="KE-知识嵌入-模块"><a href="#KE-知识嵌入-模块" class="headerlink" title="KE(知识嵌入)模块"></a>KE(知识嵌入)模块</h5><p>路径生成器GPT-2为每对问题选项生成一条最终的推理路径，对于生成的这些长度不一的离散路径，将GPT-2中最后一层隐藏状态的平均值 <script type="math/tex">p_{k}</script> 作为路径嵌入，从而最大限度地利用路径生成器。</p><script type="math/tex; mode=display">\mathbf{p}_{\mathbf{k}}=\operatorname{MEAN}\left(\left\{\mathbf{h}_{\mathbf{0}}, \mathbf{h}_{\mathbf{1}}, \ldots, \mathbf{h}_{\mathbf{T}}\right\}\right)</script><p>  由于GPT-2已经在一个大型语料库上进行了预训练，这样的表示应该足以保存路径的信息。</p><p>  由于并非所有的路径都会对决定哪个选择是正确答案做出同等贡献，所以我们利用非结构化证据，即上面提到的上下文嵌入c作为编码这种结构化证据的指导。</p><script type="math/tex; mode=display">\mathbf{p}=W_{p r o j} \cdot \sum_{k} \alpha_{k} \mathbf{p}_{k}</script><p>  其中 <script type="math/tex">W_{proj}</script> 是个可学习的映射矩阵，<script type="math/tex">\alpha_{k}</script> 为每条路径嵌入的注意力权重，其计算公式如下：</p><script type="math/tex; mode=display">\alpha_{k}=\frac{\exp \left(s_{k}\right)}{\sum_{k^{\prime}} \exp \left(s_{k^{\prime}}\right)}</script><p>  其中，<script type="math/tex">s_{k}</script> 的计算公式如下，注意力网络由 <script type="math/tex">W_{att}</script> 和 <script type="math/tex">b_{att}</script> 参数化</p><script type="math/tex; mode=display">s_{k}=\mathbf{c}^{\top} \tanh \left(\mathbf{W}_{a t t} \cdot \mathbf{p}_{k}+\mathbf{b}_{a t t}\right)</script><h5 id="融合异质信息进行分类"><a href="#融合异质信息进行分类" class="headerlink" title="融合异质信息进行分类"></a>融合异质信息进行分类</h5><p>  分类器利用路径生成器产生的路径嵌入 <script type="math/tex">p</script> 和文本编码器产生的非结构化的问题选项的上下文嵌入 <script type="math/tex">c</script> 来计算问题选择对的似然性。</p><p>  <strong>如何计算似然性</strong>？</p><p>  将 <script type="math/tex">c</script> 和 <script type="math/tex">p</script> 连接起来，并将它们提供给最终的线性分类层为每个问题选项对获取一个最终得分，这里涉及一个线性变换：</p><script type="math/tex; mode=display">f(q, a)=\mathbf{W}_{c l s} \cdot[\mathbf{c} ; \mathbf{p}]+\mathbf{b}_{c l s}</script><p>  最后通过一个softmax层对得分进行标准化，得到所有选择的最终概率。</p><h3 id="Baselines"><a href="#Baselines" class="headerlink" title="Baselines"></a>Baselines</h3><h4 id="Pre-trained-LM"><a href="#Pre-trained-LM" class="headerlink" title="Pre-trained LM"></a><strong>Pre-trained LM</strong></h4><ul><li><p>BERT</p></li><li><p>RoBERTa</p><p>在该论文的框架中，使用了RoBERTa最后一层隐藏状态的平均池作为上下文嵌入，并将其输入到线性分类器以获得分数。</p></li></ul><h4 id="KG"><a href="#KG" class="headerlink" title="KG"></a><strong>KG</strong></h4><ul><li>静态KG，例如KagNet和RGCN</li><li>动态KG，该论文使用到的GPT-2路径动态生成</li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><img src="/2020/11/04/%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E5%99%A8%E7%94%A8%E4%BA%8E%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/7.png" class=""><p>当使用RoBERTa作为上下文编码器以及上面提及的路径生成器之后，模型在CSQA的表现同baseline相比是最好的，但是当使用BERT作为上下文编码器时，表现并没有优于所有使用静态KG的模型。这是方法的局限性，在某种程度上仍然依赖上下文编码器来聚合具有注意机制的路径。如何设计一个与文本模块耦合较少的路径生成器是今后的工作。</p><p>​    </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  该论文提出了一种生成多跳知识路径的生成器，作为回答常识问题的结构化证据。为了学习这样一个路径生成器，微调了GPT-2，从一个常识KG中随机抽取样本。然后生成器将每对问答实体用一条知识路径连接起来。这些路径被进一步聚合为知识嵌入，并与文本编码器给出的上下文嵌入进行融合。在两个基准数据集上的实验结果表明，该论文的框架在性能上优于强预训练语言模型和静态KG增强方法。除此之外，还证明了所生成的路径在信息性和帮助性方面是可以解释的。未来的工作包括如何将生成器与文本编码器解耦，以及如何更好地融合知识。</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><ul><li>BPE字节对编码方法的内容摘自文章：<a href="https://zhuanlan.zhihu.com/p/86965595">https://zhuanlan.zhihu.com/p/86965595</a></li><li>论文地址：<a href="https://arxiv.org/pdf/2005.00691.pdf">《Connecting the Dots: A Knowledgeable Path Generator for Commonsense Question Answering》</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>融合异构知识在图上进行常识推理</title>
    <link href="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/"/>
    <url>/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="融合异构知识进行常识问答"><a href="#融合异构知识进行常识问答" class="headerlink" title="融合异构知识进行常识问答"></a>融合异构知识进行常识问答</h2><p>论文标题 —— 《Graph-Based Reasoning over Heterogeneous External Knowledge for Commonsense Question Answering》<br><a href="https://arxiv.org/pdf/1909.05311v2.pdf">论文来源</a><br><a href="https://github.com/DecstionBack/AAAI_2020_CommonsenseQA">论文代码</a></p><h3 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h3><h4 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h4><p>以CSQA（常识问答）为例，针对未提及背景知识的问题，要求考虑背景知识并作出回答</p><h4 id="任务形式"><a href="#任务形式" class="headerlink" title="任务形式"></a>任务形式</h4><p><strong>输入：</strong>问题Q=q_1 q_2⋯q_m和包含n个答案的候选答案集合A={a_1,a_2,⋯,a_n}<br><strong>目标：</strong>从候选集合中选出正确答案<br><strong>评价指标：</strong>准确率</p><h3 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h3><ul><li><p>在与问题相关的背景知识中如何获取evidence信息（抽取三元组，为知识源构建图）</p></li><li><p>如何基于获取到的evidence信息做出预测（图表示学习+图推理来解决）</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/1.png" class=""><h4 id="从外部知识库抽取evidence"><a href="#从外部知识库抽取evidence" class="headerlink" title="从外部知识库抽取evidence"></a>从外部知识库抽取evidence</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol><li><p>人工标注——耗时耗力耗财</p></li><li><p>仅从同构（结构化/非结构化）知识源中抽取evidence——没有同时利用不同来源的知识，得到的evidence可能不够全面</p></li><li><p>融合结构化与非结构化知识库中的知识，例如融合结构化的ConceptNet库和纯文本的Wikipedia库，并从中抽取evidence</p></li></ol><h5 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h5><p>从ConceptNet中抽取</p><ol><li><p>在ConceptNet中确定不同的问题和选项中出现的实体；</p></li><li><p>从ConceptNet中抽取从问题中的实体到候选中的实体的路径（小于 3 hops）</p></li></ol><p>从Wikipedia中抽取</p><ol><li><p>使用 Spacy 从中抽取出 107M 个句子，并用 Elastic Search 工具构建句子索引；</p></li><li><p>对于每个训练样例，去除问句和候选中的停用词，然后将所有词串联，作为检索查询 ；</p></li><li><p>使用 Elastic 搜索引擎 在检索查询和所有句子之间进行排序，选择出 top-K 个句子作为 Wikipedia 提供的证据信息（在实验中 K=10）；</p></li></ol><h4 id="为每个知识源构建图"><a href="#为每个知识源构建图" class="headerlink" title="为每个知识源构建图"></a>为每个知识源构建图</h4><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ol><li><p>对于ConceptNet库，用其自身的三元组即可</p></li><li><p>对于Wikipedia库，通过语义角色标注SRL(semantic role labeling)来抽取句子中的三元组</p></li></ol><h5 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h5><p><strong>构建ConceptNet图</strong></p><ol><li><p>把从ConceptNet中抽取出的路径拆分成三元组的形式，将每个三元组看做一个节点，融合到图中；对于含有相同实体的三元组，给图中对应到的节点加上一条边；</p></li><li><p>为了获取ConceptNet中节点的上下文词表示，将三元组根据关系模板转化为自然语言语句；</p></li></ol><p><strong>构建Wikipedia图</strong></p><ol><li><p>使用SRL抽出句子中的每个谓词的论元，谓词和论元作为节点，它们之间的关系作为边</p></li><li><p>同样地，为了增强构建图的连通性，基于两条给定的规则进行节点a,b之间的加边：</p><ul><li>b 中包含 a 且 a 的词数大于3</li><li>a 与 b 仅有一个不同的词，并且 a 和 b 包含的词数都大于3</li></ul></li></ol><h4 id="编码图信息、聚集evidence信息"><a href="#编码图信息、聚集evidence信息" class="headerlink" title="编码图信息、聚集evidence信息"></a>编码图信息、聚集evidence信息</h4><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/2.png" class=""><h5 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h5><ol><li><p>利用Topology Sort算法，根据知识抽取部分得到的图结构,对evidence句的顺序进行重排；<br>利用得到的图的结构，通过重定义evidence词之间的相对位置，来让语义相关的词的相对位置更加接近；<br>利用evidence内部的关系结构获取更好的上下文表示；</p></li><li><p>排好顺序的从ConceptNet库、Wikipedia库中抽出的evidence句、问题、所有选项<br>以上4个部分的串接，在使用了[sep]进行分隔后，作为XLNet的输入进行编码</p></li></ol><h4 id="进行最终的预测"><a href="#进行最终的预测" class="headerlink" title="进行最终的预测"></a>进行最终的预测</h4><h5 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h5><ul><li><p>把两个evidence图看作一个无向图，利用GCN对知识图和XLNet编码提供的问答+evidence的词级向量表示，来进行编码来获得节点层次的表示</p></li><li><p>evidence传播：</p><ul><li>从邻居节点聚集信息；</li><li>组合、更新节点表示</li></ul></li><li><p>利用图注意力网络对经过GCN得到的节点表示以及XLNet的input表示进行处理，聚集图级别的表示，进而进行最终的预测打分</p></li></ul><h3 id="重点模块及方法阐述"><a href="#重点模块及方法阐述" class="headerlink" title="重点模块及方法阐述"></a>重点模块及方法阐述</h3><h4 id="SRL"><a href="#SRL" class="headerlink" title="SRL"></a>SRL</h4><p>语义角色标注（Semantic Role Labeling，SRL）以句子的谓词为中心，不对句子所包含的语义信息进行深入分析，只分析句子中各成分与谓词之间的关系，即句子的谓词（Predicate）- 论元（Argument）结构。并用语义角色来描述这些结构关系，是许多自然语言理解任务（如信息抽取，篇章分析，深度问答等）的一个重要中间步骤。在研究中一般都假定谓词是给定的，所要做的就是找出给定谓词的各个论元和它们的语义角色。</p><h4 id="ConceptNet"><a href="#ConceptNet" class="headerlink" title="ConceptNet"></a>ConceptNet</h4><p>ConceptNet：常识知识库，它以三元组形式的关系型知识构成。</p><h4 id="ElaticSearch"><a href="#ElaticSearch" class="headerlink" title="ElaticSearch"></a>ElaticSearch</h4><p>ElasticSearch：一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，是当前流行的企业级搜索引擎。</p><h4 id="Topology-Sort"><a href="#Topology-Sort" class="headerlink" title="Topology Sort"></a>Topology Sort</h4><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/3.png" class=""><ul><li><p><strong>处理ConceptNet</strong></p><p>将三元组转化为自然语句，例如，(mammals, HasA, hair) -&gt; mammals has hair</p></li><li><p><strong>处理Wikipedia</strong></p><p>以evidence句作为句子图中的节点来构建句子图，如果在构建wikipedia图的过程中，节点p和q分别在句子s和t中，则为句子图中的代表两个相应句子的节点添加一条边。<br>利用拓扑排序算法对这些构建的句子图中的节点进行排序。</p></li></ul><h4 id="XLNET"><a href="#XLNET" class="headerlink" title="XLNET"></a>XLNET</h4><p><strong>使用XLNet而不采用BERT的原因，总结起来有以下几点：</strong></p><ul><li><p>BERT训练数据和测试数据之间的不一致性，这也叫作Discrephancy。当我们训练BERT的时候，<br> 会随机的Mask掉一些单词的，但实际上在使用的过程当中，我们却没有MASK这类的标签，<br> 所以这个问题就导致训练的过程和使用（测试）的过程其实不太一样，这是一个主要的问题。</p></li><li><p>BERT并不能用来生成数据。由于BERT本身是依赖于DAE的结构来训练的，所以不像那些基于语言模型训练出来的模型具备很好地生成能力。<br> 之前的方法比如NNLM，ELMo是基于语言模型生成的，所以用训练好的模型可以生成出一些句子、文本等。<br> 但基于这类生成模型的方法论本身也存在一些问题，因为理解一个单词在上下文里的意思的时候，语言模型只考虑了它的上文，而没有考虑下文！</p></li></ul><p>基于这些BERT的缺点，学者们提出了XLNet, 而且也借鉴了语言模型，还有BERT的优缺点。具体做法如下：</p><ul><li><p>首先，生成模型是单向的，即便我们使用Bidirectional LSTM类模型，其实本质是使用了两套单向的模型。<br> 通过使用permutation language model, 也就是把所有可能的permutation全部考虑进来。</p></li><li><p>另外，为了迎合这种改变，他们在原来的Transformer Encoder架构上做了改进，引入双流注意力机制,<br> 而且为了更好地处理较长的文本，进而使用的是Transformer-XL。 </p></li></ul><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><p>图卷积神经网络，实际上跟CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据（结构十分不规则，数据不具有平移不变性，<br>这让适用于处理图片、语言这类欧氏空间数据的传统的CNN、RNN瞬间失效）。</p><p>GCN精妙地设计了一种从图数据中提取特征的方法，从而让我们可以使用这些特征去对图数据进行节点分类<br>（node classification）、图分类（graph classification）、边预测（link prediction），还可以顺便得到图的嵌入表示（graph embedding）。</p><p>在Step 4对evidence图进行编码的过程，实际上就相当于对图数据进行了特征的提取。</p><p>GCN也是一个神经网络层，层与层之间的传播方式如下（利用了拉普拉斯矩阵）：</p><script type="math/tex; mode=display">H^{l+1}=\sigma\left(\widetilde{D}^{-\frac{1}{2}} \tilde{A} \widetilde{D}^{-\frac{1}{2}} H^{l} W^{l}\right)</script><p>需要说明的是，<script type="math/tex">\tilde{A}=A+I</script>为图的邻接矩阵，I为单位阵。<script type="math/tex">\tilde{D}</script> 为 <script type="math/tex">\tilde{A}</script> 的度矩阵。<script type="math/tex">H</script> 为每一层的特征。对于输入层 <script type="math/tex">H=X</script>。</p><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/4.png" class=""><p>若构造一个两层的GCN来进行分类任务，激活函数分别采用ReLU和softmax，则整体的正向传播公式为：</p><script type="math/tex; mode=display">\mathrm{Z}=\mathrm{f}(\mathrm{X}, \mathrm{A})=\operatorname{softmax}\left(\tilde{A} \operatorname{Re} L U\left(\tilde{A} X W^{(0)}\right) W^{(1)}\right)</script><p>上图中的GCN输入一个图，通过若干层GCN每个node的特征从X变成了Z，但是，无论中间有多少层，node之间的连接关系，即A，都是共享的。</p><p>GCN的特别之处：即使不训练，完全使用随机初始化的参数W，GCN提取出来的特征就已经非常优秀了！</p><h4 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h4><p>和所有的attention mechanism一样，GAT的计算也分为两步走：</p><ul><li>计算注意力系数；对于顶点i，注意计算它与它的邻接节点的相似系数</li></ul><script type="math/tex; mode=display">  e_{i j}=a\left(W \overrightarrow{h_{i}}, W \overrightarrow{h_{j}}\right)</script><p>其中共享参数W的线性映射给顶点的特征进行了增强，a(·)把拼接后的高维特征映射到一个实数上，这个过程一般通过一个单层的前馈神经网络来实现.对相关系数用softmax进行归一化便得到了注意力系数。 要理解计算过程可见下图。</p><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/5.png" class=""><ul><li>加权求和。把计算好的注意力系数进行加权求和，加上多头机制进行增强</li></ul><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/6.png" class=""><h4 id="GCN与GAT的异同"><a href="#GCN与GAT的异同" class="headerlink" title="GCN与GAT的异同"></a>GCN与GAT的异同</h4><ul><li><strong>同</strong>：GCN与GAT都是将邻居顶点的特征聚合到中心顶点上（一种aggregate运算），利用graph上的局部平稳性学习新的顶点特征表达。</li><li><strong>异</strong>：GCN利用了拉普拉斯矩阵，GAT利用attention系数。</li></ul><h5 id="为什么要融合异构知识源？"><a href="#为什么要融合异构知识源？" class="headerlink" title="为什么要融合异构知识源？"></a>为什么要融合异构知识源？</h5><ul><li><strong>结构化知识</strong> (Structured Knowledge Source)：包含大量的三元组信息（概念及其之间的关系），利于推理，但是存在覆盖度低的问题；</li><li><strong>非结构化知识</strong> (Unstructured Knowledge Source)：即 Plain-Text，包含大量冗余的、覆盖范围广的信息，可以辅助/补充结构化知识；</li></ul><img src="/2020/11/04/%E8%9E%8D%E5%90%88%E5%BC%82%E6%9E%84%E7%9F%A5%E8%AF%86%E5%9C%A8%E5%9B%BE%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%B8%B8%E8%AF%86%E6%8E%A8%E7%90%86/7.png" class=""><p>在结构化知识和非结构化知识的协同作用下，模型选出了最佳答案。</p>]]></content>
    
    
    <categories>
      
      <category>常识推理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B站弹幕爬取</title>
    <link href="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/"/>
    <url>/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h3 id="B站弹幕爬取"><a href="#B站弹幕爬取" class="headerlink" title="B站弹幕爬取"></a>B站弹幕爬取</h3><h4 id="单个视频弹幕的爬取"><a href="#单个视频弹幕的爬取" class="headerlink" title="单个视频弹幕的爬取"></a>单个视频弹幕的爬取</h4><pre><code>B站弹幕都是以xml文件的形式存在的，而xml文件的请求地址是如下形式：</code></pre><pre><code class="hljs html">http://comment.bilibili.com/233182992.xml</code></pre><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/1.png" class=""><pre><code>其中，**233182992**是**cid**，这个需要从原视频的网页中获取。获取了**cid**之后，就可以按照上述的形式拼接请求地址，发送**get**请求，获取对应的xml文件。</code></pre><h5 id="cid获取"><a href="#cid获取" class="headerlink" title="cid获取"></a>cid获取</h5><pre><code>以华农兄弟的某个视频为例，进入视频主页。</code></pre><ul><li>右键启用<strong>检查模式</strong></li><li>选择<strong>网络</strong>(Network)，刷新网页</li><li>点开第一个文件，选择<strong>响应</strong>(response)</li><li>使用<strong>CTRL + F</strong>进行字段查找，输入<strong>“cid:”</strong>，发现匹配到的第一个cid就是视频的cid</li></ul><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/2.png" class=""><pre><code>接下来，就是如何从视频主页返回的网页信息中**提取cid**。</code></pre><ul><li>确定视频的<strong>bv号</strong> </li><li>根据bv号确定请求地址 </li><li>使用<strong>正则表达式</strong>从网页返回的文本中匹配cid</li><li>根据拿到的cid请求<strong>获取xml</strong>文件</li></ul><h5 id="xml文件解析"><a href="#xml文件解析" class="headerlink" title="xml文件解析"></a>xml文件解析</h5><pre><code>获取到xml文件之后，需要从xml文件中提取出弹幕文本。调用lxml库中的etree类，etree.HTML()可以用来解析字符串格式的HTML文档对象，将传进去的字符串转变成Element对象。作为Element对象，可以方便的使用getparent()、remove()、xpath()等方法。这里使用xpath来提取需要的那部分弹幕文本。</code></pre><h5 id="爬虫封装"><a href="#爬虫封装" class="headerlink" title="爬虫封装"></a>爬虫封装</h5><p>完整代码如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> re<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiliBiliDanMu</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, bv, filename</span>):</span>        <span class="hljs-comment"># 根据bv号构造要爬取的视频url地址</span>        self.video_url = <span class="hljs-string">&quot;https://bilibili.com/video/BV&quot;</span> + bv        self.filename = filename        self.headers = &#123;            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span><span class="hljs-string">             AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Edg/85.0.564.44&quot;</span>        &#125;    <span class="hljs-comment"># 获取视频的cid</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_video_cid</span>(<span class="hljs-params">self</span>):</span>        response = requests.get(self.video_url, headers=self.headers)        html = response.content.decode()        cid = re.findall(<span class="hljs-string">r&#x27;(&quot;cid&quot;:)([0-9]+)&#x27;</span>, html)        <span class="hljs-comment"># 有的视频没有这个字段，我们跳过它</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cid) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> cid[<span class="hljs-number">0</span>][<span class="hljs-number">-1</span>]    <span class="hljs-comment"># 获取请求弹幕xml文件返回的内容</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_content</span>(<span class="hljs-params">self, xml_url</span>):</span>        response = requests.get(xml_url, headers=self.headers)        <span class="hljs-keyword">return</span> response.content    <span class="hljs-comment"># 解析获取到的内容，得到包含视频所有弹幕的列表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_danmu</span>(<span class="hljs-params">self, content_str</span>):</span>        html = etree.HTML(content_str)        danmu_list = html.xpath(<span class="hljs-string">&quot;//d/text()&quot;</span>)        <span class="hljs-keyword">return</span> danmu_list    <span class="hljs-comment"># 将弹幕逐行写入并保存为txt文件</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">self, save_items</span>):</span>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.filename, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:            lines = []            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> save_items:                lines.append(item + <span class="hljs-string">&#x27;\n&#x27;</span>)            f.writelines(lines)    <span class="hljs-comment"># 爬虫的过程封装</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">self</span>):</span>        cid = self.get_video_cid()        <span class="hljs-comment"># 跳过没有cid字段的视频</span>        <span class="hljs-keyword">if</span> cid <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            xml_url = <span class="hljs-string">&quot;http://comment.bilibili.com/&quot;</span> + <span class="hljs-built_in">str</span>(cid) + <span class="hljs-string">&quot;.xml&quot;</span>            content_str = self.get_content(xml_url)            danmu_lst = self.extract_danmu(content_str)            self.save(danmu_lst)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">pass</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    bv = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入视频的bv号: &quot;</span>)    dm = BiliBiliDanMu(bv, <span class="hljs-string">&#x27;./output/&#123;&#125;.txt&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(bv)))    dm.crawl()</code></pre><h4 id="up主所有视频的弹幕爬取"><a href="#up主所有视频的弹幕爬取" class="headerlink" title="up主所有视频的弹幕爬取"></a>up主所有视频的弹幕爬取</h4><pre><code>仍然以华农兄弟的视频为例，进入华农兄弟的个人空间的视频页，地址如下：</code></pre><pre><code class="hljs html">https://space.bilibili.com/250858633/video</code></pre><h5 id="视频页数和up名字获取"><a href="#视频页数和up名字获取" class="headerlink" title="视频页数和up名字获取"></a>视频页数和up名字获取</h5><pre><code>仍然启用网页检查，来看我们需要的信息究竟该如何请求。首先，选中网络中的**XHR选项**，刷新页面，点击出现的**search**文件，点击响应，**左键连击3次**，选中响应返回的全部数据，其实，这里返回的就是一个**json文件**。</code></pre><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/3.png" class=""><pre><code>我们使用一个在线工具来看看这个json文件的结构：[json工具](http://json.cn/)</code></pre><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/4.png" class=""><pre><code>从这个结构里可以看到，**tlist字段**下包含了三类视频的类型id及数目(**count字段**)。而视频页的**最大固定展示数目为30**，因此，我们通过一个简单的计算就可以得到up主视频的总页数。由页数，也就能确定**循环请求的次数**。请求的**url地址**如下：</code></pre><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/5.png" class=""><pre><code class="hljs html">https://api.bilibili.com/x/space/arc/search？mid=250858633&amp;ps=30&amp;tid=0&amp;pn=1&amp;keyword=&amp;order=pubdate&amp;jsonp=jsonp</code></pre><pre><code>其中，**mid**为up主的id号，**pn**为视频页号。</code></pre><h5 id="视频bv号批量获取"><a href="#视频bv号批量获取" class="headerlink" title="视频bv号批量获取"></a>视频bv号批量获取</h5><pre><code>从上述方式获取到的json文件中，我们可以不仅可以推断视频页的**总页数**，还能获取到当前页**所有视频的BV号以及作者信息**，根据BV号就能使用前面获取单个视频弹幕的代码来逐一获取当前页号下所有视频的弹幕了。</code></pre><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/6.png" class=""><h5 id="爬虫封装-1"><a href="#爬虫封装-1" class="headerlink" title="爬虫封装"></a>爬虫封装</h5><p>完整代码如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> bilibili_danmu <span class="hljs-keyword">import</span> BiliBiliDanMuuper_name = <span class="hljs-literal">None</span><span class="hljs-comment"># 获取某个up主的全部视频的弹幕</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllBv</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, up_id</span>):</span>        self.up_id = up_id        self.headers = &#123;            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)\</span><span class="hljs-string">                     AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Edg/85.0.564.44&quot;</span>        &#125;    <span class="hljs-comment"># 获取视频总页数</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pages_num</span>(<span class="hljs-params">self</span>):</span>        url = <span class="hljs-string">&#x27;https://api.bilibili.com/x/space/arc/search?mid=&#123;&#125;\</span><span class="hljs-string">        &amp;ps=30&amp;tid=0&amp;pn=1&amp;keyword=&amp;order=pubdate&amp;jsonp=jsonp&#x27;</span>.<span class="hljs-built_in">format</span>(self.up_id)        response = requests.get(url=url, headers=self.headers)        json_dict = json.loads(response.content.decode())        video_dict = json_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-string">&#x27;tlist&#x27;</span>]        total_videos = <span class="hljs-number">0</span>        <span class="hljs-keyword">global</span> uper_name        <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> video_dict.items():            total_videos += v[<span class="hljs-string">&#x27;count&#x27;</span>]        <span class="hljs-keyword">for</span> comment <span class="hljs-keyword">in</span> json_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-string">&#x27;vlist&#x27;</span>]:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(comment[<span class="hljs-string">&#x27;mid&#x27;</span>]) == self.up_id:                uper_name = comment[<span class="hljs-string">&#x27;author&#x27;</span>]            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">continue</span>        <span class="hljs-comment"># 每页最多30个视频</span>        <span class="hljs-keyword">return</span> uper_name, <span class="hljs-built_in">int</span>(total_videos / <span class="hljs-number">30</span> + <span class="hljs-number">1</span>)    <span class="hljs-comment"># 获取返回的json</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pages_json</span>(<span class="hljs-params">self, total_pages</span>):</span>        json_dict_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, total_pages + <span class="hljs-number">1</span>):            url = <span class="hljs-string">&#x27;https://api.bilibili.com/x/space/arc/search?mid=&#123;&#125;&amp;ps=30&amp;tid=0&amp;pn=&#123;&#125; \</span><span class="hljs-string">            &amp;keyword=&amp;order=pubdate&amp;jsonp=jsonp&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(self.up_id), <span class="hljs-built_in">str</span>(i))            response = requests.get(url=url, headers=self.headers)            json_dict_lst.append(json.loads(response.content.decode()))        <span class="hljs-keyword">return</span> json_dict_lst    <span class="hljs-comment"># 从json文件中获取bv号列表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_bv_from_json</span>(<span class="hljs-params">self, json_dict</span>):</span>        v_lst = json_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-string">&#x27;vlist&#x27;</span>]        bv_lst = []        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> v_lst:            bv_lst.append(item[<span class="hljs-string">&#x27;bvid&#x27;</span>][<span class="hljs-number">2</span>:])        <span class="hljs-keyword">return</span> bv_lst    <span class="hljs-comment"># 将得到的bv号列表存到一个txt文件中，文件夹名字以up主名字命名</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_bv_lst</span>(<span class="hljs-params">self, bv_lst, au_name</span>):</span>        folder = au_name        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(folder):            os.mkdir(folder)        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(au_name + <span class="hljs-string">&#x27;/bv_lst.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:            lines = []            <span class="hljs-keyword">for</span> bv_id <span class="hljs-keyword">in</span> bv_lst:                lines.append(bv_id + <span class="hljs-string">&#x27;\n&#x27;</span>)            f.writelines(lines)    <span class="hljs-comment"># 封装爬取过程，返回up主的名字和所有视频的bv号列表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span>(<span class="hljs-params">self</span>):</span>        up_name, pages_total = self.get_pages_num()        bv_video_lst = []        json_dict_lst = self.get_pages_json(pages_total)        <span class="hljs-keyword">for</span> json_file <span class="hljs-keyword">in</span> json_dict_lst:            bv_lst = self.get_bv_from_json(json_file)            bv_video_lst = bv_video_lst + bv_lst            self.save_bv_lst(bv_lst, <span class="hljs-string">&#x27;./&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(up_name))        <span class="hljs-keyword">return</span> up_name, bv_video_lst<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    up_id = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input up_id: &quot;</span>)    <span class="hljs-comment"># 实例化</span>    abm = AllBv(up_id)    author_name, bv_video_list = abm.crawl()    <span class="hljs-comment"># 借助单独一个bv视频弹幕爬取的类BiliBiliDanMu进行弹幕的爬取</span>    <span class="hljs-keyword">for</span> bv <span class="hljs-keyword">in</span> bv_video_list:        bm = BiliBiliDanMu(bv, <span class="hljs-string">&#x27;./&#123;&#125;/&#123;&#125;.txt&#x27;</span>.<span class="hljs-built_in">format</span>(author_name, <span class="hljs-built_in">str</span>(bv)))        bm.crawl()</code></pre><h4 id="制作词云"><a href="#制作词云" class="headerlink" title="制作词云"></a>制作词云</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> wordcloud <span class="hljs-keyword">import</span> WordCloud<span class="hljs-keyword">import</span> jieba<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 1:打开词云文本</span>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<span class="hljs-comment"># 2:用jieba进行分词</span>txt_cut = <span class="hljs-string">&quot;&quot;</span>.join(jieba.cut(txt, cut_all=<span class="hljs-literal">False</span>) )<span class="hljs-comment"># 3:设置词云的属性</span>font = <span class="hljs-string">&quot;C:\\Windows\\Fonts\\simkai.TTF&quot;</span>     <span class="hljs-comment"># 词云的中文字体所在路径，不设置字体的话，很可能出现乱码</span>wc = WordCloud(font_path=font,               background_color=<span class="hljs-string">&quot;white&quot;</span>,               height=<span class="hljs-number">800</span>,               width=<span class="hljs-number">1000</span>               )<span class="hljs-comment"># 4:生成词云</span>wc.generate(txt_cut)<span class="hljs-comment"># 5:存储词云</span>wc.to_file(<span class="hljs-string">&quot;./demo.png&quot;</span>)</code></pre><p>效果图如下：</p><img src="/2020/11/04/B%E7%AB%99%E5%BC%B9%E5%B9%95%E7%88%AC%E5%8F%96/7.png" class="">]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装部署neo4j</title>
    <link href="/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/"/>
    <url>/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/</url>
    
    <content type="html"><![CDATA[<h3 id="docker部署neo4j"><a href="#docker部署neo4j" class="headerlink" title="docker部署neo4j"></a>docker部署neo4j</h3><p>环境：ubuntu16.04LTS</p><h4 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h4><p>详见：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">菜鸟教程(docker安装)</a></p><h4 id="docker国内镜像源配置"><a href="#docker国内镜像源配置" class="headerlink" title="docker国内镜像源配置"></a>docker国内镜像源配置</h4><p>第一步，进入<a href="https://cr.console.aliyun.com/">阿里云</a>，登陆后点击左侧的镜像加速，生成自己的镜像加速地址。</p><img src="/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90.png" class="" title="阿里云镜像加速"><p>第二步，选择ubuntu，执行阿里云推荐的终端命令，即可更新docker的镜像源为阿里云镜像。</p><h4 id="docker部署neo4j-1"><a href="#docker部署neo4j-1" class="headerlink" title="docker部署neo4j"></a>docker部署neo4j</h4><h5 id="拉取neo4j镜像"><a href="#拉取neo4j镜像" class="headerlink" title="拉取neo4j镜像"></a>拉取neo4j镜像</h5><p>第一步，从镜像源中找合适的镜像</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> search neo<span class="hljs-number">4</span>j</code></pre><p>第二步，拉取镜像源</p><pre><code class="hljs gcode">docker pull <span class="hljs-symbol">neo4</span>j<span class="hljs-comment">(:版本号)</span> <span class="hljs-comment">//缺省 “:版本号” 时默认安装latest版本的</span></code></pre><p>第三步，查看本地镜像，检验是否拉取成功</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span></code></pre><img src="/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F.png" class="" title="本地镜像"><h5 id="构建neo4j容器"><a href="#构建neo4j容器" class="headerlink" title="构建neo4j容器"></a>构建neo4j容器</h5><p>第一步，在你根目录的任意一个子目录（我这里是/home)下建立四个基本的文件夹</p><ul><li>data——数据存放的文件夹</li><li>logs——运行的日志文件夹</li><li>conf——数据库配置文件夹（在配置文件<strong>neo4j.conf</strong>中配置包括开放远程连接、设置默认激活的数据库）</li><li>import——为了大批量导入csv来构建数据库，需要导入的节点文件<strong>nodes.csv</strong>和关系文件<strong>rel.csv</strong>需要放到这个文件夹下）</li></ul><pre><code class="hljs haml">docker run -d --name container_name \  //-d表示容器后台运行 --name指定容器名字-<span class="ruby">p <span class="hljs-number">7474</span><span class="hljs-symbol">:</span><span class="hljs-number">7474</span> -p <span class="hljs-number">7687</span><span class="hljs-symbol">:</span><span class="hljs-number">7687</span> \  /<span class="hljs-regexp">/映射容器的端口号到宿主机的端口号</span></span><span class="ruby">-v /home/neo4j/<span class="hljs-symbol">data:</span>/data \  /<span class="hljs-regexp">/把容器内的数据目录挂载到宿主机的对应目录下</span></span><span class="ruby">-v /home/neo4j/<span class="hljs-symbol">logs:</span>/logs \  /<span class="hljs-regexp">/挂载日志目录</span></span><span class="ruby">-v /home/neo4j/<span class="hljs-symbol">conf:</span>/var/lib/neo4j/conf   /<span class="hljs-regexp">/挂载配置目录</span></span><span class="ruby">-v /home/neo4j/<span class="hljs-symbol">import:</span>/var/lib/neo4j/import \  /<span class="hljs-regexp">/挂载数据导入目录</span></span><span class="ruby">--env NEO4J_AUTH=neo4j/password \  /<span class="hljs-regexp">/设定数据库的名字的访问密码</span></span><span class="ruby">neo4j /<span class="hljs-regexp">/指定使用的镜像</span></span></code></pre><p>一个可以直接复制粘贴到终端执行的代码模板</p><pre><code class="hljs awk">docker run -d --name container_name -p <span class="hljs-number">7474</span>:<span class="hljs-number">7474</span> -p <span class="hljs-number">7687</span>:<span class="hljs-number">7687</span> -v <span class="hljs-regexp">/home/</span>neo4j<span class="hljs-regexp">/data:/</span>data -v <span class="hljs-regexp">/home/</span>neo4j<span class="hljs-regexp">/logs:/</span>logs -v <span class="hljs-regexp">/home/</span>neo4j<span class="hljs-regexp">/conf:/</span>var<span class="hljs-regexp">/lib/</span>neo4j<span class="hljs-regexp">/conf -v /</span>home<span class="hljs-regexp">/neo4j/im</span>port:<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/neo4j/im</span>port --env NEO4J_AUTH=neo4j/password neo4j</code></pre><p>其中<strong>container_name</strong>可以自己指定，挂载在根目录下的子目录可以根据你自己的实际情况进行替换，我这里是<strong>/home</strong>。另外<strong>NEO4J_AUTH</strong>也是你自己来进行设置。</p><p>执行完上述命令后就在后台把neo4j容器启动起来了，这个时候你就能在宿主机的浏览器中输入</p><pre><code class="hljs angelscript">localhost:<span class="hljs-number">7474</span></code></pre><p>输入用户名和密码就能登录到数据库了。</p><img src="/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/neo4j%E7%95%8C%E9%9D%A2.png" class="" title="neo4j界面"><h5 id="neo4j配置"><a href="#neo4j配置" class="headerlink" title="neo4j配置"></a>neo4j配置</h5><p>上述方式启动的neo4j是按照默认的配置进行启动的，而默认的数据库配置是不允许远程登陆的，这样对于在服务器上使用docker搭载neo4j的同学来说，就很不方便了。所以我们对默认配置进行一些改变，改变如下：</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 进入容器配置目录挂载在宿主机的对应目录，我这里是<span class="hljs-regexp">/home/</span>neo4j/confcd <span class="hljs-regexp">/home/</span>neo4j/conf<span class="hljs-regexp">//</span> vim编辑器打开neo4j.confvim neo4j.conf<span class="hljs-regexp">//</span> 进行以下更改<span class="hljs-regexp">//</span>在文件配置末尾添加这一行dbms.connectors.default_listen_address=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>  <span class="hljs-regexp">//</span>指定连接器的默认监听ip为<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>，即允许任何ip连接到数据库<span class="hljs-regexp">//</span>修改dbms.connector.bolt.listen_address=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7687</span>  <span class="hljs-regexp">//</span>取消注释并把对bolt请求的监听“地址:端口”改为“<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7687</span>”dbms.connector.http.listen_address=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7474</span>  <span class="hljs-regexp">//</span>取消注释并把对http请求的监听“地址:端口”改为“<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">7474</span>”</code></pre><p>保存后退出，重启neo4j容器，可以使用容器的省略id或者生成容器时指定的容器名进行重启。</p><pre><code class="hljs applescript">docker restart 容器<span class="hljs-built_in">id</span>（或者容器名）</code></pre><p><strong>防火墙设置</strong></p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看当前防火墙状态，若为“inactive”，则防火墙已关闭，不必进行接续操作。sudo ufw status<span class="hljs-regexp">//</span> 若防火墙状态为“active”，则使用下列命令开放端口sudo ufw allow <span class="hljs-number">7474</span>sudo ufw allow <span class="hljs-number">7687</span><span class="hljs-regexp">//</span> 重启防火墙sudo ufw reload</code></pre><h4 id="neo4j数据导入"><a href="#neo4j数据导入" class="headerlink" title="neo4j数据导入"></a>neo4j数据导入</h4><p>neo4j数据的批量导入方法</p><img src="/2020/11/04/docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2neo4j/%E5%AF%BC%E5%85%A5%E6%96%B9%E6%B3%95.png" class="" title="导入方法"><p>为了加快速度，使用官方的<strong>Neo4j-import</strong>进行导入</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 数据准备清空data<span class="hljs-regexp">/databases/g</span>raph.db文件夹(如果有),将清洗好的结点文件nodes.csv和关系文件rel.csv拷贝到宿主机<span class="hljs-regexp">/home/</span>neo4j/import中<span class="hljs-regexp">//</span> docker以exec方式进入容器的交互式终端docker exec -it container_name(or container_id) <span class="hljs-regexp">/bin/</span>bash<span class="hljs-regexp">//</span> 停掉neo4jbin/neo4j stop<span class="hljs-regexp">//</span>使用如下命令导入bin/neo4j-admin import \--database=graph.db \        <span class="hljs-regexp">//</span>指定导入的数据库，没有系统则会在data/databases下自动创建一个--nodes .<span class="hljs-regexp">/import/</span>nodes.csv <span class="hljs-regexp">//</span>指定导入的节点文件位置--relationships .<span class="hljs-regexp">/import/</span>rel.csv <span class="hljs-regexp">//</span>指定导入的关系文件位置--skip-duplicate-nodes=true <span class="hljs-regexp">//</span>设置重复节点自动过滤--skip-bad-relationships=true <span class="hljs-regexp">//</span>设置bad关系自动过滤<span class="hljs-regexp">//</span>可执行一行式终端命令bin<span class="hljs-regexp">/neo4j-admin import --database=graph.db --nodes ./im</span>port<span class="hljs-regexp">/nodes.csv --relationships ./im</span>port/rel.csv --skip-duplicate-nodes=true --skip-bad-relationships=true<span class="hljs-regexp">//</span> 容器内启动neo4jbin/neo4j start<span class="hljs-regexp">//</span> 退出交互式终端但是保证neo4j后台继续运行ctrl + P + Q<span class="hljs-regexp">//</span>保险起见，重启neo4j容器docker restart container_name(or container_id)</code></pre><p>重启后使用另一台主机向服务器发送http请求进行远程登陆，在浏览器中输入</p><pre><code class="hljs angelscript">服务器ip:<span class="hljs-number">7474</span></code></pre><p><strong>切换连接模式</strong>为 <strong>bolt:/</strong> ，输入用户名和密码进行登陆，登陆成功发现在数据库一栏没找到新导入的数据库<strong>graph.db</strong></p><p>这是因为配置不够全，继续进到容器挂载到宿主机的<strong>/home/neo4j/conf</strong>中对<strong>neo4j.conf</strong>进行配置</p><pre><code class="hljs reasonml"><span class="hljs-comment">//在文件末尾添加默认的数据库</span>dbms.active_database=graph.db<span class="hljs-comment">// 保存后重启容器</span>docker restart container<span class="hljs-constructor">_name(<span class="hljs-params">or</span> <span class="hljs-params">container_id</span>)</span></code></pre><p>重新进行远程连接，此时数据库的默认选择应该就切换到了新导入的graph.db。</p><h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><p>数据如何清洗成两个符合neo4j-import导入格式的csv文件？</p><ul><li><a href="https://blog.csdn.net/muruibin88/article/details/106475757">ownthink_kg 1.4亿数据快速导入Neo4j</a></li><li><a href="https://github.com/jievince/rdf-converter">GO语言编写的开源数据清洗工具</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
